import { ParserOutput } from './parserOutput';
import { Token } from './tokens';
import { Option } from './option';
import { Result } from './result';
/**
 * The state for the argument wrapper.
 */
export interface ArgsState {
    /**
     * The indices of the ordered tokens already retrieved.
     */
    usedIndices: Set<number>;
    /**
     * The current position in the ordered tokens.
     * Increments from 0.
     */
    position: number;
    /**
     * The current position backwards in the ordered tokens.
     * Decrements from the end.
     */
    positionFromEnd: number;
}
/**
 * A wrapper around the parser output for retrieving command arguments.
 */
export declare class Args implements IterableIterator<string> {
    /**
     * The parser output.
     */
    readonly parserOutput: ParserOutput;
    /**
     * The state of this instance.
     */
    state: ArgsState;
    /**
     * @param parserOutput - The parser output.
     */
    constructor(parserOutput: ParserOutput);
    /**
     * Whether all ordered tokens have been used.
     */
    get finished(): boolean;
    /**
     * The amount of ordered tokens.
     */
    get length(): number;
    /**
     * The amount of remaining ordered tokens.
     */
    get remaining(): number;
    /**
     * Gets the next ordered argument.
     * @return An iterator result containing a string.
     */
    next(): IteratorResult<string>;
    [Symbol.iterator](): this;
    /**
     * Retrieves the value of the next unused ordered token.
     * That token will now be consider used.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * console.log(args.single());
     * >>> '1'
     *
     * console.log(args.single());
     * >>> '2'
     *
     * console.log(args.single());
     * >>> '3'
     *
     * console.log(args.single());
     * >>> null
     * ```
     *
     * @returns The value if there are tokens left.
     */
    single(): string | null;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be consider used if the transformation succeeds.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.singleMap(parse));
     * >>> { exists: true, value: 1 }
     * ```
     *
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param useAnyways - Whether to consider the token used even if the transformation fails; defaults to false.
     * @returns The value if the transformation succeeds.
     * If there are no tokens left, null is returned.
     */
    singleMap<T>(f: (x: string) => Option<T>, useAnyways?: boolean): Option<T> | null;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * This variant of the function is asynchronous using `Promise`.
     * That token will now be consider used if the transformation succeeds.
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param useAnyways - Whether to consider the token used even if the transformation fails; defaults to false.
     * @returns The value if the transformation succeeds.
     * If there are no tokens left, null is returned.
     */
    singleMapAsync<T>(f: (x: string) => Promise<Option<T>>, useAnyways?: boolean): Promise<Option<T> | null>;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be consider used if the transformation succeeds.
     * This is a variant of {@linkcode Args#singleMap} that allows for a Result to be returned.
     *
     * ```ts
     * // Suppose args are from '1 a'.
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return isNaN(n) ? err(x + ' is not a number') : ok(n);
     * };
     *
     * console.log(args.singleParse(parse));
     * >>> { success: true, value: 1 }
     *
     * console.log(args.singleParse(parse));
     * >>> { success: false, error: 'a is not a number' }
     *
     * console.log(args.singleParse(parse));
     * >>> null
     * ```
     *
     * @typeparam T - Output type.
     * @typeparam E - Error type.
     * @param f - Gives a result of either the resulting value, or an error.
     * @param useAnyways - Whether to consider the token used even if the transformation fails; defaults to false.
     * @returns The result which succeeds if the transformation succeeds.
     * If there are no tokens left, null is returned.
     */
    singleParse<T, E>(f: (x: string) => Result<T, E>, useAnyways?: boolean): Result<T, E> | null;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be consider used if the transformation succeeds.
     * This variant of the function is asynchronous using `Promise`.
     * This is a variant of {@linkcode Args#singleMapAsync} that allows for a Result to be returned.
     * @typeparam T - Output type.
     * @typeparam E - Error type.
     * @param f - Gives a result of either the resulting value, or an error.
     * @param useAnyways - Whether to consider the token used even if the transformation fails; defaults to false.
     * @returns The result which succeeds if the transformation succeeds.
     * If there are no tokens left, null is returned.
     */
    singleParseAsync<T, E>(f: (x: string) => Promise<Result<T, E>>, useAnyways?: boolean): Promise<Result<T, E> | null>;
    /**
     * Retrieves the value of the next unused ordered token from the end.
     * That token will now be consider used.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * console.log(args.singleFromEnd());
     * >>> '3'
     *
     * console.log(args.singleFromEnd());
     * >>> '2'
     *
     * console.log(args.singleFromEnd());
     * >>> '1'
     *
     * console.log(args.singleFromEnd());
     * >>> null
     * ```
     *
     * @returns The value if there are tokens left.
     */
    singleFromEnd(): string | null;
    /**
     * Retrieves many unused tokens.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * const xs = args.many();
     * console.log(joinTokens(xs));
     * >>> '1 2 3'
     *
     * // Suppose args are from '1 2 3'.
     * const xs = args.many(2);
     * console.log(joinTokens(xs));
     * >>> '1 2'
     * ```
     *
     * @param limit - The limit on the amount of tokens to retrieve; defaults to infinite.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The tokens.
     */
    many(limit?: number, from?: number): Token[];
    /**
     * Retrieves many unused tokens from the end.
     * Note that the order of retrieved tokens will be the same order as in the ordered tokens list.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * const xs = args.manyFromEnd();
     * console.log(joinTokens(xs));
     * >>> '1 2 3'
     *
     * // Suppose args are from '1 2 3'.
     * const xs = args.manyFromEnd(2);
     * console.log(joinTokens(xs));
     * >>> '2 3'
     * ```
     *
     * @param limit - The limit on the amount of tokens to retrieve; defaults to infinite.
     * @param from - Where to start looking for tokens; defaults to current position from end.
     * @returns The tokens.
     */
    manyFromEnd(limit?: number, from?: number): Token[];
    /**
     * Checks if a flag was given.
     *
     * ```ts
     * // Suppose args are from '--f --g'.
     * console.log(args.flag('f'));
     * >>> true
     *
     * console.log(args.flag('g', 'h'));
     * >>> true
     *
     * console.log(args.flag('h'));
     * >>> false
     * ```
     *
     * @param keys - The name(s) of the flag.
     * @returns Whether the flag was given.
     */
    flag(...keys: string[]): boolean;
    /**
     * Gets the last value of an option.
     *
     * ```ts
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.option('a'));
     * >>> '1'
     *
     * console.log(args.option('b', 'c'));
     * >>> '2'
     *
     * console.log(args.option('d'));
     * >>> null
     * ```
     *
     * @param keys - The name(s) of the option.
     * @returns The last value of the option if it was given.
     * When there are multiple names, the last value of the first found name is given.
     */
    option(...keys: string[]): string | null;
    /**
     * Gets all the values of an option.
     *
     * ```ts
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.options('a'));
     * >>> ['1', '1']
     *
     * console.log(args.option('b', 'c'));
     * >>> ['2', '3']
     *
     * console.log(args.option('d'));
     * >>> null
     * ```
     *
     * @param keys - The name(s) of the option.
     * @returns The values of the option if it was given.
     */
    options(...keys: string[]): string[] | null;
    /**
     * Finds and retrieves the first unused token that could be transformed.
     * That token will now be consider used.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return isNaN(n) || n === 1 ? none() : some(n);
     * };
     *
     * console.log(args.findMap(parse));
     * >>> { exists: true, value: 2 }
     * ```
     *
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting value if it was found.
     */
    findMap<T>(f: (x: string) => Option<T>, from?: number): Option<T>;
    /**
     * Finds and retrieves the first unused token that could be transformed.
     * This variant of the function is asynchronous using `Promise`.
     * That token will now be consider used.
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting value if it was found.
     */
    findMapAsync<T>(f: (x: string) => Promise<Option<T>>, from?: number): Promise<Option<T>>;
    /**
     * Finds and retrieves the first unused token that could be transformed.
     * That token will now be consider used.
     * This is a variant of {@linkcode Args#findMap} that allows for a Result to be returned.
     * @typeparam T - Output type.
     * @typeparam E - Error type.
     * @param f - Gives a result of either the resulting value, or an error.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting value if it was found or a list of errors during parsing.
     */
    findParse<T, E>(f: (x: string) => Result<T, E>, from?: number): Result<T, E[]>;
    /**
     * Finds and retrieves the first unused token that could be transformed.
     * That token will now be consider used.
     * This variant of the function is asynchronous using `Promise`.
     * This is a variant of {@linkcode Args#findMapAsync} that allows for a Result to be returned.
     * @typeparam T - Output type.
     * @typeparam E - Error type.
     * @param f - Gives a result of either the resulting value, or an error.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting value if it was found or a list of errors during parsing.
     */
    findParseAsync<T, E>(f: (x: string) => Promise<Result<T, E>>, from?: number): Promise<Result<T, E[]>>;
    /**
     * Filters and retrieves all unused tokens that could be transformed.
     * Those tokens will now be consider used.
     *
     * ```ts
     * // Suppose args are from '1 2 3'.
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return isNaN(n) || n === 1 ? none() : some(n);
     * };
     *
     * console.log(args.filterMap(parse));
     * >>> [2, 3]
     * ```
     *
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param limit - The limit on the amount of tokens to retrieve; defaults to infinite.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting values.
     */
    filterMap<T>(f: (x: string) => Option<T>, limit?: number, from?: number): T[];
    /**
     * Filters and retrieves all unused tokens that could be transformed.
     * This variant of the function is asynchronous using `Promise`.
     * Those tokens will now be consider used.
     * @typeparam T - Output type.
     * @param f - Gives an option of either the resulting value, or nothing if failed.
     * @param limit - The limit on the amount of tokens to retrieve; defaults to infinite.
     * @param from - Where to start looking for tokens; defaults to current position.
     * @returns The resulting values.
     */
    filterMapAsync<T>(f: (x: string) => Promise<Option<T>>, limit?: number, from?: number): Promise<T[]>;
    /**
     * Saves the current state that can then be restored later by using {@linkcode Args#restore}.
     * @returns The current state.
     */
    save(): ArgsState;
    /**
     * Sets the current state to the given state from {@linkcode Args#save}.
     * Use this to backtrack after a series of retrievals.
     * @param state - State to restore to.
     */
    restore(state: ArgsState): void;
}
