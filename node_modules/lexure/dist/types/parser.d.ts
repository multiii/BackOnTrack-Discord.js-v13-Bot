import { UnorderedStrategy } from './unordered';
import { Token } from './tokens';
import { ParserOutput } from './parserOutput';
/**
 * Parses a list of tokens to separate out flags and options.
 */
export declare class Parser implements IterableIterator<ParserOutput>, Iterator<ParserOutput, null, ParserOutput | undefined> {
    private input;
    private unorderedStrategy;
    private position;
    /**
     * @param input - The input tokens.
     */
    constructor(input?: Token[]);
    /**
     * Sets the input to use.
     * This will reset the parser.
     * @param input - Input to use.
     * @returns The parser.
     */
    setInput(input: Token[]): this;
    /**
     * Sets the strategy for parsing unordered arguments.
     * This can be done in the middle of parsing.
     *
     * ```ts
     * const parser = new Parser(tokens)
     *   .setUnorderedStrategy(longStrategy())
     *   .parse();
     * ```
     *
     * @returns The parser.
     */
    setUnorderedStrategy(s: UnorderedStrategy): this;
    /**
     * Resets the state of the parser.
     * @return The parser.
     */
    reset(): this;
    /**
     * Whether the parser is finished.
     */
    get finished(): boolean;
    private shift;
    /**
     * Gets the next parsed tokens.
     * If a parser output is passed in, that output will be mutated, otherwise a new one is made.
     * @param output - Parser output to mutate.
     * @returns An iterator result containing parser output.
     */
    next(output?: ParserOutput): IteratorResult<ParserOutput>;
    private processToken;
    private pFlag;
    private pOption;
    private pCompactOption;
    private pOrdered;
    [Symbol.iterator](): this;
    /**
     * Runs the parser.
     *
     * ```ts
     * const lexer = new Lexer(input);
     * const tokens = lexer.lex();
     * const parser = new Parser(tokens);
     * const output = parser.parse();
     * ```
     *
     * @returns The parser output.
     */
    parse(): ParserOutput;
}
