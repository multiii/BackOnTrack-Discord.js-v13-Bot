"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const unordered_1 = require("./unordered");
const parserOutput_1 = require("./parserOutput");
/**
 * Parses a list of tokens to separate out flags and options.
 */
class Parser {
    /**
     * @param input - The input tokens.
     */
    constructor(input) {
        this.unorderedStrategy = unordered_1.noStrategy();
        this.position = 0;
        this.input = input !== null && input !== void 0 ? input : [];
    }
    /**
     * Sets the input to use.
     * This will reset the parser.
     * @param input - Input to use.
     * @returns The parser.
     */
    setInput(input) {
        this.input = input;
        this.reset();
        return this;
    }
    /**
     * Sets the strategy for parsing unordered arguments.
     * This can be done in the middle of parsing.
     *
     * ```ts
     * const parser = new Parser(tokens)
     *   .setUnorderedStrategy(longStrategy())
     *   .parse();
     * ```
     *
     * @returns The parser.
     */
    setUnorderedStrategy(s) {
        this.unorderedStrategy = s;
        return this;
    }
    /**
     * Resets the state of the parser.
     * @return The parser.
     */
    reset() {
        this.position = 0;
        return this;
    }
    /**
     * Whether the parser is finished.
     */
    get finished() {
        return this.position >= this.input.length;
    }
    shift(n) {
        this.position += n;
    }
    /**
     * Gets the next parsed tokens.
     * If a parser output is passed in, that output will be mutated, otherwise a new one is made.
     * @param output - Parser output to mutate.
     * @returns An iterator result containing parser output.
     */
    next(output) {
        if (this.finished) {
            return { done: true, value: null };
        }
        const ts = this.processToken(output);
        if (ts == null) {
            throw new Error('Unexpected end of input (this should never happen).');
        }
        return { done: false, value: ts };
    }
    processToken(output) {
        return this.pFlag(output)
            || this.pOption(output)
            || this.pCompactOption(output)
            || this.pOrdered(output);
    }
    pFlag(output = parserOutput_1.emptyOutput()) {
        const t = this.input[this.position];
        const f = this.unorderedStrategy.matchFlag(t.value);
        if (f == null) {
            return null;
        }
        this.shift(1);
        output.flags.add(f);
        return output;
    }
    pOption(output = parserOutput_1.emptyOutput()) {
        const t = this.input[this.position];
        const o = this.unorderedStrategy.matchOption(t.value);
        if (o == null) {
            return null;
        }
        this.shift(1);
        if (!output.options.has(o)) {
            output.options.set(o, []);
        }
        const n = this.input[this.position];
        if (n == null) {
            return output;
        }
        const bad = (this.unorderedStrategy.matchFlag(n.value)
            || this.unorderedStrategy.matchOption(n.value)
            || this.unorderedStrategy.matchCompactOption(n.value)) != null;
        if (bad) {
            return output;
        }
        this.shift(1);
        const xs = output.options.get(o);
        xs.push(n.value);
        return output;
    }
    pCompactOption(output = parserOutput_1.emptyOutput()) {
        const t = this.input[this.position];
        const o = this.unorderedStrategy.matchCompactOption(t.value);
        if (o == null) {
            return null;
        }
        this.shift(1);
        if (!output.options.has(o[0])) {
            output.options.set(o[0], [o[1]]);
        }
        else {
            const a = output.options.get(o[0]);
            a.push(o[1]);
        }
        return output;
    }
    pOrdered(output = parserOutput_1.emptyOutput()) {
        const t = this.input[this.position];
        this.shift(1);
        output.ordered.push(t);
        return output;
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
     * Runs the parser.
     *
     * ```ts
     * const lexer = new Lexer(input);
     * const tokens = lexer.lex();
     * const parser = new Parser(tokens);
     * const output = parser.parse();
     * ```
     *
     * @returns The parser output.
     */
    parse() {
        const output = parserOutput_1.emptyOutput();
        let r = this.next(output);
        while (!r.done) {
            r = this.next(output);
        }
        return output;
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map