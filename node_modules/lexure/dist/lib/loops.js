"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loop1Async = exports.loopAsync = exports.loop1 = exports.loop = void 0;
const loopAction_1 = require("./loopAction");
const result_1 = require("./result");
const { STEP, FINISH, FAIL } = loopAction_1.LoopTag;
/**
 * Runs a loop which continuously gets input and attempts to parse it.
 * The loop strategy used will determine how the loop continues and ends.
 *
 * ```ts
 * const getInputFromSomewhere = () => '2';
 *
 * const x = loop('1', {
 *   getInput() {
 *     const i = getInputFromSomewhere();
 *     return i == null ? fail('no input') : step(i);
 *   },
 *
 *   parse(x: string) {
 *     const n = Number(x);
 *     return isNaN(n) ? fail('bad input') : finish(n);
 *   }
 * });
 *
 * console.log(x);
 * >>> 1
 * ```
 *
 * @typeparam A - Input type.
 * @typeparam Z - Output type.
 * @typeparam E - Error type.
 * @param intialInput - The first input to parse.
 * @param strat - The loop strategy to use.
 * @returns Either the parsed value or an error.
 */
function loop(intialInput, strat) {
    var _a, _b, _c, _d;
    let inp = intialInput;
    let parsed = strat.parse(inp);
    for (;;) {
        switch (parsed.action) {
            case FINISH:
                return result_1.ok(parsed.value);
            case FAIL: {
                const r = (_b = (_a = strat.onParseError) === null || _a === void 0 ? void 0 : _a.call(strat, parsed.error, inp)) !== null && _b !== void 0 ? _b : loopAction_1.step_();
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
        const got = strat.getInput();
        switch (got.action) {
            case STEP: {
                inp = got.item;
                parsed = strat.parse(inp);
                break;
            }
            case FINISH:
                return result_1.ok(got.value);
            case FAIL: {
                const r = (_d = (_c = strat.onInputError) === null || _c === void 0 ? void 0 : _c.call(strat, got.error)) !== null && _d !== void 0 ? _d : loopAction_1.fail(got.error);
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
    }
}
exports.loop = loop;
/**
 * Runs a loop which continuously gets input and attempts to parse it.
 * The loop strategy used will determine how the loop continues and ends.
 * This variant has no initial input.
 *
 * ```ts
 * const getInputFromSomewhere = () => '2';
 *
 * const x = loop1({
 *   getInput() {
 *     const i = getInputFromSomewhere();
 *     return i == null ? fail('no input') : step(i);
 *   },
 *
 *   parse(x: string) {
 *     const n = Number(x);
 *     return isNaN(n) ? fail('bad input') : finish(n);
 *   }
 * });
 *
 * console.log(x);
 * >>> 2
 * ```
 *
 * @typeparam A - Input type.
 * @typeparam Z - Output type.
 * @typeparam E - Error type.
 * @param strat - The loop strategy to use.
 * @returns Either the parsed value or an error.
 */
function loop1(strat) {
    var _a, _b, _c, _d;
    for (;;) {
        const got = strat.getInput();
        switch (got.action) {
            case STEP: {
                const inp = got.item;
                const parsed = strat.parse(inp);
                switch (parsed.action) {
                    case FINISH:
                        return result_1.ok(parsed.value);
                    case FAIL: {
                        const r = (_b = (_a = strat.onParseError) === null || _a === void 0 ? void 0 : _a.call(strat, parsed.error, inp)) !== null && _b !== void 0 ? _b : loopAction_1.step_();
                        switch (r.action) {
                            case FINISH:
                                return result_1.ok(r.value);
                            case FAIL:
                                return result_1.err(r.error);
                        }
                    }
                }
                break;
            }
            case FINISH:
                return result_1.ok(got.value);
            case FAIL: {
                const r = (_d = (_c = strat.onInputError) === null || _c === void 0 ? void 0 : _c.call(strat, got.error)) !== null && _d !== void 0 ? _d : loopAction_1.fail(got.error);
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
    }
}
exports.loop1 = loop1;
/**
 * Runs a loop which continuously gets input and attempts to parse it.
 * The loop strategy used will determine how the loop continues and ends.
 * This variant of the function is asynchronous using `Promise`.
 * @typeparam A - Input type.
 * @typeparam Z - Output type.
 * @typeparam E - Error type.
 * @param intialInput - The first input to parse.
 * @param strat - The loop strategy to use.
 * @returns Either the parsed value or an error.
 */
async function loopAsync(intialInput, strat) {
    var _a, _b, _c, _d;
    let inp = intialInput;
    let parsed = await strat.parse(inp);
    for (;;) {
        switch (parsed.action) {
            case FINISH:
                return result_1.ok(parsed.value);
            case FAIL: {
                const r = (_b = await ((_a = strat.onParseError) === null || _a === void 0 ? void 0 : _a.call(strat, parsed.error, inp))) !== null && _b !== void 0 ? _b : loopAction_1.step_();
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
        const got = await strat.getInput();
        switch (got.action) {
            case STEP: {
                inp = got.item;
                parsed = await strat.parse(inp);
                break;
            }
            case FINISH:
                return result_1.ok(got.value);
            case FAIL: {
                const r = (_d = await ((_c = strat.onInputError) === null || _c === void 0 ? void 0 : _c.call(strat, got.error))) !== null && _d !== void 0 ? _d : loopAction_1.fail(got.error);
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
    }
}
exports.loopAsync = loopAsync;
/**
 * Runs a loop which continuously gets input and attempts to parse it.
 * The loop strategy used will determine how the loop continues and ends.
 * This variant has no initial input.
 * This variant of the function is asynchronous using `Promise`.
 * @typeparam A - Input type.
 * @typeparam Z - Output type.
 * @typeparam E - Error type.
 * @param strat - The loop strategy to use.
 * @returns Either the parsed value or an error.
 */
async function loop1Async(strat) {
    var _a, _b, _c, _d;
    for (;;) {
        const got = await strat.getInput();
        switch (got.action) {
            case STEP: {
                const inp = got.item;
                const parsed = await strat.parse(inp);
                switch (parsed.action) {
                    case FINISH:
                        return result_1.ok(parsed.value);
                    case FAIL: {
                        const r = (_b = await ((_a = strat.onParseError) === null || _a === void 0 ? void 0 : _a.call(strat, parsed.error, inp))) !== null && _b !== void 0 ? _b : loopAction_1.step_();
                        switch (r.action) {
                            case FINISH:
                                return result_1.ok(r.value);
                            case FAIL:
                                return result_1.err(r.error);
                        }
                    }
                }
                break;
            }
            case FINISH:
                return result_1.ok(got.value);
            case FAIL: {
                const r = (_d = await ((_c = strat.onInputError) === null || _c === void 0 ? void 0 : _c.call(strat, got.error))) !== null && _d !== void 0 ? _d : loopAction_1.fail(got.error);
                switch (r.action) {
                    case FINISH:
                        return result_1.ok(r.value);
                    case FAIL:
                        return result_1.err(r.error);
                }
            }
        }
    }
}
exports.loop1Async = loop1Async;
//# sourceMappingURL=loops.js.map