"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.outputFromJSON = exports.outputToJSON = exports.mergeOutputs = exports.emptyOutput = void 0;
/**
 * Creates an empty parser output.
 * @returns An empty output.
 */
function emptyOutput() {
    return {
        ordered: [],
        flags: new Set(),
        options: new Map()
    };
}
exports.emptyOutput = emptyOutput;
/**
 * Merges multiple outputs into one.
 * Flags and options that appear later will be preferred if there are duplicates.
 * @param ps - The outputs to merge.
 * @returns The merged output.
 */
function mergeOutputs(...ps) {
    const output = emptyOutput();
    for (const p of ps) {
        output.ordered.push(...p.ordered);
        for (const f of p.flags) {
            output.flags.add(f);
        }
        for (const [o, xs] of p.options.entries()) {
            if (!output.options.has(o)) {
                output.options.set(o, []);
            }
            const ys = output.options.get(o);
            ys.push(...xs);
        }
    }
    return output;
}
exports.mergeOutputs = mergeOutputs;
/**
 * Converts an output to JSON, where the flags and options are turned into arrays of entries.
 * You can recover the output with 'outputFromJSON'.
 * @param p - The output.
 * @returns The JSON.
 */
function outputToJSON(p) {
    return {
        ordered: p.ordered,
        flags: [...p.flags],
        options: [...p.options]
    };
}
exports.outputToJSON = outputToJSON;
/**
 * Converts JSON to a parser output.
 * @param obj - A valid JSON input, following the schema from 'outputToJSON'.
 * @returns The output.
 */
function outputFromJSON(obj) {
    return {
        ordered: obj.ordered,
        flags: new Set(obj.flags),
        options: new Map(obj.options)
    };
}
exports.outputFromJSON = outputFromJSON;
//# sourceMappingURL=parserOutput.js.map