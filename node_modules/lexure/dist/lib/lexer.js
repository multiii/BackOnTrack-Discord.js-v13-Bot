"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = void 0;
const tokens_1 = require("./tokens");
/**
 * The lexer turns input into a list of tokens.
 */
class Lexer {
    /**
     * @param input - Input string.
     */
    constructor(input) {
        this.quotes = [];
        this.position = 0;
        this.input = input !== null && input !== void 0 ? input : '';
        if (input != null) {
            this.pWs();
        }
    }
    /**
     * Sets the input to use.
     * This will reset the lexer.
     * @param input - Input to use.
     * @returns The lexer.
     */
    setInput(input) {
        this.input = input;
        this.reset();
        this.pWs();
        return this;
    }
    /**
     * Sets the quotes to use.
     * This can be done in the middle of lexing.
     *
     * ```ts
     * const lexer = new Lexer('"hello"');
     * lexer.setQuotes([['"', '"']]);
     * const xs = lexer.lex();
     * console.log(xs);
     * >>> [{ value: 'hello', raw: '"hello"', trailing: '' }]
     * ```
     *
     * @param quotes - List of pairs of open and close quotes.
     * It is required that these strings do not contain any whitespace characters.
     * The matching of these quotes will be case-sensitive.
     * @returns The lexer.
     */
    setQuotes(quotes) {
        this.quotes = quotes;
        return this;
    }
    /**
     * Resets the position of the lexer.
     * @return The lexer.
     */
    reset() {
        this.position = 0;
        return this;
    }
    /**
     * Whether the lexer is finished.
     */
    get finished() {
        return this.position >= this.input.length;
    }
    match(s) {
        const sub = this.input.slice(this.position, this.position + s.length);
        if (s === sub) {
            return sub;
        }
        return null;
    }
    matchR(r) {
        return this.input.slice(this.position).match(r);
    }
    shift(n) {
        this.position += n;
    }
    /**
     * Gets the next token.
     * @returns An iterator result containing the next token.
     */
    next() {
        if (this.finished) {
            return { done: true, value: null };
        }
        const t = this.nextToken();
        if (t == null) {
            throw new Error('Unexpected end of input (this should never happen).');
        }
        return { done: false, value: t };
    }
    nextToken() {
        return this.pQuoted() || this.pWord();
    }
    pWs() {
        var _a, _b;
        const w = (_b = (_a = this.matchR(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : '';
        this.shift(w.length);
        return w;
    }
    pQuoted() {
        var _a;
        for (const [openQ, closeQ] of this.quotes) {
            const open = this.match(openQ);
            if (open == null) {
                continue;
            }
            this.shift(open.length);
            let inner = this.input.slice(this.position);
            inner = sliceTo(inner, [closeQ]);
            this.shift(inner.length);
            const close = (_a = this.match(closeQ)) !== null && _a !== void 0 ? _a : '';
            this.shift(close.length);
            const s = this.pWs();
            return { value: inner, raw: open + inner + close, trailing: s };
        }
        return null;
    }
    pWord() {
        var _a;
        let w = (_a = this.matchR(/^\S+/)) === null || _a === void 0 ? void 0 : _a[0];
        if (w == null) {
            return null;
        }
        w = sliceTo(w, this.quotes.flat());
        this.shift(w.length);
        const s = this.pWs();
        return { value: w, raw: w, trailing: s };
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
     * Runs the lexer.
     * This consumes the lexer.
     *
     * ```ts
     * const lexer = new Lexer('hello world');
     * const xs = lexer.lex();
     * console.log(xs);
     * >>> [
     *   { value: 'hello', raw: 'hello', trailing: ' ' },
     *   { value: 'world', raw: 'world', trailing: '' }
     * ]
     * ```
     *
     * @returns All the tokens lexed.
     */
    lex() {
        return [...this];
    }
    /**
     * Runs the lexer, matching a prefix and command.
     * This consumes at most two tokens of the lexer.
     * This uses {@linkcode extractCommand} under the hood.
     *
     * ```ts
     * const lexer = new Lexer('!help me');
     * const r = lexer.lexCommand(s => s.startsWith('!') ? 1 : null);
     * if (r != null) {
     *   const [command, getRest] = r;
     *   console.log(command.value);
     *   >>> 'help'
     *   console.log(getRest()[0].value);
     *   >>> 'me'
     * }
     * ```
     *
     * @param matchPrefix - A function that gives the length of the prefix if there is one.
     * @returns The command and the rest of the lexed tokens, as long as the prefix was matched.
     * The rest of the tokens are delayed as a function.
     */
    lexCommand(matchPrefix) {
        const t1 = this.next();
        if (t1.done) {
            return null;
        }
        const cmd1 = tokens_1.extractCommand(matchPrefix, [t1.value]);
        if (cmd1 != null) {
            return [cmd1, () => [...this]];
        }
        const t2 = this.next();
        if (t2.done) {
            return null;
        }
        const cmd2 = tokens_1.extractCommand(matchPrefix, [t1.value, t2.value]);
        if (cmd2 == null) {
            return null;
        }
        return [cmd2, () => [...this]];
    }
}
exports.Lexer = Lexer;
function sliceTo(word, xs) {
    const is = xs.map(x => word.indexOf(x)).filter(x => x !== -1);
    if (is.length === 0) {
        return word;
    }
    const i = Math.min(...is);
    return word.slice(0, i);
}
//# sourceMappingURL=lexer.js.map