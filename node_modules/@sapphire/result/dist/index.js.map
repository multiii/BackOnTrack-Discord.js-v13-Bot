{"version":3,"sources":["../src/index.ts","../src/lib/Maybe.ts","../src/lib/Result.ts","../src/lib/Parsers.ts"],"sourcesContent":["export * from './lib/Lexure';\nexport * from './lib/Maybe';\nexport * from './lib/Result';\nexport * from './lib/Parsers';\n","import type { None, Some } from './Lexure';\n\n/**\n * A type used to express a value that may or may not exist.\n * @typeparam T The value's type.\n */\nexport type Maybe<T> = Some<T> | None;\n\n/**\n * Returns the maybe itself.\n * @param value The value to convert.\n */\nexport function maybe<T, V extends Maybe<T>>(value: V): V;\n\n/**\n * Creates a {@link None} from an existing {@link None} or a `null`.\n * @param value The value to convert.\n */\nexport function maybe(value: null | None): None;\n\n/**\n * Creates a {@link Some} from a non-null value or an existing {@link Some}, or a {@link None} otherwise.\n * @param value The value to convert.\n */\nexport function maybe<T>(value: T | Maybe<T> | null): Maybe<T>;\n\n/**\n * Creates a {@link Some} from a non-null value or an existing {@link Some}.\n * @param value The value to convert.\n */\nexport function maybe<T>(value: T | Some<T>): Some<T>;\nexport function maybe<T>(value: T | Maybe<T> | null): Maybe<T> {\n\treturn isMaybe(value) ? value : value === null ? none() : some(value);\n}\n\n/**\n * Creates a None with no value.\n * @return An existing Maybe.\n */\nexport function some(): Some<unknown>;\n\n/**\n * Creates a None with a value.\n * @typeparam T The value's type.\n * @param x Value to use.\n * @return An existing Maybe.\n */\nexport function some<T>(x: T): Some<T>;\nexport function some<T>(x?: T): Some<unknown> {\n\treturn { exists: true, value: x };\n}\n\n/**\n * Creates a None value.\n * @return A non-existing Maybe.\n */\nexport function none(): None {\n\treturn { exists: false };\n}\n\n/**\n * Determines whether or not a Maybe is a Some.\n * @typeparam T The value's type.\n */\nexport function isSome<T>(x: Maybe<T>): x is Some<T> {\n\treturn x.exists;\n}\n\n/**\n * Determines whether or not a Maybe is a None.\n * @typeparam T The value's type.\n */\nexport function isNone<T>(x: Maybe<T>): x is None {\n\treturn !x.exists;\n}\n\n/**\n * Type-safe helper to preserve the type parameter's type.\n * @param x The value to check.\n */\nexport function isMaybe<T>(x: Maybe<T>): true;\n\n/**\n * Determines whether or not an arbitrary value is a Maybe.\n * @param x The value to check.\n */\nexport function isMaybe<T>(x: unknown): x is Maybe<T>;\nexport function isMaybe<T>(x: Maybe<T> | unknown): x is Maybe<T> {\n\treturn typeof x === 'object' && x !== null && typeof Reflect.get(x, 'exists') === 'boolean';\n}\n\nexport type UnwrapMaybeValue<T extends Maybe<unknown>> = T extends Some<infer V> ? V : never;\n","import type { Err, Ok } from './Lexure';\n\n/**\n * A type used to express computations that can fail.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport type Result<T, E> = Ok<T> | Err<E>;\n\n/**\n * Creates an Ok with no value.\n * @return A successful Result.\n */\nexport function ok(): Ok<unknown>;\n\n/**\n * Creates an Ok.\n * @typeparam T The result's type.\n * @param x Value to use.\n * @return A successful Result.\n */\nexport function ok<T>(x: T): Ok<T>;\nexport function ok<T>(x?: T): Ok<unknown> {\n\treturn { success: true, value: x };\n}\n\n/**\n * Creates an Err with no error.\n * @return An erroneous Result.\n */\nexport function err(): Err<unknown>;\n\n/**\n * Creates an Err.\n * @typeparam E The error's type.\n * @param x Value to use.\n * @return An erroneous Result.\n */\nexport function err<E>(x: E): Err<E>;\nexport function err<E>(x?: E): Err<unknown> {\n\treturn { success: false, error: x };\n}\n\n/**\n * Determines whether or not a result is an Ok.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport function isOk<T, E>(x: Result<T, E>): x is Ok<T> {\n\treturn x.success;\n}\n\n/**\n * Determines whether or not a result is an Err.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport function isErr<T, E>(x: Result<T, E>): x is Err<E> {\n\treturn !x.success;\n}\n","import { err, ok, Result } from './Result';\n\n/**\n * Creates a {@link Result} out of a callback.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport function from<T, E = unknown>(cb: (...args: unknown[]) => T): Result<T, E> {\n\ttry {\n\t\treturn ok(cb());\n\t} catch (error) {\n\t\treturn err(error as E);\n\t}\n}\n\n/**\n * Creates a {@link Result} out of a promise or async callback.\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n */\nexport async function fromAsync<T, E = unknown>(promiseOrCb: Awaitable<T> | ((...args: unknown[]) => Awaitable<T>)): Promise<Result<T, E>> {\n\ttry {\n\t\treturn ok(await (isFunction(promiseOrCb) ? promiseOrCb() : promiseOrCb));\n\t} catch (error) {\n\t\treturn err(error as E);\n\t}\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isFunction(input: unknown): input is Function {\n\treturn typeof input === 'function';\n}\n\ntype Awaitable<T> = PromiseLike<T> | T;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC+BO,eAAkB,OAAsC;AAC9D,SAAO,QAAQ,KAAK,IAAI,QAAQ,UAAU,OAAO,KAAK,IAAI,KAAK,KAAK;AACrE;AAFgB,AAiBT,cAAiB,GAAsB;AAC7C,SAAO,EAAE,QAAQ,MAAM,OAAO,EAAE;AACjC;AAFgB,AAQT,gBAAsB;AAC5B,SAAO,EAAE,QAAQ,MAAM;AACxB;AAFgB,AAQT,gBAAmB,GAA2B;AACpD,SAAO,EAAE;AACV;AAFgB,AAQT,gBAAmB,GAAwB;AACjD,SAAO,CAAC,EAAE;AACX;AAFgB,AAeT,iBAAoB,GAAsC;AAChE,SAAO,OAAO,MAAM,YAAY,MAAM,QAAQ,OAAO,QAAQ,IAAI,GAAG,QAAQ,MAAM;AACnF;AAFgB;;ACjET,YAAe,GAAoB;AACzC,SAAO,EAAE,SAAS,MAAM,OAAO,EAAE;AAClC;AAFgB,AAiBT,aAAgB,GAAqB;AAC3C,SAAO,EAAE,SAAS,OAAO,OAAO,EAAE;AACnC;AAFgB,AAST,cAAoB,GAA6B;AACvD,SAAO,EAAE;AACV;AAFgB,AAST,eAAqB,GAA8B;AACzD,SAAO,CAAC,EAAE;AACX;AAFgB;;AClDT,cAA8B,IAA6C;AACjF,MAAI;AACH,WAAO,GAAG,GAAG,CAAC;AAAA,EACf,SAAS,OAAP;AACD,WAAO,IAAI,KAAU;AAAA,EACtB;AACD;AANgB,AAahB,yBAAgD,aAA2F;AAC1I,MAAI;AACH,WAAO,GAAG,MAAO,YAAW,WAAW,IAAI,YAAY,IAAI,YAAY;AAAA,EACxE,SAAS,OAAP;AACD,WAAO,IAAI,KAAU;AAAA,EACtB;AACD;AANsB,AAStB,oBAAoB,OAAmC;AACtD,SAAO,OAAO,UAAU;AACzB;AAFS","names":[]}