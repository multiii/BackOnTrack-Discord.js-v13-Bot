var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/lib/arrayStrictEquals.ts
function arrayStrictEquals(arr1, arr2) {
  if (arr1 === arr2)
    return true;
  if (arr1.length !== arr2.length)
    return false;
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i] || typeof arr1[i] !== typeof arr2[i])
      return false;
  }
  return true;
}

// src/lib/cast.ts
function cast(value) {
  return value;
}

// src/lib/chunk.ts
function chunk(array, chunkSize) {
  if (!Array.isArray(array))
    throw new TypeError("entries must be an array.");
  if (!Number.isInteger(chunkSize))
    throw new TypeError("chunkSize must be an integer.");
  if (chunkSize < 1)
    throw new RangeError("chunkSize must be 1 or greater.");
  const clone = array.slice();
  const chunks = [];
  while (clone.length)
    chunks.push(clone.splice(0, chunkSize));
  return chunks;
}

// src/lib/classExtends.ts
function classExtends(value, base) {
  let ctor = value;
  while (ctor !== null) {
    if (ctor === base)
      return true;
    ctor = Object.getPrototypeOf(ctor);
  }
  return false;
}

// src/lib/codeBlock.ts
var zws = String.fromCharCode(8203);
function codeBlock(language, expression) {
  if (typeof expression === "string") {
    if (expression.length === 0)
      return `\`\`\`${zws}\`\`\``;
    return `\`\`\`${language}
${expression.replace(/```/, `\`${zws}\`\``).replace(/`$/g, `\`${zws}`)}\`\`\``;
  }
  return `\`\`\`${language}
${expression || zws}\`\`\``;
}

// src/lib/splitText.ts
function splitText(str, length, char = " ") {
  const x = str.substring(0, length).lastIndexOf(char);
  const pos = x === -1 ? length : x;
  return str.substring(0, pos);
}

// src/lib/cutText.ts
function cutText(str, length) {
  if (str.length < length)
    return str;
  const cut = splitText(str, length - 3);
  if (cut.length < length - 3)
    return `${cut}...`;
  return `${cut.slice(0, length - 3)}...`;
}

// src/lib/debounce/index.ts
function debounce(func, options = {}) {
  var _a;
  let lastArgs;
  let result;
  let timerId;
  let lastCallTime;
  let lastInvokeTime = 0;
  const wait = (_a = options.wait) != null ? _a : 0;
  const maxWait = typeof options.maxWait === "number" ? Math.max(options.maxWait, wait) : null;
  function invokeFunc(time) {
    const args = lastArgs;
    lastArgs = void 0;
    lastInvokeTime = time;
    result = func(...args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return result;
  }
  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const result2 = wait - timeSinceLastCall;
    return maxWait === null ? result2 : Math.min(result2, maxWait - timeSinceLastInvoke);
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxWait !== null && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      trailingEdge(time);
      return;
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    return invokeFunc(time);
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = void 0;
    lastCallTime = void 0;
    timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(Date.now());
  }
  function debounced(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    lastArgs = args;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxWait !== null) {
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

// src/lib/isPrimitive.ts
var primitiveTypes = ["string", "bigint", "number", "boolean"];
function isPrimitive(input) {
  return primitiveTypes.includes(typeof input);
}

// src/lib/deepClone.ts
function deepClone(source) {
  if (source === null || isPrimitive(source)) {
    return source;
  }
  if (source instanceof Date) {
    const output = new source.constructor(source);
    return output;
  }
  if (Array.isArray(source)) {
    const output = new source.constructor(source.length);
    for (let i = 0; i < source.length; i++) {
      output[i] = deepClone(source[i]);
    }
    return output;
  }
  if (source instanceof Map) {
    const output = new source.constructor();
    for (const [key, value] of source.entries()) {
      output.set(key, deepClone(value));
    }
    return output;
  }
  if (source instanceof Set) {
    const output = new source.constructor();
    for (const value of source.values()) {
      output.add(deepClone(value));
    }
    return output;
  }
  if (typeof source === "object") {
    const output = new source.constructor();
    for (const [key, value] of Object.entries(source)) {
      Object.defineProperty(output, key, {
        configurable: true,
        enumerable: true,
        value: deepClone(value),
        writable: true
      });
    }
    return output;
  }
  return source;
}

// src/lib/isNullOrUndefined.ts
function isNullOrUndefined(value) {
  return value === void 0 || value === null;
}

// src/lib/filterNullAndUndefined.ts
function filterNullAndUndefined(value) {
  return !isNullOrUndefined(value);
}

// src/lib/isNullOrUndefinedOrEmpty.ts
function isNullOrUndefinedOrEmpty(value) {
  return isNullOrUndefined(value) || value.length === 0;
}

// src/lib/filterNullAndUndefinedAndEmpty.ts
function filterNullAndUndefinedAndEmpty(value) {
  return !isNullOrUndefinedOrEmpty(value);
}

// src/lib/isNullOrUndefinedOrZero.ts
function isNullOrUndefinedOrZero(value) {
  return value === 0 || isNullOrUndefined(value);
}

// src/lib/filterNullAndUndefinedAndZero.ts
function filterNullAndUndefinedAndZero(value) {
  return !isNullOrUndefinedOrZero(value);
}

// src/lib/hasAtLeastOneKeyInMap.ts
function hasAtLeastOneKeyInMap(map, keys) {
  return keys.some((key) => map.has(key));
}

// src/lib/inlineCodeBlock.ts
var zws2 = String.fromCharCode(8203);
function inlineCodeBlock(input) {
  return `\`${input.replace(/ /g, "\xA0").replace(/`/g, `\`${zws2}`)}\``;
}

// src/lib/isClass.ts
function isClass(input) {
  return typeof input === "function" && typeof input.prototype === "object";
}

// src/lib/isFunction.ts
function isFunction(input) {
  return typeof input === "function";
}

// src/lib/isNumber.ts
function isNumber(input) {
  return typeof input === "number" && !isNaN(input) && Number.isFinite(input);
}

// src/lib/isObject.ts
function isObject(input, constructorType) {
  return typeof input === "object" && input ? input.constructor === (constructorType != null ? constructorType : Object) : false;
}

// src/lib/isThenable.ts
function hasThen(input) {
  return Reflect.has(input, "then") && isFunction(input.then);
}
function hasCatch(input) {
  return Reflect.has(input, "catch") && isFunction(input.catch);
}
function isThenable(input) {
  if (typeof input !== "object" || input === null)
    return false;
  return input instanceof Promise || input !== Promise.prototype && hasThen(input) && hasCatch(input);
}

// src/lib/makeObject.ts
function makeObject(path, value, obj = {}) {
  if (path.includes(".")) {
    const route = path.split(".");
    const lastKey = route.pop();
    let reference = obj;
    for (const key of route) {
      if (!reference[key])
        reference[key] = {};
      reference = reference[key];
    }
    reference[lastKey] = value;
  } else {
    obj[path] = value;
  }
  return obj;
}

// src/lib/mergeDefault.ts
function mergeDefault(base, overwrites) {
  if (!overwrites)
    return deepClone(base);
  for (const [baseKey, baseValue] of Object.entries(base)) {
    const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);
    if (typeof overwritesValueAtBaseKey === "undefined") {
      Reflect.set(overwrites, baseKey, deepClone(baseValue));
    } else if (isObject(overwritesValueAtBaseKey)) {
      Reflect.set(overwrites, baseKey, mergeDefault(baseValue != null ? baseValue : {}, overwritesValueAtBaseKey));
    }
  }
  return overwrites;
}

// src/lib/mergeObjects.ts
function mergeObjects(objTarget, objSource) {
  for (const [key, value] of Object.entries(objSource)) {
    const targetValue = Reflect.get(objTarget, key);
    if (isObject(value)) {
      Reflect.set(objTarget, key, isObject(targetValue) ? mergeObjects(targetValue, value) : value);
    } else if (!isObject(targetValue)) {
      Reflect.set(objTarget, key, value);
    }
  }
  return objTarget;
}

// src/lib/noop.ts
function noop() {
}

// src/lib/objectToTuples.ts
function objectToTuples(original, prefix = "") {
  const entries = [];
  for (const [key, value] of Object.entries(original)) {
    if (isObject(value)) {
      entries.push(...objectToTuples(value, `${prefix}${key}.`));
    } else {
      entries.push([`${prefix}${key}`, value]);
    }
  }
  return entries;
}

// src/lib/parseUrl.ts
function parseURL(url) {
  try {
    return new URL(url);
  } catch {
    return null;
  }
}

// src/lib/partition.ts
function partition(array, predicate) {
  if (!Array.isArray(array))
    throw new TypeError("entries must be an array.");
  if (!isFunction(predicate))
    throw new TypeError("predicate must be an function that returns a boolean value.");
  const partitionOne = [];
  const partitionTwo = [];
  for (let i = 0; i < array.length; i++) {
    if (predicate(array[i], i)) {
      partitionOne.push(array[i]);
    } else {
      partitionTwo.push(array[i]);
    }
  }
  return [partitionOne, partitionTwo];
}

// src/lib/range.ts
function range(min, max, step) {
  return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
}

// src/lib/regExpEsc.ts
var REGEXPESC = /[-/\\^$*+?.()|[\]{}]/g;
function regExpEsc(str) {
  return str.replace(REGEXPESC, "\\$&");
}

// src/lib/roundNumber.ts
function roundNumber(num, scale = 0) {
  if (!num.toString().includes("e")) {
    return Number(`${Math.round(Number(`${num}e+${scale}`))}e-${scale}`);
  }
  const arr = `${num}`.split("e");
  let sig = "";
  if (Number(arr[1]) + scale > 0) {
    sig = "+";
  }
  return Number(`${Math.round(Number(`${Number(arr[0])}e${sig}${Number(arr[1]) + scale}`))}e-${scale}`);
}

// src/lib/toTitleCase.ts
var TO_TITLE_CASE = /[A-Za-zÀ-ÖØ-öø-ÿ]\S*/g;
var baseVariants = {
  textchannel: "TextChannel",
  voicechannel: "VoiceChannel",
  categorychannel: "CategoryChannel",
  guildmember: "GuildMember"
};
function toTitleCase(str, options = {}) {
  const { additionalVariants = {}, caseSensitive } = options;
  const titleCaseVariants = {
    ...baseVariants,
    ...caseSensitive ? additionalVariants : Object.entries(additionalVariants).reduce((variants, [key, variant]) => ({ ...variants, [key.toLowerCase()]: variant }), {})
  };
  return str.replace(TO_TITLE_CASE, (txt) => {
    var _a;
    return (_a = titleCaseVariants[caseSensitive ? txt : txt.toLowerCase()]) != null ? _a : txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
  });
}

// src/lib/tryParse.ts
function tryParse(value) {
  try {
    return JSON.parse(value);
  } catch (err) {
    return value;
  }
}
export {
  arrayStrictEquals,
  cast,
  chunk,
  classExtends,
  codeBlock,
  cutText,
  debounce,
  deepClone,
  filterNullAndUndefined,
  filterNullAndUndefinedAndEmpty,
  filterNullAndUndefinedAndZero,
  filterNullAndUndefined as filterNullish,
  filterNullAndUndefinedAndEmpty as filterNullishOrEmpty,
  filterNullAndUndefinedAndZero as filterNullishOrZero,
  hasAtLeastOneKeyInMap,
  inlineCodeBlock,
  isClass,
  isFunction,
  isNullOrUndefined,
  isNullOrUndefinedOrEmpty,
  isNullOrUndefinedOrZero,
  isNullOrUndefined as isNullish,
  isNullOrUndefinedOrEmpty as isNullishOrEmpty,
  isNullOrUndefinedOrZero as isNullishOrZero,
  isNumber,
  isObject,
  isPrimitive,
  isThenable,
  makeObject,
  mergeDefault,
  mergeObjects,
  noop,
  objectToTuples,
  parseURL,
  partition,
  range,
  regExpEsc,
  roundNumber,
  splitText,
  toTitleCase,
  tryParse
};
/**
 * Split a string by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @param char The character to split with
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
/**
 * Split a text by its latest space character in a range from the character 0 to the selected one.
 * @param str The text to split.
 * @param length The length of the desired string.
 * @copyright 2019 Antonio Román
 * @license Apache-2.0
 */
//# sourceMappingURL=index.mjs.map