"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  LazyPaginatedMessage: () => LazyPaginatedMessage,
  MessageBuilder: () => MessageBuilder,
  MessagePrompter: () => MessagePrompter,
  MessagePrompterBaseStrategy: () => MessagePrompterBaseStrategy,
  MessagePrompterConfirmStrategy: () => MessagePrompterConfirmStrategy,
  MessagePrompterMessageStrategy: () => MessagePrompterMessageStrategy,
  MessagePrompterNumberStrategy: () => MessagePrompterNumberStrategy,
  MessagePrompterReactionStrategy: () => MessagePrompterReactionStrategy,
  PaginatedFieldMessageEmbed: () => PaginatedFieldMessageEmbed,
  PaginatedMessage: () => PaginatedMessage,
  PaginatedMessageEmbedFields: () => PaginatedMessageEmbedFields,
  actionIsButtonOrMenu: () => actionIsButtonOrMenu,
  canJoinVoiceChannel: () => canJoinVoiceChannel,
  canReact: () => canReact,
  canReadMessages: () => canReadMessages,
  canRemoveAllReactions: () => canRemoveAllReactions,
  canSendAttachments: () => canSendAttachments,
  canSendEmbeds: () => canSendEmbeds,
  canSendMessages: () => canSendMessages,
  createPartitionedMessageRow: () => createPartitionedMessageRow,
  isCategoryChannel: () => isCategoryChannel,
  isDMChannel: () => isDMChannel,
  isGroupChannel: () => isGroupChannel,
  isGuildBasedChannel: () => isGuildBasedChannel,
  isGuildBasedChannelByGuildKey: () => isGuildBasedChannelByGuildKey,
  isGuildMember: () => isGuildMember,
  isMessageButtonComponent: () => isMessageButtonComponent,
  isMessageButtonInteraction: () => isMessageButtonInteraction,
  isMessageInstance: () => isMessageInstance,
  isNewsChannel: () => isNewsChannel,
  isNewsThreadChannel: () => isNewsThreadChannel,
  isNsfwChannel: () => isNsfwChannel,
  isPrivateThreadChannel: () => isPrivateThreadChannel,
  isPublicThreadChannel: () => isPublicThreadChannel,
  isStageChannel: () => isStageChannel,
  isStoreChannel: () => isStoreChannel,
  isTextBasedChannel: () => isTextBasedChannel,
  isTextChannel: () => isTextChannel,
  isThreadChannel: () => isThreadChannel,
  isVoiceBasedChannel: () => isVoiceBasedChannel,
  isVoiceChannel: () => isVoiceChannel,
  runsOnInteraction: () => runsOnInteraction,
  safelyReplyToInteraction: () => safelyReplyToInteraction
});
module.exports = __toCommonJS(src_exports);
__reExport(src_exports, require("@sapphire/discord-utilities"), module.exports);

// src/lib/builders/MessageBuilder.ts
var _MessageBuilder = class {
  constructor(options) {
    __publicField(this, "tts");
    __publicField(this, "nonce");
    __publicField(this, "content");
    __publicField(this, "embeds");
    __publicField(this, "allowedMentions");
    __publicField(this, "files");
    this.tts = options?.tts ?? _MessageBuilder.defaults.tts;
    this.nonce = options?.nonce ?? _MessageBuilder.defaults.nonce;
    this.content = options?.content ?? _MessageBuilder.defaults.content;
    this.embeds = options?.embeds ?? _MessageBuilder.defaults.embeds;
    this.allowedMentions = options?.allowedMentions ?? _MessageBuilder.defaults.allowedMentions;
    this.files = options?.files ?? _MessageBuilder.defaults.files;
  }
  setTTS(tts) {
    this.tts = tts;
    return this;
  }
  setNonce(nonce) {
    this.nonce = nonce;
    return this;
  }
  setContent(content) {
    this.content = content;
    return this;
  }
  setEmbeds(embeds) {
    if (embeds && embeds.length > 10) {
      embeds = embeds.slice(0, 10);
    }
    this.embeds = embeds;
    return this;
  }
  setAllowedMentions(allowedMentions) {
    this.allowedMentions = allowedMentions;
    return this;
  }
  addFile(file) {
    this.files = this.files?.concat(file) ?? [file];
    return this;
  }
  setFile(file) {
    this.files = [file];
    return this;
  }
  setFiles(files) {
    this.files = files;
    return this;
  }
};
var MessageBuilder = _MessageBuilder;
__name(MessageBuilder, "MessageBuilder");
__publicField(MessageBuilder, "defaults", {});

// src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts
var import_utilities2 = require("@sapphire/utilities");

// src/lib/type-guards.ts
var import_utilities = require("@sapphire/utilities");
var import_discord = require("discord.js");
function isCategoryChannel(channel) {
  return channel?.type === "GUILD_CATEGORY";
}
__name(isCategoryChannel, "isCategoryChannel");
function isDMChannel(channel) {
  return channel?.type === "DM";
}
__name(isDMChannel, "isDMChannel");
function isGroupChannel(channel) {
  return channel?.type === "GROUP_DM";
}
__name(isGroupChannel, "isGroupChannel");
function isGuildBasedChannel(channel) {
  return channel?.type !== "DM";
}
__name(isGuildBasedChannel, "isGuildBasedChannel");
function isGuildBasedChannelByGuildKey(channel) {
  return Reflect.has(channel ?? {}, "guild");
}
__name(isGuildBasedChannelByGuildKey, "isGuildBasedChannelByGuildKey");
function isNewsChannel(channel) {
  return channel?.type === "GUILD_NEWS";
}
__name(isNewsChannel, "isNewsChannel");
function isStoreChannel(channel) {
  return channel?.type === "GUILD_STORE";
}
__name(isStoreChannel, "isStoreChannel");
function isTextChannel(channel) {
  return channel?.type === "GUILD_TEXT";
}
__name(isTextChannel, "isTextChannel");
function isVoiceChannel(channel) {
  return channel?.type === "GUILD_VOICE";
}
__name(isVoiceChannel, "isVoiceChannel");
function isStageChannel(channel) {
  return channel?.type === "GUILD_STAGE_VOICE";
}
__name(isStageChannel, "isStageChannel");
function isThreadChannel(channel) {
  return channel?.isThread() ?? false;
}
__name(isThreadChannel, "isThreadChannel");
function isNewsThreadChannel(channel) {
  return channel?.type === "GUILD_NEWS_THREAD";
}
__name(isNewsThreadChannel, "isNewsThreadChannel");
function isPublicThreadChannel(channel) {
  return channel?.type === "GUILD_PUBLIC_THREAD";
}
__name(isPublicThreadChannel, "isPublicThreadChannel");
function isPrivateThreadChannel(channel) {
  return channel?.type === "GUILD_PRIVATE_THREAD";
}
__name(isPrivateThreadChannel, "isPrivateThreadChannel");
function isTextBasedChannel(channel) {
  if ((0, import_utilities.isNullish)(channel))
    return false;
  return !(0, import_utilities.isNullish)(channel.send);
}
__name(isTextBasedChannel, "isTextBasedChannel");
function isVoiceBasedChannel(channel) {
  if ((0, import_utilities.isNullish)(channel))
    return false;
  return channel.isVoice();
}
__name(isVoiceBasedChannel, "isVoiceBasedChannel");
function isNsfwChannel(channel) {
  if ((0, import_utilities.isNullish)(channel))
    return false;
  switch (channel.type) {
    case "DM":
    case "GROUP_DM":
    case "GUILD_CATEGORY":
    case "GUILD_STAGE_VOICE":
    case "GUILD_STORE":
    case "GUILD_VOICE":
    case "GUILD_DIRECTORY":
    case "UNKNOWN":
      return false;
    case "GUILD_NEWS":
    case "GUILD_TEXT":
      return channel.nsfw;
    case "GUILD_NEWS_THREAD":
    case "GUILD_PRIVATE_THREAD":
    case "GUILD_PUBLIC_THREAD":
      return Boolean(channel.parent?.nsfw);
  }
}
__name(isNsfwChannel, "isNsfwChannel");
function isMessageInstance(message) {
  return message instanceof import_discord.Message;
}
__name(isMessageInstance, "isMessageInstance");
function isGuildMember(member) {
  return member instanceof import_discord.GuildMember;
}
__name(isGuildMember, "isGuildMember");

// src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts
var _MessagePrompterBaseStrategy = class {
  constructor(type, message, options) {
    __publicField(this, "type");
    __publicField(this, "timeout");
    __publicField(this, "explicitReturn");
    __publicField(this, "appliedMessage", null);
    __publicField(this, "message");
    __publicField(this, "editMessage");
    this.type = type;
    this.timeout = options?.timeout ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1e3;
    this.explicitReturn = options?.explicitReturn ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;
    this.editMessage = options?.editMessage ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? void 0;
    this.message = message;
  }
  async collectReactions(channel, authorOrFilter, reactions) {
    if (isTextBasedChannel(channel)) {
      if (!(0, import_utilities2.isNullish)(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = this.appliedMessage.createReactionCollector({
        ...this.createReactionPromptFilter(reactions, authorOrFilter),
        max: 1,
        time: this.timeout
      });
      let resolved = false;
      const collected = new Promise((resolve, reject) => {
        collector.on("collect", (r) => {
          resolve(r);
          resolved = true;
          collector.stop();
        });
        collector.on("end", (collected2) => {
          resolved = true;
          if (!collected2.size)
            reject(new Error("Collector has ended"));
        });
      });
      for (const reaction2 of reactions) {
        if (resolved)
          break;
        await this.appliedMessage.react(reaction2);
      }
      const firstReaction = await collected;
      const emoji = firstReaction?.emoji;
      const reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);
      return {
        emoji,
        reaction,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      };
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  createReactionPromptFilter(reactions, authorOrFilter) {
    return {
      filter: async (reaction, user) => reactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? "") && (typeof authorOrFilter === "function" ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) && !user.bot
    };
  }
};
var MessagePrompterBaseStrategy = _MessagePrompterBaseStrategy;
__name(MessagePrompterBaseStrategy, "MessagePrompterBaseStrategy");
__publicField(MessagePrompterBaseStrategy, "defaultStrategyOptions", {
  timeout: 10 * 1e3,
  explicitReturn: false,
  editMessage: void 0
});

// src/lib/MessagePrompter/strategies/MessagePrompterConfirmStrategy.ts
var _MessagePrompterConfirmStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("confirm", message, options);
    __publicField(this, "confirmEmoji");
    __publicField(this, "cancelEmoji");
    this.confirmEmoji = options?.confirmEmoji ?? _MessagePrompterConfirmStrategy.confirmEmoji;
    this.cancelEmoji = options?.cancelEmoji ?? _MessagePrompterConfirmStrategy.cancelEmoji;
  }
  async run(channel, authorOrFilter) {
    const response = await this.collectReactions(channel, authorOrFilter, [this.confirmEmoji, this.cancelEmoji]);
    const confirmed = (response?.emoji?.id ?? response?.emoji?.name) === this.confirmEmoji;
    return this.explicitReturn ? { ...response, confirmed } : confirmed;
  }
};
var MessagePrompterConfirmStrategy = _MessagePrompterConfirmStrategy;
__name(MessagePrompterConfirmStrategy, "MessagePrompterConfirmStrategy");
__publicField(MessagePrompterConfirmStrategy, "confirmEmoji", "\u{1F1FE}");
__publicField(MessagePrompterConfirmStrategy, "cancelEmoji", "\u{1F1F3}");

// src/lib/MessagePrompter/strategies/MessagePrompterMessageStrategy.ts
var import_utilities3 = require("@sapphire/utilities");
var MessagePrompterMessageStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("message", message, options);
  }
  async run(channel, authorOrFilter) {
    if (isTextBasedChannel(channel)) {
      if (!(0, import_utilities3.isNullish)(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = await channel.awaitMessages({
        ...this.createMessagePromptFilter(authorOrFilter),
        max: 1,
        time: this.timeout,
        errors: ["time"]
      });
      const response = collector.first();
      if (!response) {
        throw new Error("No messages received");
      }
      return this.explicitReturn ? {
        response,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      } : response;
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  createMessagePromptFilter(authorOrFilter) {
    return {
      filter: async (message) => (typeof authorOrFilter === "function" ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) && !message.author.bot
    };
  }
};
__name(MessagePrompterMessageStrategy, "MessagePrompterMessageStrategy");

// src/lib/MessagePrompter/strategies/MessagePrompterNumberStrategy.ts
var _MessagePrompterNumberStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("number", message, options);
    __publicField(this, "numberEmojis");
    __publicField(this, "start");
    __publicField(this, "end");
    this.numberEmojis = options?.numberEmojis ?? _MessagePrompterNumberStrategy.numberEmojis;
    this.start = options?.start ?? 0;
    this.end = options?.end ?? 10;
  }
  async run(channel, authorOrFilter) {
    if (this.start < 0)
      throw new TypeError("Starting number cannot be less than 0.");
    if (this.end > 10)
      throw new TypeError("Ending number cannot be more than 10.");
    const numbers = Array.from({ length: this.end - this.start + 1 }, (_, n) => n + this.start);
    const emojis = this.numberEmojis.slice(this.start, this.end);
    const response = await this.collectReactions(channel, authorOrFilter, emojis);
    const emojiIndex = emojis.findIndex((emoji) => (response?.emoji?.id ?? response?.emoji?.name) === emoji);
    const number = numbers[emojiIndex];
    return this.explicitReturn ? { ...response, number } : number;
  }
};
var MessagePrompterNumberStrategy = _MessagePrompterNumberStrategy;
__name(MessagePrompterNumberStrategy, "MessagePrompterNumberStrategy");
__publicField(MessagePrompterNumberStrategy, "numberEmojis", ["0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\u{1F51F}"]);

// src/lib/MessagePrompter/strategies/MessagePrompterReactionStrategy.ts
var MessagePrompterReactionStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("reactions", message, options);
    __publicField(this, "reactions");
    this.reactions = options?.reactions;
  }
  async run(channel, authorOrFilter) {
    if (!this.reactions?.length)
      throw new TypeError("There are no reactions provided.");
    const response = await this.collectReactions(channel, authorOrFilter, this.reactions);
    return this.explicitReturn ? response : response.reaction ?? response;
  }
};
__name(MessagePrompterReactionStrategy, "MessagePrompterReactionStrategy");

// src/lib/MessagePrompter/MessagePrompter.ts
var _MessagePrompter = class {
  constructor(message, strategy, strategyOptions) {
    __publicField(this, "strategy");
    let strategyToRun;
    if (message instanceof MessagePrompterBaseStrategy) {
      strategyToRun = message;
    } else {
      const mapStrategy = _MessagePrompter.strategies.get(strategy ?? _MessagePrompter.defaultStrategy);
      if (!mapStrategy) {
        throw new Error("No strategy provided");
      }
      strategyToRun = new mapStrategy(message, strategyOptions);
    }
    this.strategy = strategyToRun;
  }
  run(channel, authorOrFilter) {
    return this.strategy.run(channel, authorOrFilter);
  }
};
var MessagePrompter = _MessagePrompter;
__name(MessagePrompter, "MessagePrompter");
__publicField(MessagePrompter, "strategies", /* @__PURE__ */ new Map([
  ["confirm", MessagePrompterConfirmStrategy],
  ["number", MessagePrompterNumberStrategy],
  ["reaction", MessagePrompterReactionStrategy],
  ["message", MessagePrompterMessageStrategy]
]));
__publicField(MessagePrompter, "defaultStrategy", "confirm");

// src/lib/PaginatedMessages/LazyPaginatedMessage.ts
var import_utilities6 = require("@sapphire/utilities");
var import_discord4 = require("discord.js");

// src/lib/PaginatedMessages/PaginatedMessage.ts
var import_time_utilities = require("@sapphire/time-utilities");
var import_utilities5 = require("@sapphire/utilities");
var import_discord3 = require("discord.js");
var import_node_util = require("util");

// src/lib/PaginatedMessages/utils.ts
var import_utilities4 = require("@sapphire/utilities");
var import_discord2 = require("discord.js");
function runsOnInteraction(messageOrInteraction) {
  return !(messageOrInteraction instanceof import_discord2.Message);
}
__name(runsOnInteraction, "runsOnInteraction");
function actionIsButtonOrMenu(action) {
  return action.type === import_discord2.Constants.MessageComponentTypes.SELECT_MENU || action.type === "SELECT_MENU" || action.style !== "LINK" && action.style !== import_discord2.Constants.MessageButtonStyles.LINK;
}
__name(actionIsButtonOrMenu, "actionIsButtonOrMenu");
function isMessageButtonInteraction(interaction) {
  return interaction.type === import_discord2.Constants.MessageComponentTypes.BUTTON || interaction.type === "BUTTON";
}
__name(isMessageButtonInteraction, "isMessageButtonInteraction");
function isMessageButtonComponent(component) {
  return component.type === "BUTTON";
}
__name(isMessageButtonComponent, "isMessageButtonComponent");
function createPartitionedMessageRow(components) {
  const [messageButtons, selectMenus] = (0, import_utilities4.partition)(components, isMessageButtonComponent);
  const chunkedButtonComponents = (0, import_utilities4.chunk)(messageButtons, 5);
  const messageButtonActionRows = chunkedButtonComponents.map((componentsChunk) => new import_discord2.MessageActionRow().setComponents(componentsChunk));
  const selectMenuActionRows = selectMenus.map((component) => new import_discord2.MessageActionRow().setComponents(component));
  return [...messageButtonActionRows, ...selectMenuActionRows];
}
__name(createPartitionedMessageRow, "createPartitionedMessageRow");
async function safelyReplyToInteraction(parameters) {
  if (runsOnInteraction(parameters.messageOrInteraction)) {
    if (parameters.messageOrInteraction.replied || parameters.messageOrInteraction.deferred) {
      await parameters.messageOrInteraction.editReply(parameters.interactionEditReplyContent);
    } else if (parameters.messageOrInteraction.isMessageComponent()) {
      await parameters.messageOrInteraction.update(parameters.componentUpdateContent);
    } else {
      await parameters.messageOrInteraction.reply(parameters.interactionReplyContent);
    }
  } else if (parameters.messageMethodContent && parameters.messageMethod && isMessageInstance(parameters.messageOrInteraction)) {
    await parameters.messageOrInteraction[parameters.messageMethod](parameters.messageMethodContent);
  }
}
__name(safelyReplyToInteraction, "safelyReplyToInteraction");

// src/lib/PaginatedMessages/PaginatedMessage.ts
var _thisMazeWasNotMeantForYouContent;
var _PaginatedMessage = class {
  constructor({
    pages,
    actions,
    template,
    pageIndexPrefix,
    embedFooterSeparator,
    paginatedMessageData = null
  } = {}) {
    __privateAdd(this, _thisMazeWasNotMeantForYouContent, { content: "This maze wasn't meant for you...what did you do." });
    __publicField(this, "pages");
    __publicField(this, "response", null);
    __publicField(this, "collector", null);
    __publicField(this, "messages", []);
    __publicField(this, "actions", /* @__PURE__ */ new Map());
    __publicField(this, "index", 0);
    __publicField(this, "idle", import_time_utilities.Time.Minute * 14.5);
    __publicField(this, "template");
    __publicField(this, "pageIndexPrefix", _PaginatedMessage.pageIndexPrefix);
    __publicField(this, "embedFooterSeparator", _PaginatedMessage.embedFooterSeparator);
    __publicField(this, "stopPaginatedMessageCustomIds", _PaginatedMessage.stopPaginatedMessageCustomIds);
    __publicField(this, "emitPartialDMChannelWarning", _PaginatedMessage.emitPartialDMChannelWarning);
    __publicField(this, "paginatedMessageData", null);
    __publicField(this, "selectMenuOptions", _PaginatedMessage.selectMenuOptions);
    __publicField(this, "selectMenuPlaceholder");
    __publicField(this, "wrongUserInteractionReply", _PaginatedMessage.wrongUserInteractionReply);
    __publicField(this, "hasEmittedMaxPageWarning", false);
    __publicField(this, "hasEmittedPartialDMChannelWarning", false);
    this.pages = pages ?? [];
    for (const page of this.pages) {
      if ((0, import_utilities5.isFunction)(page) || (0, import_utilities5.isObject)(page)) {
        this.messages.push(page);
      }
    }
    for (const action of actions ?? this.constructor.defaultActions) {
      if (actionIsButtonOrMenu(action)) {
        this.actions.set(action.customId, action);
      } else {
        this.actions.set(action.url, action);
      }
    }
    this.template = _PaginatedMessage.resolveTemplate(template);
    this.pageIndexPrefix = pageIndexPrefix ?? _PaginatedMessage.pageIndexPrefix;
    this.embedFooterSeparator = embedFooterSeparator ?? _PaginatedMessage.embedFooterSeparator;
    this.paginatedMessageData = paginatedMessageData;
  }
  setSelectMenuOptions(newOptions) {
    this.selectMenuOptions = newOptions;
    return this;
  }
  setSelectMenuPlaceholder(placeholder) {
    this.selectMenuPlaceholder = placeholder;
    return this;
  }
  setWrongUserInteractionReply(wrongUserInteractionReply) {
    this.wrongUserInteractionReply = wrongUserInteractionReply;
    return this;
  }
  setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds) {
    this.stopPaginatedMessageCustomIds = stopPaginatedMessageCustomIds;
    return this;
  }
  setEmitPartialDMChannelWarning(emitPartialDMChannelWarning) {
    this.emitPartialDMChannelWarning = emitPartialDMChannelWarning;
    return this;
  }
  setIndex(index) {
    this.index = index;
    return this;
  }
  setIdle(idle) {
    this.idle = idle;
    return this;
  }
  setActions(actions, includeDefaultActions = false) {
    this.actions.clear();
    return this.addActions([...includeDefaultActions ? _PaginatedMessage.defaultActions : [], ...actions]);
  }
  addActions(actions) {
    for (const action of actions)
      this.addAction(action);
    return this;
  }
  addAction(action) {
    if (actionIsButtonOrMenu(action)) {
      this.actions.set(action.customId, action);
    } else {
      this.actions.set(action.url, action);
    }
    return this;
  }
  hasPage(index) {
    return index >= 0 && index < this.pages.length;
  }
  setPages(pages) {
    this.pages = [];
    this.messages = [];
    this.addPages(pages);
    return this;
  }
  addPage(page) {
    if (this.pages.length === 25) {
      if (!this.hasEmittedMaxPageWarning) {
        process.emitWarning("Maximum amount of pages exceeded for PaginatedMessage. Please check your instance of PaginatedMessage and ensure that you do not exceed 25 pages total.", {
          type: "PaginatedMessageExceededMessagePageAmount",
          code: "PAGINATED_MESSAGE_EXCEEDED_MAXIMUM_AMOUNT_OF_PAGES",
          detail: `If you do need more than 25 pages you can extend the class and overwrite the actions in the constructor.`
        });
        this.hasEmittedMaxPageWarning = true;
      }
      return this;
    }
    this.pages.push(page);
    return this;
  }
  addPageBuilder(builder) {
    return this.addPage((0, import_utilities5.isFunction)(builder) ? builder(new MessageBuilder()) : builder);
  }
  addAsyncPageBuilder(builder) {
    return this.addPage(async () => (0, import_utilities5.isFunction)(builder) ? builder(new MessageBuilder()) : builder);
  }
  addPageContent(content) {
    return this.addPage({ content });
  }
  addPageEmbed(embed) {
    return this.addPage({ embeds: (0, import_utilities5.isFunction)(embed) ? [embed(new import_discord3.MessageEmbed())] : [embed] });
  }
  addAsyncPageEmbed(embed) {
    return this.addPage(async () => ({ embeds: (0, import_utilities5.isFunction)(embed) ? [await embed(new import_discord3.MessageEmbed())] : [embed] }));
  }
  addPageEmbeds(embeds) {
    let processedEmbeds = (0, import_utilities5.isFunction)(embeds) ? embeds(new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed()) : embeds;
    if (processedEmbeds.length > 10) {
      processedEmbeds = processedEmbeds.slice(0, 10);
    }
    return this.addPage({ embeds: processedEmbeds });
  }
  addAsyncPageEmbeds(embeds) {
    return this.addPage(async () => {
      let processedEmbeds = (0, import_utilities5.isFunction)(embeds) ? await embeds(new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed(), new import_discord3.MessageEmbed()) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
  addPages(pages) {
    for (const page of pages)
      this.addPage(page);
    return this;
  }
  async run(messageOrInteraction, target) {
    if (!messageOrInteraction.channel) {
      const isInteraction = runsOnInteraction(messageOrInteraction);
      let shouldEmitWarning = this.emitPartialDMChannelWarning;
      if (shouldEmitWarning && this.hasEmittedPartialDMChannelWarning) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && isInteraction && messageOrInteraction.client.options.partials?.includes("CHANNEL")) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && !isInteraction && messageOrInteraction.client.options.partials?.includes("CHANNEL") && new import_discord3.Intents(messageOrInteraction.client.options.intents).has(import_discord3.Intents.FLAGS.DIRECT_MESSAGES)) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning) {
        process.emitWarning([
          "PaginatedMessage was initiated in a DM channel without the client having the required partial configured.",
          'If you want PaginatedMessage to work in DM channels then make sure you start your client with "CHANNEL" added to "client.options.partials".',
          'Furthermore if you are using message based commands (as opposed to application commands) then you will also need to add the "DIRECT_MESSAGE" intent to "client.options.intents"',
          'If you do not want to be alerted about this in the future then you can disable this warning by setting "PaginatedMessage.emitPartialDMChannelWarning" to "false", or use "setEmitPartialDMChannelWarning(false)" before calling "run".'
        ].join("\n"), {
          type: "PaginatedMessageRunsInNonpartialDMChannel",
          code: "PAGINATED_MESSAGE_RUNS_IN_NON_PARTIAL_DM_CHANNEL"
        });
        this.hasEmittedPartialDMChannelWarning = true;
      }
      await safelyReplyToInteraction({
        messageOrInteraction,
        interactionEditReplyContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        messageMethod: "reply",
        messageMethodContent: __privateGet(this, _thisMazeWasNotMeantForYouContent)
      });
      return this;
    }
    target ??= runsOnInteraction(messageOrInteraction) ? messageOrInteraction.user : messageOrInteraction.author;
    const paginatedMessage = _PaginatedMessage.handlers.get(target.id);
    paginatedMessage?.collector?.stop();
    if (runsOnInteraction(messageOrInteraction)) {
      if (messageOrInteraction.user.bot && messageOrInteraction.user.id === messageOrInteraction.client.user?.id) {
        this.response = messageOrInteraction;
      }
    } else if (messageOrInteraction.author.bot && messageOrInteraction.author.id === messageOrInteraction.client.user?.id) {
      this.response = messageOrInteraction;
    }
    await this.resolvePagesOnRun();
    if (!this.messages.length)
      throw new Error("There are no messages.");
    if (!this.actions.size)
      throw new Error("There are no actions.");
    await this.setUpMessage(messageOrInteraction, target);
    this.setUpCollector(messageOrInteraction.channel, target);
    const messageId = this.response.id;
    if (this.collector) {
      this.collector.once("end", () => {
        _PaginatedMessage.messages.delete(messageId);
        _PaginatedMessage.handlers.delete(target.id);
      });
      _PaginatedMessage.messages.set(messageId, this);
      _PaginatedMessage.handlers.set(target.id, this);
    }
    return this;
  }
  async resolvePagesOnRun() {
    for (let i = 0; i < this.pages.length; i++) {
      await this.resolvePage(i);
    }
  }
  async resolvePage(index) {
    const message = this.messages[index];
    if (!(0, import_utilities5.isNullish)(message)) {
      return message;
    }
    const resolved = await this.handlePageLoad(this.pages[index], index);
    this.messages[index] = resolved;
    return resolved;
  }
  clone() {
    const clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);
    clone.actions = this.actions;
    clone.response = this.response;
    clone.template = this.template;
    return clone;
  }
  async setUpMessage(messageOrInteraction, targetUser) {
    let page = this.messages[this.index];
    page = (0, import_utilities5.isFunction)(page) ? await page(this.index, this.pages, this) : page;
    page = { ...page, ...this.paginatedMessageData ?? {} };
    if (this.pages.length > 1) {
      const messageComponents = await Promise.all([...this.actions.values()].map(async (interaction) => {
        return isMessageButtonInteraction(interaction) ? new import_discord3.MessageButton(interaction) : new import_discord3.MessageSelectMenu({
          options: await Promise.all(this.pages.map(async (_, index) => {
            return {
              ...await this.selectMenuOptions(index + 1, this.resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser)),
              value: index.toString()
            };
          })),
          placeholder: this.selectMenuPlaceholder,
          ...interaction
        });
      }));
      page.components = createPartitionedMessageRow(messageComponents);
    }
    if (this.response) {
      if (runsOnInteraction(this.response)) {
        if (this.response.replied || this.response.deferred) {
          await this.response.editReply(page);
        } else {
          await this.response.reply(page);
        }
      } else if (isMessageInstance(this.response)) {
        await this.response.edit(page);
      }
    } else if (runsOnInteraction(messageOrInteraction)) {
      if (messageOrInteraction.replied || messageOrInteraction.deferred) {
        this.response = await messageOrInteraction.editReply(page);
      } else {
        this.response = await messageOrInteraction.reply({ ...page, fetchReply: true, ephemeral: false });
      }
    } else {
      this.response = await messageOrInteraction.channel.send(page);
    }
  }
  setUpCollector(channel, targetUser) {
    if (this.pages.length > 1) {
      this.collector = new import_discord3.InteractionCollector(targetUser.client, {
        filter: (interaction) => !(0, import_utilities5.isNullish)(this.response) && interaction.isMessageComponent() && this.actions.has(interaction.customId),
        time: this.idle,
        guild: isGuildBasedChannel(channel) ? channel.guild : void 0,
        channel,
        interactionType: import_discord3.Constants.InteractionTypes.MESSAGE_COMPONENT,
        ...!(0, import_utilities5.isNullish)(this.response) && !runsOnInteraction(this.response) ? {
          message: this.response
        } : {}
      }).on("collect", this.handleCollect.bind(this, targetUser, channel)).on("end", this.handleEnd.bind(this));
    }
  }
  async handlePageLoad(page, index) {
    const options = (0, import_utilities5.isFunction)(page) ? await page(index, this.pages, this) : page;
    const clonedTemplate = (0, import_utilities5.deepClone)(this.template);
    const optionsWithTemplate = this.applyTemplate(clonedTemplate, options);
    return this.applyFooter(optionsWithTemplate, index);
  }
  async handleCollect(targetUser, channel, interaction) {
    if (interaction.user.id === targetUser.id) {
      this.response = interaction;
      const action = this.actions.get(interaction.customId);
      if (actionIsButtonOrMenu(action)) {
        const previousIndex = this.index;
        await action.run({
          interaction,
          handler: this,
          author: targetUser,
          channel,
          response: this.response,
          collector: this.collector
        });
        if (!this.stopPaginatedMessageCustomIds.includes(action.customId)) {
          const newIndex = previousIndex === this.index ? previousIndex : this.index;
          const messagePage = await this.resolvePage(newIndex);
          const updateOptions = (0, import_utilities5.isFunction)(messagePage) ? await messagePage(newIndex, this.pages, this) : messagePage;
          await safelyReplyToInteraction({
            messageOrInteraction: interaction,
            interactionEditReplyContent: updateOptions,
            interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
            componentUpdateContent: updateOptions
          });
        }
      }
    } else {
      const interactionReplyOptions = await this.wrongUserInteractionReply(targetUser, interaction.user, this.resolvePaginatedMessageInternationalizationContext(interaction, targetUser));
      await interaction.reply((0, import_utilities5.isObject)(interactionReplyOptions) ? interactionReplyOptions : { content: interactionReplyOptions, ephemeral: true, allowedMentions: { users: [], roles: [] } });
    }
  }
  handleEnd(_, reason) {
    this.collector?.removeAllListeners();
    if (this.response && !_PaginatedMessage.deletionStopReasons.includes(reason)) {
      void safelyReplyToInteraction({
        messageOrInteraction: this.response,
        interactionEditReplyContent: { components: [] },
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: { components: [] },
        messageMethod: "edit",
        messageMethodContent: { components: [] }
      });
    }
  }
  applyFooter(message, index) {
    if (!message.embeds?.length) {
      return message;
    }
    const embedsWithFooterApplied = (0, import_utilities5.deepClone)(message.embeds);
    const idx = embedsWithFooterApplied.length - 1;
    const lastEmbed = embedsWithFooterApplied[idx];
    if (lastEmbed) {
      lastEmbed.footer ??= { text: this.template.embeds?.[idx]?.footer?.text ?? this.template.embeds?.[0]?.footer?.text ?? "" };
      lastEmbed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ""}${index + 1} / ${this.pages.length}${lastEmbed.footer.text ? ` ${this.embedFooterSeparator} ${lastEmbed.footer.text}` : ""}`;
    }
    return { ...message, embeds: embedsWithFooterApplied };
  }
  resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser) {
    const context = {
      user: targetUser,
      channel: messageOrInteraction.channel,
      guild: isGuildBasedChannel(messageOrInteraction.channel) ? messageOrInteraction.channel.guild : null,
      interactionGuildLocale: runsOnInteraction(messageOrInteraction) ? messageOrInteraction.guildLocale : void 0,
      interactionLocale: runsOnInteraction(messageOrInteraction) ? messageOrInteraction.locale : void 0
    };
    Object.defineProperty(context, "author", {
      get: (0, import_node_util.deprecate)(() => {
        return context.user;
      }, "PaginatedMessageInternationalizationContext's `author` property is deprecated and will be removed in the next major version. Please use `PaginatedMessageInternationalizationContext.user` instead.", "DeprecationWarning"),
      set: (0, import_node_util.deprecate)((val) => {
        context.user = val;
      }, "PaginatedMessageInternationalizationContext's `author` property is deprecated and will be removed in the next major version. Please use `PaginatedMessageInternationalizationContext.user` instead.", "DeprecationWarning")
    });
    return context;
  }
  applyTemplate(template, options) {
    const embedData = this.applyTemplateEmbed(template.embeds, options.embeds);
    return { ...template, ...options, embeds: embedData };
  }
  applyTemplateEmbed(templateEmbed, pageEmbeds) {
    if ((0, import_utilities5.isNullish)(pageEmbeds)) {
      return templateEmbed ? [templateEmbed?.[0]] : void 0;
    }
    if ((0, import_utilities5.isNullish)(templateEmbed)) {
      return pageEmbeds;
    }
    return this.mergeEmbeds(templateEmbed[0], pageEmbeds);
  }
  mergeEmbeds(templateEmbed, pageEmbeds) {
    const mergedEmbeds = [];
    for (const pageEmbed of pageEmbeds) {
      mergedEmbeds.push({
        title: pageEmbed.title ?? templateEmbed.title ?? void 0,
        description: pageEmbed.description ?? templateEmbed.description ?? void 0,
        url: pageEmbed.url ?? templateEmbed.url ?? void 0,
        timestamp: (typeof pageEmbed.timestamp === "string" ? new Date(pageEmbed.timestamp) : pageEmbed.timestamp) ?? (typeof templateEmbed.timestamp === "string" ? new Date(templateEmbed.timestamp) : templateEmbed.timestamp) ?? void 0,
        color: pageEmbed.color ?? templateEmbed.color ?? void 0,
        fields: this.mergeArrays(templateEmbed.fields, pageEmbed.fields),
        author: pageEmbed.author ?? templateEmbed.author ?? void 0,
        thumbnail: pageEmbed.thumbnail ?? templateEmbed.thumbnail ?? void 0,
        image: pageEmbed.image ?? templateEmbed.image ?? void 0,
        video: pageEmbed.video ?? templateEmbed.video ?? void 0,
        footer: pageEmbed.footer ?? templateEmbed.footer ?? void 0
      });
    }
    return mergedEmbeds;
  }
  mergeArrays(template, array) {
    if ((0, import_utilities5.isNullish)(array)) {
      return template;
    }
    if ((0, import_utilities5.isNullish)(template)) {
      return array;
    }
    return [...template, ...array];
  }
  static resolveTemplate(template) {
    if (template === void 0) {
      return {};
    }
    if (template instanceof import_discord3.MessageEmbed) {
      return { embeds: [template] };
    }
    return template;
  }
};
var PaginatedMessage = _PaginatedMessage;
__name(PaginatedMessage, "PaginatedMessage");
_thisMazeWasNotMeantForYouContent = new WeakMap();
__publicField(PaginatedMessage, "defaultActions", [
  {
    customId: "@sapphire/paginated-messages.goToPage",
    type: import_discord3.Constants.MessageComponentTypes.SELECT_MENU,
    run: ({ handler, interaction }) => interaction.isSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
  },
  {
    customId: "@sapphire/paginated-messages.firstPage",
    style: "PRIMARY",
    emoji: "\u23EA",
    type: import_discord3.Constants.MessageComponentTypes.BUTTON,
    run: ({ handler }) => handler.index = 0
  },
  {
    customId: "@sapphire/paginated-messages.previousPage",
    style: "PRIMARY",
    emoji: "\u25C0\uFE0F",
    type: import_discord3.Constants.MessageComponentTypes.BUTTON,
    run: ({ handler }) => {
      if (handler.index === 0) {
        handler.index = handler.pages.length - 1;
      } else {
        --handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.nextPage",
    style: "PRIMARY",
    emoji: "\u25B6\uFE0F",
    type: import_discord3.Constants.MessageComponentTypes.BUTTON,
    run: ({ handler }) => {
      if (handler.index === handler.pages.length - 1) {
        handler.index = 0;
      } else {
        ++handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.goToLastPage",
    style: "PRIMARY",
    emoji: "\u23E9",
    type: import_discord3.Constants.MessageComponentTypes.BUTTON,
    run: ({ handler }) => handler.index = handler.pages.length - 1
  },
  {
    customId: "@sapphire/paginated-messages.stop",
    style: "DANGER",
    emoji: "\u23F9\uFE0F",
    type: import_discord3.Constants.MessageComponentTypes.BUTTON,
    run: ({ collector }) => {
      collector.stop();
    }
  }
]);
__publicField(PaginatedMessage, "emitPartialDMChannelWarning", true);
__publicField(PaginatedMessage, "stopPaginatedMessageCustomIds", ["@sapphire/paginated-messages.stop"]);
__publicField(PaginatedMessage, "deletionStopReasons", ["messageDelete", "channelDelete", "guildDelete"]);
__publicField(PaginatedMessage, "pageIndexPrefix", "");
__publicField(PaginatedMessage, "embedFooterSeparator", "\u2022");
__publicField(PaginatedMessage, "messages", /* @__PURE__ */ new Map());
__publicField(PaginatedMessage, "handlers", /* @__PURE__ */ new Map());
__publicField(PaginatedMessage, "selectMenuOptions", /* @__PURE__ */ __name((pageIndex) => ({ label: `Page ${pageIndex}` }), "selectMenuOptions"));
__publicField(PaginatedMessage, "wrongUserInteractionReply", /* @__PURE__ */ __name((targetUser) => ({
  content: `Please stop interacting with the components on this message. They are only for ${import_discord3.Formatters.userMention(targetUser.id)}.`,
  ephemeral: true,
  allowedMentions: { users: [], roles: [] }
}), "wrongUserInteractionReply"));

// src/lib/PaginatedMessages/LazyPaginatedMessage.ts
var LazyPaginatedMessage = class extends PaginatedMessage {
  async resolvePagesOnRun() {
    await this.resolvePage(this.index);
  }
  async resolvePage(index) {
    const promises = [super.resolvePage(index)];
    if (this.hasPage(index - 1))
      promises.push(super.resolvePage(index - 1));
    if (this.hasPage(index + 1))
      promises.push(super.resolvePage(index + 1));
    const [result] = await Promise.all(promises);
    return result;
  }
  addPageBuilder(builder) {
    return this.addPage(() => (0, import_utilities6.isFunction)(builder) ? builder(new MessageBuilder()) : builder);
  }
  addPageContent(content) {
    return this.addPage(() => ({ content }));
  }
  addPageEmbed(embed) {
    return this.addPage(() => ({ embeds: typeof embed === "function" ? [embed(new import_discord4.MessageEmbed())] : [embed] }));
  }
  addPageEmbeds(embeds) {
    return this.addPage(() => {
      let processedEmbeds = (0, import_utilities6.isFunction)(embeds) ? embeds(new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed(), new import_discord4.MessageEmbed()) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
};
__name(LazyPaginatedMessage, "LazyPaginatedMessage");

// src/lib/PaginatedMessages/PaginatedFieldMessageEmbed.ts
var import_utilities7 = require("@sapphire/utilities");
var import_discord5 = require("discord.js");
var PaginatedFieldMessageEmbed = class extends PaginatedMessage {
  constructor() {
    super(...arguments);
    __publicField(this, "embedTemplate", new import_discord5.MessageEmbed());
    __publicField(this, "totalPages", 0);
    __publicField(this, "items", []);
    __publicField(this, "itemsPerPage", 10);
    __publicField(this, "fieldTitle", "");
  }
  setItems(items) {
    this.items = items;
    return this;
  }
  setTitleField(title) {
    this.fieldTitle = title;
    return this;
  }
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  formatItems(formatter) {
    this.items = this.items.map(formatter);
    return this;
  }
  make() {
    if (!this.fieldTitle.length)
      throw new Error("The title of the field to format must have a value.");
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.items.some((x) => !x))
      throw new Error("The format of the array items is incorrect.");
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  generatePages() {
    const template = this.embedTemplate instanceof import_discord5.MessageEmbed ? this.embedTemplate.toJSON() : this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new import_discord5.MessageEmbed(template);
      const fieldsClone = this.embedTemplate.fields;
      clonedTemplate.fields = [];
      if (!clonedTemplate.color)
        clonedTemplate.setColor("RANDOM");
      const data = this.paginateArray(this.items, i, this.itemsPerPage);
      this.addPage({
        embeds: [clonedTemplate.addField(this.fieldTitle, data.join("\n"), false).addFields(fieldsClone)]
      });
    }
  }
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  resolveTemplate(template) {
    if (template instanceof import_discord5.MessageEmbed) {
      return template;
    }
    if ((0, import_utilities7.isFunction)(template)) {
      return template(new import_discord5.MessageEmbed());
    }
    return new import_discord5.MessageEmbed(template);
  }
};
__name(PaginatedFieldMessageEmbed, "PaginatedFieldMessageEmbed");

// src/lib/PaginatedMessages/PaginatedMessageEmbedFields.ts
var import_discord_utilities = require("@sapphire/discord-utilities");
var import_utilities8 = require("@sapphire/utilities");
var import_discord6 = require("discord.js");
var PaginatedMessageEmbedFields = class extends PaginatedMessage {
  constructor() {
    super(...arguments);
    __publicField(this, "embedTemplate", new import_discord6.MessageEmbed());
    __publicField(this, "totalPages", 0);
    __publicField(this, "items", []);
    __publicField(this, "itemsPerPage", 10);
  }
  setItems(items) {
    this.items = items;
    return this;
  }
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  make() {
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.itemsPerPage > import_discord_utilities.EmbedLimits.MaximumFields)
      throw new Error(`Pages cannot contain more than ${import_discord_utilities.EmbedLimits.MaximumFields} fields.`);
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  generatePages() {
    const template = this.embedTemplate instanceof import_discord6.MessageEmbed ? this.embedTemplate.toJSON() : this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new import_discord6.MessageEmbed(template);
      const fieldsClone = this.embedTemplate.fields;
      clonedTemplate.fields = [];
      if (!clonedTemplate.color)
        clonedTemplate.setColor("RANDOM");
      const data = this.paginateArray(this.items, i, this.itemsPerPage - fieldsClone.length);
      this.addPage({
        embeds: [clonedTemplate.addFields(...data, ...fieldsClone)]
      });
    }
  }
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  resolveTemplate(template) {
    if (template instanceof import_discord6.MessageEmbed) {
      return template;
    }
    if ((0, import_utilities8.isFunction)(template)) {
      return template(new import_discord6.MessageEmbed());
    }
    return new import_discord6.MessageEmbed(template);
  }
};
__name(PaginatedMessageEmbedFields, "PaginatedMessageEmbedFields");

// src/lib/utilities.ts
var import_utilities9 = require("@sapphire/utilities");
var import_discord7 = require("discord.js");
var canReadMessagesPermissions = new import_discord7.Permissions(["VIEW_CHANNEL"]);
function canReadMessages(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  return canDoUtility(channel, canReadMessagesPermissions);
}
__name(canReadMessages, "canReadMessages");
var canSendMessagesPermissions = new import_discord7.Permissions([canReadMessagesPermissions, "SEND_MESSAGES"]);
function canSendMessages(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendMessagesPermissions);
}
__name(canSendMessages, "canSendMessages");
var canSendEmbedsPermissions = new import_discord7.Permissions([canSendMessagesPermissions, "EMBED_LINKS"]);
function canSendEmbeds(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendEmbedsPermissions);
}
__name(canSendEmbeds, "canSendEmbeds");
var canSendAttachmentsPermissions = new import_discord7.Permissions([canSendMessagesPermissions, "ATTACH_FILES"]);
function canSendAttachments(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendAttachmentsPermissions);
}
__name(canSendAttachments, "canSendAttachments");
var canReactPermissions = new import_discord7.Permissions([canSendMessagesPermissions, "READ_MESSAGE_HISTORY", "ADD_REACTIONS"]);
function canReact(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && channel.archived)
    return false;
  return canDoUtility(channel, canReactPermissions);
}
__name(canReact, "canReact");
var canRemoveAllReactionsPermissions = new import_discord7.Permissions([canReadMessagesPermissions, "READ_MESSAGE_HISTORY", "MANAGE_MESSAGES"]);
function canRemoveAllReactions(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (isDMChannel(channel))
    return false;
  return canDoUtility(channel, canRemoveAllReactionsPermissions);
}
__name(canRemoveAllReactions, "canRemoveAllReactions");
var canJoinVoiceChannelPermissions = new import_discord7.Permissions(["CONNECT"]);
function canJoinVoiceChannel(channel) {
  if ((0, import_utilities9.isNullish)(channel))
    return false;
  if (!isVoiceBasedChannel(channel))
    return false;
  if (channel.userLimit >= channel.members.size)
    return false;
  return canDoUtility(channel, canJoinVoiceChannelPermissions);
}
__name(canJoinVoiceChannel, "canJoinVoiceChannel");
function canDoUtility(channel, permissionsToPass) {
  return isGuildBasedChannel(channel) ? channel.permissionsFor(channel.guild.me).has(permissionsToPass) : true;
}
__name(canDoUtility, "canDoUtility");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LazyPaginatedMessage,
  MessageBuilder,
  MessagePrompter,
  MessagePrompterBaseStrategy,
  MessagePrompterConfirmStrategy,
  MessagePrompterMessageStrategy,
  MessagePrompterNumberStrategy,
  MessagePrompterReactionStrategy,
  PaginatedFieldMessageEmbed,
  PaginatedMessage,
  PaginatedMessageEmbedFields,
  actionIsButtonOrMenu,
  canJoinVoiceChannel,
  canReact,
  canReadMessages,
  canRemoveAllReactions,
  canSendAttachments,
  canSendEmbeds,
  canSendMessages,
  createPartitionedMessageRow,
  isCategoryChannel,
  isDMChannel,
  isGroupChannel,
  isGuildBasedChannel,
  isGuildBasedChannelByGuildKey,
  isGuildMember,
  isMessageButtonComponent,
  isMessageButtonInteraction,
  isMessageInstance,
  isNewsChannel,
  isNewsThreadChannel,
  isNsfwChannel,
  isPrivateThreadChannel,
  isPublicThreadChannel,
  isStageChannel,
  isStoreChannel,
  isTextBasedChannel,
  isTextChannel,
  isThreadChannel,
  isVoiceBasedChannel,
  isVoiceChannel,
  runsOnInteraction,
  safelyReplyToInteraction
});
//# sourceMappingURL=index.js.map