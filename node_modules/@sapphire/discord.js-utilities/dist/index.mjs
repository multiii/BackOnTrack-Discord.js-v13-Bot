var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// src/index.ts
export * from "@sapphire/discord-utilities";

// src/lib/builders/MessageBuilder.ts
var _MessageBuilder = class {
  constructor(options) {
    __publicField(this, "tts");
    __publicField(this, "nonce");
    __publicField(this, "content");
    __publicField(this, "embeds");
    __publicField(this, "allowedMentions");
    __publicField(this, "files");
    this.tts = options?.tts ?? _MessageBuilder.defaults.tts;
    this.nonce = options?.nonce ?? _MessageBuilder.defaults.nonce;
    this.content = options?.content ?? _MessageBuilder.defaults.content;
    this.embeds = options?.embeds ?? _MessageBuilder.defaults.embeds;
    this.allowedMentions = options?.allowedMentions ?? _MessageBuilder.defaults.allowedMentions;
    this.files = options?.files ?? _MessageBuilder.defaults.files;
  }
  setTTS(tts) {
    this.tts = tts;
    return this;
  }
  setNonce(nonce) {
    this.nonce = nonce;
    return this;
  }
  setContent(content) {
    this.content = content;
    return this;
  }
  setEmbeds(embeds) {
    if (embeds && embeds.length > 10) {
      embeds = embeds.slice(0, 10);
    }
    this.embeds = embeds;
    return this;
  }
  setAllowedMentions(allowedMentions) {
    this.allowedMentions = allowedMentions;
    return this;
  }
  addFile(file) {
    this.files = this.files?.concat(file) ?? [file];
    return this;
  }
  setFile(file) {
    this.files = [file];
    return this;
  }
  setFiles(files) {
    this.files = files;
    return this;
  }
};
var MessageBuilder = _MessageBuilder;
__name(MessageBuilder, "MessageBuilder");
__publicField(MessageBuilder, "defaults", {});

// src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts
import { isNullish as isNullish2 } from "@sapphire/utilities";

// src/lib/type-guards.ts
import { isNullish } from "@sapphire/utilities";
import {
  GuildMember,
  Message
} from "discord.js";
function isCategoryChannel(channel) {
  return channel?.type === "GUILD_CATEGORY";
}
__name(isCategoryChannel, "isCategoryChannel");
function isDMChannel(channel) {
  return channel?.type === "DM";
}
__name(isDMChannel, "isDMChannel");
function isGroupChannel(channel) {
  return channel?.type === "GROUP_DM";
}
__name(isGroupChannel, "isGroupChannel");
function isGuildBasedChannel(channel) {
  return channel?.type !== "DM";
}
__name(isGuildBasedChannel, "isGuildBasedChannel");
function isGuildBasedChannelByGuildKey(channel) {
  return Reflect.has(channel ?? {}, "guild");
}
__name(isGuildBasedChannelByGuildKey, "isGuildBasedChannelByGuildKey");
function isNewsChannel(channel) {
  return channel?.type === "GUILD_NEWS";
}
__name(isNewsChannel, "isNewsChannel");
function isStoreChannel(channel) {
  return channel?.type === "GUILD_STORE";
}
__name(isStoreChannel, "isStoreChannel");
function isTextChannel(channel) {
  return channel?.type === "GUILD_TEXT";
}
__name(isTextChannel, "isTextChannel");
function isVoiceChannel(channel) {
  return channel?.type === "GUILD_VOICE";
}
__name(isVoiceChannel, "isVoiceChannel");
function isStageChannel(channel) {
  return channel?.type === "GUILD_STAGE_VOICE";
}
__name(isStageChannel, "isStageChannel");
function isThreadChannel(channel) {
  return channel?.isThread() ?? false;
}
__name(isThreadChannel, "isThreadChannel");
function isNewsThreadChannel(channel) {
  return channel?.type === "GUILD_NEWS_THREAD";
}
__name(isNewsThreadChannel, "isNewsThreadChannel");
function isPublicThreadChannel(channel) {
  return channel?.type === "GUILD_PUBLIC_THREAD";
}
__name(isPublicThreadChannel, "isPublicThreadChannel");
function isPrivateThreadChannel(channel) {
  return channel?.type === "GUILD_PRIVATE_THREAD";
}
__name(isPrivateThreadChannel, "isPrivateThreadChannel");
function isTextBasedChannel(channel) {
  if (isNullish(channel))
    return false;
  return !isNullish(channel.send);
}
__name(isTextBasedChannel, "isTextBasedChannel");
function isVoiceBasedChannel(channel) {
  if (isNullish(channel))
    return false;
  return channel.isVoice();
}
__name(isVoiceBasedChannel, "isVoiceBasedChannel");
function isNsfwChannel(channel) {
  if (isNullish(channel))
    return false;
  switch (channel.type) {
    case "DM":
    case "GROUP_DM":
    case "GUILD_CATEGORY":
    case "GUILD_STAGE_VOICE":
    case "GUILD_STORE":
    case "GUILD_VOICE":
    case "GUILD_DIRECTORY":
    case "UNKNOWN":
      return false;
    case "GUILD_NEWS":
    case "GUILD_TEXT":
      return channel.nsfw;
    case "GUILD_NEWS_THREAD":
    case "GUILD_PRIVATE_THREAD":
    case "GUILD_PUBLIC_THREAD":
      return Boolean(channel.parent?.nsfw);
  }
}
__name(isNsfwChannel, "isNsfwChannel");
function isMessageInstance(message) {
  return message instanceof Message;
}
__name(isMessageInstance, "isMessageInstance");
function isGuildMember(member) {
  return member instanceof GuildMember;
}
__name(isGuildMember, "isGuildMember");

// src/lib/MessagePrompter/strategies/MessagePrompterBaseStrategy.ts
var _MessagePrompterBaseStrategy = class {
  constructor(type, message, options) {
    __publicField(this, "type");
    __publicField(this, "timeout");
    __publicField(this, "explicitReturn");
    __publicField(this, "appliedMessage", null);
    __publicField(this, "message");
    __publicField(this, "editMessage");
    this.type = type;
    this.timeout = options?.timeout ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.timeout ?? 10 * 1e3;
    this.explicitReturn = options?.explicitReturn ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.explicitReturn ?? false;
    this.editMessage = options?.editMessage ?? _MessagePrompterBaseStrategy.defaultStrategyOptions.editMessage ?? void 0;
    this.message = message;
  }
  async collectReactions(channel, authorOrFilter, reactions) {
    if (isTextBasedChannel(channel)) {
      if (!isNullish2(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = this.appliedMessage.createReactionCollector({
        ...this.createReactionPromptFilter(reactions, authorOrFilter),
        max: 1,
        time: this.timeout
      });
      let resolved = false;
      const collected = new Promise((resolve, reject) => {
        collector.on("collect", (r) => {
          resolve(r);
          resolved = true;
          collector.stop();
        });
        collector.on("end", (collected2) => {
          resolved = true;
          if (!collected2.size)
            reject(new Error("Collector has ended"));
        });
      });
      for (const reaction2 of reactions) {
        if (resolved)
          break;
        await this.appliedMessage.react(reaction2);
      }
      const firstReaction = await collected;
      const emoji = firstReaction?.emoji;
      const reaction = reactions.find((r) => (emoji?.id ?? emoji?.name) === r);
      return {
        emoji,
        reaction,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      };
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  createReactionPromptFilter(reactions, authorOrFilter) {
    return {
      filter: async (reaction, user) => reactions.includes(reaction.emoji.id ?? reaction.emoji.name ?? "") && (typeof authorOrFilter === "function" ? await authorOrFilter(reaction, user) : user.id === authorOrFilter.id) && !user.bot
    };
  }
};
var MessagePrompterBaseStrategy = _MessagePrompterBaseStrategy;
__name(MessagePrompterBaseStrategy, "MessagePrompterBaseStrategy");
__publicField(MessagePrompterBaseStrategy, "defaultStrategyOptions", {
  timeout: 10 * 1e3,
  explicitReturn: false,
  editMessage: void 0
});

// src/lib/MessagePrompter/strategies/MessagePrompterConfirmStrategy.ts
var _MessagePrompterConfirmStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("confirm", message, options);
    __publicField(this, "confirmEmoji");
    __publicField(this, "cancelEmoji");
    this.confirmEmoji = options?.confirmEmoji ?? _MessagePrompterConfirmStrategy.confirmEmoji;
    this.cancelEmoji = options?.cancelEmoji ?? _MessagePrompterConfirmStrategy.cancelEmoji;
  }
  async run(channel, authorOrFilter) {
    const response = await this.collectReactions(channel, authorOrFilter, [this.confirmEmoji, this.cancelEmoji]);
    const confirmed = (response?.emoji?.id ?? response?.emoji?.name) === this.confirmEmoji;
    return this.explicitReturn ? { ...response, confirmed } : confirmed;
  }
};
var MessagePrompterConfirmStrategy = _MessagePrompterConfirmStrategy;
__name(MessagePrompterConfirmStrategy, "MessagePrompterConfirmStrategy");
__publicField(MessagePrompterConfirmStrategy, "confirmEmoji", "\u{1F1FE}");
__publicField(MessagePrompterConfirmStrategy, "cancelEmoji", "\u{1F1F3}");

// src/lib/MessagePrompter/strategies/MessagePrompterMessageStrategy.ts
import { isNullish as isNullish3 } from "@sapphire/utilities";
var MessagePrompterMessageStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("message", message, options);
  }
  async run(channel, authorOrFilter) {
    if (isTextBasedChannel(channel)) {
      if (!isNullish3(this.editMessage) && this.editMessage.editable) {
        this.appliedMessage = await this.editMessage.edit(this.message);
      } else {
        this.appliedMessage = await channel.send(this.message);
      }
      const collector = await channel.awaitMessages({
        ...this.createMessagePromptFilter(authorOrFilter),
        max: 1,
        time: this.timeout,
        errors: ["time"]
      });
      const response = collector.first();
      if (!response) {
        throw new Error("No messages received");
      }
      return this.explicitReturn ? {
        response,
        strategy: this,
        appliedMessage: this.appliedMessage,
        message: this.message
      } : response;
    }
    throw new Error("A channel was provided to which I am not able to send messages");
  }
  createMessagePromptFilter(authorOrFilter) {
    return {
      filter: async (message) => (typeof authorOrFilter === "function" ? await authorOrFilter(message) : message.author.id === authorOrFilter.id) && !message.author.bot
    };
  }
};
__name(MessagePrompterMessageStrategy, "MessagePrompterMessageStrategy");

// src/lib/MessagePrompter/strategies/MessagePrompterNumberStrategy.ts
var _MessagePrompterNumberStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("number", message, options);
    __publicField(this, "numberEmojis");
    __publicField(this, "start");
    __publicField(this, "end");
    this.numberEmojis = options?.numberEmojis ?? _MessagePrompterNumberStrategy.numberEmojis;
    this.start = options?.start ?? 0;
    this.end = options?.end ?? 10;
  }
  async run(channel, authorOrFilter) {
    if (this.start < 0)
      throw new TypeError("Starting number cannot be less than 0.");
    if (this.end > 10)
      throw new TypeError("Ending number cannot be more than 10.");
    const numbers = Array.from({ length: this.end - this.start + 1 }, (_, n) => n + this.start);
    const emojis = this.numberEmojis.slice(this.start, this.end);
    const response = await this.collectReactions(channel, authorOrFilter, emojis);
    const emojiIndex = emojis.findIndex((emoji) => (response?.emoji?.id ?? response?.emoji?.name) === emoji);
    const number = numbers[emojiIndex];
    return this.explicitReturn ? { ...response, number } : number;
  }
};
var MessagePrompterNumberStrategy = _MessagePrompterNumberStrategy;
__name(MessagePrompterNumberStrategy, "MessagePrompterNumberStrategy");
__publicField(MessagePrompterNumberStrategy, "numberEmojis", ["0\uFE0F\u20E3", "1\uFE0F\u20E3", "2\uFE0F\u20E3", "3\uFE0F\u20E3", "4\uFE0F\u20E3", "5\uFE0F\u20E3", "6\uFE0F\u20E3", "7\uFE0F\u20E3", "8\uFE0F\u20E3", "9\uFE0F\u20E3", "\u{1F51F}"]);

// src/lib/MessagePrompter/strategies/MessagePrompterReactionStrategy.ts
var MessagePrompterReactionStrategy = class extends MessagePrompterBaseStrategy {
  constructor(message, options) {
    super("reactions", message, options);
    __publicField(this, "reactions");
    this.reactions = options?.reactions;
  }
  async run(channel, authorOrFilter) {
    if (!this.reactions?.length)
      throw new TypeError("There are no reactions provided.");
    const response = await this.collectReactions(channel, authorOrFilter, this.reactions);
    return this.explicitReturn ? response : response.reaction ?? response;
  }
};
__name(MessagePrompterReactionStrategy, "MessagePrompterReactionStrategy");

// src/lib/MessagePrompter/MessagePrompter.ts
var _MessagePrompter = class {
  constructor(message, strategy, strategyOptions) {
    __publicField(this, "strategy");
    let strategyToRun;
    if (message instanceof MessagePrompterBaseStrategy) {
      strategyToRun = message;
    } else {
      const mapStrategy = _MessagePrompter.strategies.get(strategy ?? _MessagePrompter.defaultStrategy);
      if (!mapStrategy) {
        throw new Error("No strategy provided");
      }
      strategyToRun = new mapStrategy(message, strategyOptions);
    }
    this.strategy = strategyToRun;
  }
  run(channel, authorOrFilter) {
    return this.strategy.run(channel, authorOrFilter);
  }
};
var MessagePrompter = _MessagePrompter;
__name(MessagePrompter, "MessagePrompter");
__publicField(MessagePrompter, "strategies", /* @__PURE__ */ new Map([
  ["confirm", MessagePrompterConfirmStrategy],
  ["number", MessagePrompterNumberStrategy],
  ["reaction", MessagePrompterReactionStrategy],
  ["message", MessagePrompterMessageStrategy]
]));
__publicField(MessagePrompter, "defaultStrategy", "confirm");

// src/lib/PaginatedMessages/LazyPaginatedMessage.ts
import { isFunction as isFunction2 } from "@sapphire/utilities";
import { MessageEmbed as MessageEmbed2 } from "discord.js";

// src/lib/PaginatedMessages/PaginatedMessage.ts
import { Time } from "@sapphire/time-utilities";
import { deepClone, isFunction, isNullish as isNullish4, isObject } from "@sapphire/utilities";
import {
  Constants as Constants2,
  Formatters,
  Intents,
  InteractionCollector,
  MessageButton,
  MessageEmbed,
  MessageSelectMenu
} from "discord.js";
import { deprecate } from "node:util";

// src/lib/PaginatedMessages/utils.ts
import { chunk, partition } from "@sapphire/utilities";
import {
  Constants,
  Message as Message2,
  MessageActionRow
} from "discord.js";
function runsOnInteraction(messageOrInteraction) {
  return !(messageOrInteraction instanceof Message2);
}
__name(runsOnInteraction, "runsOnInteraction");
function actionIsButtonOrMenu(action) {
  return action.type === Constants.MessageComponentTypes.SELECT_MENU || action.type === "SELECT_MENU" || action.style !== "LINK" && action.style !== Constants.MessageButtonStyles.LINK;
}
__name(actionIsButtonOrMenu, "actionIsButtonOrMenu");
function isMessageButtonInteraction(interaction) {
  return interaction.type === Constants.MessageComponentTypes.BUTTON || interaction.type === "BUTTON";
}
__name(isMessageButtonInteraction, "isMessageButtonInteraction");
function isMessageButtonComponent(component) {
  return component.type === "BUTTON";
}
__name(isMessageButtonComponent, "isMessageButtonComponent");
function createPartitionedMessageRow(components) {
  const [messageButtons, selectMenus] = partition(components, isMessageButtonComponent);
  const chunkedButtonComponents = chunk(messageButtons, 5);
  const messageButtonActionRows = chunkedButtonComponents.map((componentsChunk) => new MessageActionRow().setComponents(componentsChunk));
  const selectMenuActionRows = selectMenus.map((component) => new MessageActionRow().setComponents(component));
  return [...messageButtonActionRows, ...selectMenuActionRows];
}
__name(createPartitionedMessageRow, "createPartitionedMessageRow");
async function safelyReplyToInteraction(parameters) {
  if (runsOnInteraction(parameters.messageOrInteraction)) {
    if (parameters.messageOrInteraction.replied || parameters.messageOrInteraction.deferred) {
      await parameters.messageOrInteraction.editReply(parameters.interactionEditReplyContent);
    } else if (parameters.messageOrInteraction.isMessageComponent()) {
      await parameters.messageOrInteraction.update(parameters.componentUpdateContent);
    } else {
      await parameters.messageOrInteraction.reply(parameters.interactionReplyContent);
    }
  } else if (parameters.messageMethodContent && parameters.messageMethod && isMessageInstance(parameters.messageOrInteraction)) {
    await parameters.messageOrInteraction[parameters.messageMethod](parameters.messageMethodContent);
  }
}
__name(safelyReplyToInteraction, "safelyReplyToInteraction");

// src/lib/PaginatedMessages/PaginatedMessage.ts
var _thisMazeWasNotMeantForYouContent;
var _PaginatedMessage = class {
  constructor({
    pages,
    actions,
    template,
    pageIndexPrefix,
    embedFooterSeparator,
    paginatedMessageData = null
  } = {}) {
    __privateAdd(this, _thisMazeWasNotMeantForYouContent, { content: "This maze wasn't meant for you...what did you do." });
    __publicField(this, "pages");
    __publicField(this, "response", null);
    __publicField(this, "collector", null);
    __publicField(this, "messages", []);
    __publicField(this, "actions", /* @__PURE__ */ new Map());
    __publicField(this, "index", 0);
    __publicField(this, "idle", Time.Minute * 14.5);
    __publicField(this, "template");
    __publicField(this, "pageIndexPrefix", _PaginatedMessage.pageIndexPrefix);
    __publicField(this, "embedFooterSeparator", _PaginatedMessage.embedFooterSeparator);
    __publicField(this, "stopPaginatedMessageCustomIds", _PaginatedMessage.stopPaginatedMessageCustomIds);
    __publicField(this, "emitPartialDMChannelWarning", _PaginatedMessage.emitPartialDMChannelWarning);
    __publicField(this, "paginatedMessageData", null);
    __publicField(this, "selectMenuOptions", _PaginatedMessage.selectMenuOptions);
    __publicField(this, "selectMenuPlaceholder");
    __publicField(this, "wrongUserInteractionReply", _PaginatedMessage.wrongUserInteractionReply);
    __publicField(this, "hasEmittedMaxPageWarning", false);
    __publicField(this, "hasEmittedPartialDMChannelWarning", false);
    this.pages = pages ?? [];
    for (const page of this.pages) {
      if (isFunction(page) || isObject(page)) {
        this.messages.push(page);
      }
    }
    for (const action of actions ?? this.constructor.defaultActions) {
      if (actionIsButtonOrMenu(action)) {
        this.actions.set(action.customId, action);
      } else {
        this.actions.set(action.url, action);
      }
    }
    this.template = _PaginatedMessage.resolveTemplate(template);
    this.pageIndexPrefix = pageIndexPrefix ?? _PaginatedMessage.pageIndexPrefix;
    this.embedFooterSeparator = embedFooterSeparator ?? _PaginatedMessage.embedFooterSeparator;
    this.paginatedMessageData = paginatedMessageData;
  }
  setSelectMenuOptions(newOptions) {
    this.selectMenuOptions = newOptions;
    return this;
  }
  setSelectMenuPlaceholder(placeholder) {
    this.selectMenuPlaceholder = placeholder;
    return this;
  }
  setWrongUserInteractionReply(wrongUserInteractionReply) {
    this.wrongUserInteractionReply = wrongUserInteractionReply;
    return this;
  }
  setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds) {
    this.stopPaginatedMessageCustomIds = stopPaginatedMessageCustomIds;
    return this;
  }
  setEmitPartialDMChannelWarning(emitPartialDMChannelWarning) {
    this.emitPartialDMChannelWarning = emitPartialDMChannelWarning;
    return this;
  }
  setIndex(index) {
    this.index = index;
    return this;
  }
  setIdle(idle) {
    this.idle = idle;
    return this;
  }
  setActions(actions, includeDefaultActions = false) {
    this.actions.clear();
    return this.addActions([...includeDefaultActions ? _PaginatedMessage.defaultActions : [], ...actions]);
  }
  addActions(actions) {
    for (const action of actions)
      this.addAction(action);
    return this;
  }
  addAction(action) {
    if (actionIsButtonOrMenu(action)) {
      this.actions.set(action.customId, action);
    } else {
      this.actions.set(action.url, action);
    }
    return this;
  }
  hasPage(index) {
    return index >= 0 && index < this.pages.length;
  }
  setPages(pages) {
    this.pages = [];
    this.messages = [];
    this.addPages(pages);
    return this;
  }
  addPage(page) {
    if (this.pages.length === 25) {
      if (!this.hasEmittedMaxPageWarning) {
        process.emitWarning("Maximum amount of pages exceeded for PaginatedMessage. Please check your instance of PaginatedMessage and ensure that you do not exceed 25 pages total.", {
          type: "PaginatedMessageExceededMessagePageAmount",
          code: "PAGINATED_MESSAGE_EXCEEDED_MAXIMUM_AMOUNT_OF_PAGES",
          detail: `If you do need more than 25 pages you can extend the class and overwrite the actions in the constructor.`
        });
        this.hasEmittedMaxPageWarning = true;
      }
      return this;
    }
    this.pages.push(page);
    return this;
  }
  addPageBuilder(builder) {
    return this.addPage(isFunction(builder) ? builder(new MessageBuilder()) : builder);
  }
  addAsyncPageBuilder(builder) {
    return this.addPage(async () => isFunction(builder) ? builder(new MessageBuilder()) : builder);
  }
  addPageContent(content) {
    return this.addPage({ content });
  }
  addPageEmbed(embed) {
    return this.addPage({ embeds: isFunction(embed) ? [embed(new MessageEmbed())] : [embed] });
  }
  addAsyncPageEmbed(embed) {
    return this.addPage(async () => ({ embeds: isFunction(embed) ? [await embed(new MessageEmbed())] : [embed] }));
  }
  addPageEmbeds(embeds) {
    let processedEmbeds = isFunction(embeds) ? embeds(new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed()) : embeds;
    if (processedEmbeds.length > 10) {
      processedEmbeds = processedEmbeds.slice(0, 10);
    }
    return this.addPage({ embeds: processedEmbeds });
  }
  addAsyncPageEmbeds(embeds) {
    return this.addPage(async () => {
      let processedEmbeds = isFunction(embeds) ? await embeds(new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed(), new MessageEmbed()) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
  addPages(pages) {
    for (const page of pages)
      this.addPage(page);
    return this;
  }
  async run(messageOrInteraction, target) {
    if (!messageOrInteraction.channel) {
      const isInteraction = runsOnInteraction(messageOrInteraction);
      let shouldEmitWarning = this.emitPartialDMChannelWarning;
      if (shouldEmitWarning && this.hasEmittedPartialDMChannelWarning) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && isInteraction && messageOrInteraction.client.options.partials?.includes("CHANNEL")) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning && !isInteraction && messageOrInteraction.client.options.partials?.includes("CHANNEL") && new Intents(messageOrInteraction.client.options.intents).has(Intents.FLAGS.DIRECT_MESSAGES)) {
        shouldEmitWarning = false;
      }
      if (shouldEmitWarning) {
        process.emitWarning([
          "PaginatedMessage was initiated in a DM channel without the client having the required partial configured.",
          'If you want PaginatedMessage to work in DM channels then make sure you start your client with "CHANNEL" added to "client.options.partials".',
          'Furthermore if you are using message based commands (as opposed to application commands) then you will also need to add the "DIRECT_MESSAGE" intent to "client.options.intents"',
          'If you do not want to be alerted about this in the future then you can disable this warning by setting "PaginatedMessage.emitPartialDMChannelWarning" to "false", or use "setEmitPartialDMChannelWarning(false)" before calling "run".'
        ].join("\n"), {
          type: "PaginatedMessageRunsInNonpartialDMChannel",
          code: "PAGINATED_MESSAGE_RUNS_IN_NON_PARTIAL_DM_CHANNEL"
        });
        this.hasEmittedPartialDMChannelWarning = true;
      }
      await safelyReplyToInteraction({
        messageOrInteraction,
        interactionEditReplyContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: __privateGet(this, _thisMazeWasNotMeantForYouContent),
        messageMethod: "reply",
        messageMethodContent: __privateGet(this, _thisMazeWasNotMeantForYouContent)
      });
      return this;
    }
    target ??= runsOnInteraction(messageOrInteraction) ? messageOrInteraction.user : messageOrInteraction.author;
    const paginatedMessage = _PaginatedMessage.handlers.get(target.id);
    paginatedMessage?.collector?.stop();
    if (runsOnInteraction(messageOrInteraction)) {
      if (messageOrInteraction.user.bot && messageOrInteraction.user.id === messageOrInteraction.client.user?.id) {
        this.response = messageOrInteraction;
      }
    } else if (messageOrInteraction.author.bot && messageOrInteraction.author.id === messageOrInteraction.client.user?.id) {
      this.response = messageOrInteraction;
    }
    await this.resolvePagesOnRun();
    if (!this.messages.length)
      throw new Error("There are no messages.");
    if (!this.actions.size)
      throw new Error("There are no actions.");
    await this.setUpMessage(messageOrInteraction, target);
    this.setUpCollector(messageOrInteraction.channel, target);
    const messageId = this.response.id;
    if (this.collector) {
      this.collector.once("end", () => {
        _PaginatedMessage.messages.delete(messageId);
        _PaginatedMessage.handlers.delete(target.id);
      });
      _PaginatedMessage.messages.set(messageId, this);
      _PaginatedMessage.handlers.set(target.id, this);
    }
    return this;
  }
  async resolvePagesOnRun() {
    for (let i = 0; i < this.pages.length; i++) {
      await this.resolvePage(i);
    }
  }
  async resolvePage(index) {
    const message = this.messages[index];
    if (!isNullish4(message)) {
      return message;
    }
    const resolved = await this.handlePageLoad(this.pages[index], index);
    this.messages[index] = resolved;
    return resolved;
  }
  clone() {
    const clone = new this.constructor({ pages: this.pages, actions: [] }).setIndex(this.index).setIdle(this.idle);
    clone.actions = this.actions;
    clone.response = this.response;
    clone.template = this.template;
    return clone;
  }
  async setUpMessage(messageOrInteraction, targetUser) {
    let page = this.messages[this.index];
    page = isFunction(page) ? await page(this.index, this.pages, this) : page;
    page = { ...page, ...this.paginatedMessageData ?? {} };
    if (this.pages.length > 1) {
      const messageComponents = await Promise.all([...this.actions.values()].map(async (interaction) => {
        return isMessageButtonInteraction(interaction) ? new MessageButton(interaction) : new MessageSelectMenu({
          options: await Promise.all(this.pages.map(async (_, index) => {
            return {
              ...await this.selectMenuOptions(index + 1, this.resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser)),
              value: index.toString()
            };
          })),
          placeholder: this.selectMenuPlaceholder,
          ...interaction
        });
      }));
      page.components = createPartitionedMessageRow(messageComponents);
    }
    if (this.response) {
      if (runsOnInteraction(this.response)) {
        if (this.response.replied || this.response.deferred) {
          await this.response.editReply(page);
        } else {
          await this.response.reply(page);
        }
      } else if (isMessageInstance(this.response)) {
        await this.response.edit(page);
      }
    } else if (runsOnInteraction(messageOrInteraction)) {
      if (messageOrInteraction.replied || messageOrInteraction.deferred) {
        this.response = await messageOrInteraction.editReply(page);
      } else {
        this.response = await messageOrInteraction.reply({ ...page, fetchReply: true, ephemeral: false });
      }
    } else {
      this.response = await messageOrInteraction.channel.send(page);
    }
  }
  setUpCollector(channel, targetUser) {
    if (this.pages.length > 1) {
      this.collector = new InteractionCollector(targetUser.client, {
        filter: (interaction) => !isNullish4(this.response) && interaction.isMessageComponent() && this.actions.has(interaction.customId),
        time: this.idle,
        guild: isGuildBasedChannel(channel) ? channel.guild : void 0,
        channel,
        interactionType: Constants2.InteractionTypes.MESSAGE_COMPONENT,
        ...!isNullish4(this.response) && !runsOnInteraction(this.response) ? {
          message: this.response
        } : {}
      }).on("collect", this.handleCollect.bind(this, targetUser, channel)).on("end", this.handleEnd.bind(this));
    }
  }
  async handlePageLoad(page, index) {
    const options = isFunction(page) ? await page(index, this.pages, this) : page;
    const clonedTemplate = deepClone(this.template);
    const optionsWithTemplate = this.applyTemplate(clonedTemplate, options);
    return this.applyFooter(optionsWithTemplate, index);
  }
  async handleCollect(targetUser, channel, interaction) {
    if (interaction.user.id === targetUser.id) {
      this.response = interaction;
      const action = this.actions.get(interaction.customId);
      if (actionIsButtonOrMenu(action)) {
        const previousIndex = this.index;
        await action.run({
          interaction,
          handler: this,
          author: targetUser,
          channel,
          response: this.response,
          collector: this.collector
        });
        if (!this.stopPaginatedMessageCustomIds.includes(action.customId)) {
          const newIndex = previousIndex === this.index ? previousIndex : this.index;
          const messagePage = await this.resolvePage(newIndex);
          const updateOptions = isFunction(messagePage) ? await messagePage(newIndex, this.pages, this) : messagePage;
          await safelyReplyToInteraction({
            messageOrInteraction: interaction,
            interactionEditReplyContent: updateOptions,
            interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
            componentUpdateContent: updateOptions
          });
        }
      }
    } else {
      const interactionReplyOptions = await this.wrongUserInteractionReply(targetUser, interaction.user, this.resolvePaginatedMessageInternationalizationContext(interaction, targetUser));
      await interaction.reply(isObject(interactionReplyOptions) ? interactionReplyOptions : { content: interactionReplyOptions, ephemeral: true, allowedMentions: { users: [], roles: [] } });
    }
  }
  handleEnd(_, reason) {
    this.collector?.removeAllListeners();
    if (this.response && !_PaginatedMessage.deletionStopReasons.includes(reason)) {
      void safelyReplyToInteraction({
        messageOrInteraction: this.response,
        interactionEditReplyContent: { components: [] },
        interactionReplyContent: { ...__privateGet(this, _thisMazeWasNotMeantForYouContent), ephemeral: true },
        componentUpdateContent: { components: [] },
        messageMethod: "edit",
        messageMethodContent: { components: [] }
      });
    }
  }
  applyFooter(message, index) {
    if (!message.embeds?.length) {
      return message;
    }
    const embedsWithFooterApplied = deepClone(message.embeds);
    const idx = embedsWithFooterApplied.length - 1;
    const lastEmbed = embedsWithFooterApplied[idx];
    if (lastEmbed) {
      lastEmbed.footer ??= { text: this.template.embeds?.[idx]?.footer?.text ?? this.template.embeds?.[0]?.footer?.text ?? "" };
      lastEmbed.footer.text = `${this.pageIndexPrefix ? `${this.pageIndexPrefix} ` : ""}${index + 1} / ${this.pages.length}${lastEmbed.footer.text ? ` ${this.embedFooterSeparator} ${lastEmbed.footer.text}` : ""}`;
    }
    return { ...message, embeds: embedsWithFooterApplied };
  }
  resolvePaginatedMessageInternationalizationContext(messageOrInteraction, targetUser) {
    const context = {
      user: targetUser,
      channel: messageOrInteraction.channel,
      guild: isGuildBasedChannel(messageOrInteraction.channel) ? messageOrInteraction.channel.guild : null,
      interactionGuildLocale: runsOnInteraction(messageOrInteraction) ? messageOrInteraction.guildLocale : void 0,
      interactionLocale: runsOnInteraction(messageOrInteraction) ? messageOrInteraction.locale : void 0
    };
    Object.defineProperty(context, "author", {
      get: deprecate(() => {
        return context.user;
      }, "PaginatedMessageInternationalizationContext's `author` property is deprecated and will be removed in the next major version. Please use `PaginatedMessageInternationalizationContext.user` instead.", "DeprecationWarning"),
      set: deprecate((val) => {
        context.user = val;
      }, "PaginatedMessageInternationalizationContext's `author` property is deprecated and will be removed in the next major version. Please use `PaginatedMessageInternationalizationContext.user` instead.", "DeprecationWarning")
    });
    return context;
  }
  applyTemplate(template, options) {
    const embedData = this.applyTemplateEmbed(template.embeds, options.embeds);
    return { ...template, ...options, embeds: embedData };
  }
  applyTemplateEmbed(templateEmbed, pageEmbeds) {
    if (isNullish4(pageEmbeds)) {
      return templateEmbed ? [templateEmbed?.[0]] : void 0;
    }
    if (isNullish4(templateEmbed)) {
      return pageEmbeds;
    }
    return this.mergeEmbeds(templateEmbed[0], pageEmbeds);
  }
  mergeEmbeds(templateEmbed, pageEmbeds) {
    const mergedEmbeds = [];
    for (const pageEmbed of pageEmbeds) {
      mergedEmbeds.push({
        title: pageEmbed.title ?? templateEmbed.title ?? void 0,
        description: pageEmbed.description ?? templateEmbed.description ?? void 0,
        url: pageEmbed.url ?? templateEmbed.url ?? void 0,
        timestamp: (typeof pageEmbed.timestamp === "string" ? new Date(pageEmbed.timestamp) : pageEmbed.timestamp) ?? (typeof templateEmbed.timestamp === "string" ? new Date(templateEmbed.timestamp) : templateEmbed.timestamp) ?? void 0,
        color: pageEmbed.color ?? templateEmbed.color ?? void 0,
        fields: this.mergeArrays(templateEmbed.fields, pageEmbed.fields),
        author: pageEmbed.author ?? templateEmbed.author ?? void 0,
        thumbnail: pageEmbed.thumbnail ?? templateEmbed.thumbnail ?? void 0,
        image: pageEmbed.image ?? templateEmbed.image ?? void 0,
        video: pageEmbed.video ?? templateEmbed.video ?? void 0,
        footer: pageEmbed.footer ?? templateEmbed.footer ?? void 0
      });
    }
    return mergedEmbeds;
  }
  mergeArrays(template, array) {
    if (isNullish4(array)) {
      return template;
    }
    if (isNullish4(template)) {
      return array;
    }
    return [...template, ...array];
  }
  static resolveTemplate(template) {
    if (template === void 0) {
      return {};
    }
    if (template instanceof MessageEmbed) {
      return { embeds: [template] };
    }
    return template;
  }
};
var PaginatedMessage = _PaginatedMessage;
__name(PaginatedMessage, "PaginatedMessage");
_thisMazeWasNotMeantForYouContent = new WeakMap();
__publicField(PaginatedMessage, "defaultActions", [
  {
    customId: "@sapphire/paginated-messages.goToPage",
    type: Constants2.MessageComponentTypes.SELECT_MENU,
    run: ({ handler, interaction }) => interaction.isSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
  },
  {
    customId: "@sapphire/paginated-messages.firstPage",
    style: "PRIMARY",
    emoji: "\u23EA",
    type: Constants2.MessageComponentTypes.BUTTON,
    run: ({ handler }) => handler.index = 0
  },
  {
    customId: "@sapphire/paginated-messages.previousPage",
    style: "PRIMARY",
    emoji: "\u25C0\uFE0F",
    type: Constants2.MessageComponentTypes.BUTTON,
    run: ({ handler }) => {
      if (handler.index === 0) {
        handler.index = handler.pages.length - 1;
      } else {
        --handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.nextPage",
    style: "PRIMARY",
    emoji: "\u25B6\uFE0F",
    type: Constants2.MessageComponentTypes.BUTTON,
    run: ({ handler }) => {
      if (handler.index === handler.pages.length - 1) {
        handler.index = 0;
      } else {
        ++handler.index;
      }
    }
  },
  {
    customId: "@sapphire/paginated-messages.goToLastPage",
    style: "PRIMARY",
    emoji: "\u23E9",
    type: Constants2.MessageComponentTypes.BUTTON,
    run: ({ handler }) => handler.index = handler.pages.length - 1
  },
  {
    customId: "@sapphire/paginated-messages.stop",
    style: "DANGER",
    emoji: "\u23F9\uFE0F",
    type: Constants2.MessageComponentTypes.BUTTON,
    run: ({ collector }) => {
      collector.stop();
    }
  }
]);
__publicField(PaginatedMessage, "emitPartialDMChannelWarning", true);
__publicField(PaginatedMessage, "stopPaginatedMessageCustomIds", ["@sapphire/paginated-messages.stop"]);
__publicField(PaginatedMessage, "deletionStopReasons", ["messageDelete", "channelDelete", "guildDelete"]);
__publicField(PaginatedMessage, "pageIndexPrefix", "");
__publicField(PaginatedMessage, "embedFooterSeparator", "\u2022");
__publicField(PaginatedMessage, "messages", /* @__PURE__ */ new Map());
__publicField(PaginatedMessage, "handlers", /* @__PURE__ */ new Map());
__publicField(PaginatedMessage, "selectMenuOptions", /* @__PURE__ */ __name((pageIndex) => ({ label: `Page ${pageIndex}` }), "selectMenuOptions"));
__publicField(PaginatedMessage, "wrongUserInteractionReply", /* @__PURE__ */ __name((targetUser) => ({
  content: `Please stop interacting with the components on this message. They are only for ${Formatters.userMention(targetUser.id)}.`,
  ephemeral: true,
  allowedMentions: { users: [], roles: [] }
}), "wrongUserInteractionReply"));

// src/lib/PaginatedMessages/LazyPaginatedMessage.ts
var LazyPaginatedMessage = class extends PaginatedMessage {
  async resolvePagesOnRun() {
    await this.resolvePage(this.index);
  }
  async resolvePage(index) {
    const promises = [super.resolvePage(index)];
    if (this.hasPage(index - 1))
      promises.push(super.resolvePage(index - 1));
    if (this.hasPage(index + 1))
      promises.push(super.resolvePage(index + 1));
    const [result] = await Promise.all(promises);
    return result;
  }
  addPageBuilder(builder) {
    return this.addPage(() => isFunction2(builder) ? builder(new MessageBuilder()) : builder);
  }
  addPageContent(content) {
    return this.addPage(() => ({ content }));
  }
  addPageEmbed(embed) {
    return this.addPage(() => ({ embeds: typeof embed === "function" ? [embed(new MessageEmbed2())] : [embed] }));
  }
  addPageEmbeds(embeds) {
    return this.addPage(() => {
      let processedEmbeds = isFunction2(embeds) ? embeds(new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2(), new MessageEmbed2()) : embeds;
      if (processedEmbeds.length > 10) {
        processedEmbeds = processedEmbeds.slice(0, 10);
      }
      return { embeds: processedEmbeds };
    });
  }
};
__name(LazyPaginatedMessage, "LazyPaginatedMessage");

// src/lib/PaginatedMessages/PaginatedFieldMessageEmbed.ts
import { isFunction as isFunction3 } from "@sapphire/utilities";
import { MessageEmbed as MessageEmbed3 } from "discord.js";
var PaginatedFieldMessageEmbed = class extends PaginatedMessage {
  constructor() {
    super(...arguments);
    __publicField(this, "embedTemplate", new MessageEmbed3());
    __publicField(this, "totalPages", 0);
    __publicField(this, "items", []);
    __publicField(this, "itemsPerPage", 10);
    __publicField(this, "fieldTitle", "");
  }
  setItems(items) {
    this.items = items;
    return this;
  }
  setTitleField(title) {
    this.fieldTitle = title;
    return this;
  }
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  formatItems(formatter) {
    this.items = this.items.map(formatter);
    return this;
  }
  make() {
    if (!this.fieldTitle.length)
      throw new Error("The title of the field to format must have a value.");
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.items.some((x) => !x))
      throw new Error("The format of the array items is incorrect.");
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  generatePages() {
    const template = this.embedTemplate instanceof MessageEmbed3 ? this.embedTemplate.toJSON() : this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new MessageEmbed3(template);
      const fieldsClone = this.embedTemplate.fields;
      clonedTemplate.fields = [];
      if (!clonedTemplate.color)
        clonedTemplate.setColor("RANDOM");
      const data = this.paginateArray(this.items, i, this.itemsPerPage);
      this.addPage({
        embeds: [clonedTemplate.addField(this.fieldTitle, data.join("\n"), false).addFields(fieldsClone)]
      });
    }
  }
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  resolveTemplate(template) {
    if (template instanceof MessageEmbed3) {
      return template;
    }
    if (isFunction3(template)) {
      return template(new MessageEmbed3());
    }
    return new MessageEmbed3(template);
  }
};
__name(PaginatedFieldMessageEmbed, "PaginatedFieldMessageEmbed");

// src/lib/PaginatedMessages/PaginatedMessageEmbedFields.ts
import { EmbedLimits } from "@sapphire/discord-utilities";
import { isFunction as isFunction4 } from "@sapphire/utilities";
import { MessageEmbed as MessageEmbed4 } from "discord.js";
var PaginatedMessageEmbedFields = class extends PaginatedMessage {
  constructor() {
    super(...arguments);
    __publicField(this, "embedTemplate", new MessageEmbed4());
    __publicField(this, "totalPages", 0);
    __publicField(this, "items", []);
    __publicField(this, "itemsPerPage", 10);
  }
  setItems(items) {
    this.items = items;
    return this;
  }
  setItemsPerPage(itemsPerPage) {
    this.itemsPerPage = itemsPerPage;
    return this;
  }
  setTemplate(template) {
    this.embedTemplate = this.resolveTemplate(template);
    return this;
  }
  make() {
    if (!this.items.length)
      throw new Error("The items array is empty.");
    if (this.itemsPerPage > EmbedLimits.MaximumFields)
      throw new Error(`Pages cannot contain more than ${EmbedLimits.MaximumFields} fields.`);
    this.totalPages = Math.ceil(this.items.length / this.itemsPerPage);
    this.generatePages();
    return this;
  }
  generatePages() {
    const template = this.embedTemplate instanceof MessageEmbed4 ? this.embedTemplate.toJSON() : this.embedTemplate;
    for (let i = 0; i < this.totalPages; i++) {
      const clonedTemplate = new MessageEmbed4(template);
      const fieldsClone = this.embedTemplate.fields;
      clonedTemplate.fields = [];
      if (!clonedTemplate.color)
        clonedTemplate.setColor("RANDOM");
      const data = this.paginateArray(this.items, i, this.itemsPerPage - fieldsClone.length);
      this.addPage({
        embeds: [clonedTemplate.addFields(...data, ...fieldsClone)]
      });
    }
  }
  paginateArray(items, currentPage, perPageItems) {
    const offset = currentPage * perPageItems;
    return items.slice(offset, offset + perPageItems);
  }
  resolveTemplate(template) {
    if (template instanceof MessageEmbed4) {
      return template;
    }
    if (isFunction4(template)) {
      return template(new MessageEmbed4());
    }
    return new MessageEmbed4(template);
  }
};
__name(PaginatedMessageEmbedFields, "PaginatedMessageEmbedFields");

// src/lib/utilities.ts
import { isNullish as isNullish5 } from "@sapphire/utilities";
import { Permissions } from "discord.js";
var canReadMessagesPermissions = new Permissions(["VIEW_CHANNEL"]);
function canReadMessages(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  return canDoUtility(channel, canReadMessagesPermissions);
}
__name(canReadMessages, "canReadMessages");
var canSendMessagesPermissions = new Permissions([canReadMessagesPermissions, "SEND_MESSAGES"]);
function canSendMessages(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendMessagesPermissions);
}
__name(canSendMessages, "canSendMessages");
var canSendEmbedsPermissions = new Permissions([canSendMessagesPermissions, "EMBED_LINKS"]);
function canSendEmbeds(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendEmbedsPermissions);
}
__name(canSendEmbeds, "canSendEmbeds");
var canSendAttachmentsPermissions = new Permissions([canSendMessagesPermissions, "ATTACH_FILES"]);
function canSendAttachments(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && !channel.sendable)
    return false;
  return canDoUtility(channel, canSendAttachmentsPermissions);
}
__name(canSendAttachments, "canSendAttachments");
var canReactPermissions = new Permissions([canSendMessagesPermissions, "READ_MESSAGE_HISTORY", "ADD_REACTIONS"]);
function canReact(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return true;
  if (channel.isThread() && channel.archived)
    return false;
  return canDoUtility(channel, canReactPermissions);
}
__name(canReact, "canReact");
var canRemoveAllReactionsPermissions = new Permissions([canReadMessagesPermissions, "READ_MESSAGE_HISTORY", "MANAGE_MESSAGES"]);
function canRemoveAllReactions(channel) {
  if (isNullish5(channel))
    return false;
  if (isDMChannel(channel))
    return false;
  return canDoUtility(channel, canRemoveAllReactionsPermissions);
}
__name(canRemoveAllReactions, "canRemoveAllReactions");
var canJoinVoiceChannelPermissions = new Permissions(["CONNECT"]);
function canJoinVoiceChannel(channel) {
  if (isNullish5(channel))
    return false;
  if (!isVoiceBasedChannel(channel))
    return false;
  if (channel.userLimit >= channel.members.size)
    return false;
  return canDoUtility(channel, canJoinVoiceChannelPermissions);
}
__name(canJoinVoiceChannel, "canJoinVoiceChannel");
function canDoUtility(channel, permissionsToPass) {
  return isGuildBasedChannel(channel) ? channel.permissionsFor(channel.guild.me).has(permissionsToPass) : true;
}
__name(canDoUtility, "canDoUtility");
export {
  LazyPaginatedMessage,
  MessageBuilder,
  MessagePrompter,
  MessagePrompterBaseStrategy,
  MessagePrompterConfirmStrategy,
  MessagePrompterMessageStrategy,
  MessagePrompterNumberStrategy,
  MessagePrompterReactionStrategy,
  PaginatedFieldMessageEmbed,
  PaginatedMessage,
  PaginatedMessageEmbedFields,
  actionIsButtonOrMenu,
  canJoinVoiceChannel,
  canReact,
  canReadMessages,
  canRemoveAllReactions,
  canSendAttachments,
  canSendEmbeds,
  canSendMessages,
  createPartitionedMessageRow,
  isCategoryChannel,
  isDMChannel,
  isGroupChannel,
  isGuildBasedChannel,
  isGuildBasedChannelByGuildKey,
  isGuildMember,
  isMessageButtonComponent,
  isMessageButtonInteraction,
  isMessageInstance,
  isNewsChannel,
  isNewsThreadChannel,
  isNsfwChannel,
  isPrivateThreadChannel,
  isPublicThreadChannel,
  isStageChannel,
  isStoreChannel,
  isTextBasedChannel,
  isTextChannel,
  isThreadChannel,
  isVoiceBasedChannel,
  isVoiceChannel,
  runsOnInteraction,
  safelyReplyToInteraction
};
//# sourceMappingURL=index.mjs.map