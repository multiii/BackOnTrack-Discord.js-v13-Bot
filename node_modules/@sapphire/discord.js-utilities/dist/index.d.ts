export * from '@sapphire/discord-utilities';
import { MessageOptions, CategoryChannel, DMChannel, PartialDMChannel, NewsChannel, StageChannel, StoreChannel, TextChannel, ThreadChannel, VoiceChannel, GuildChannel, Channel, Message, PartialTextBasedChannelFields, EmojiIdentifierResolvable, User, CollectorFilter, MessageReaction, CollectorOptions, GuildEmoji, ReactionEmoji, EmojiResolvable, InteractionButtonOptions, ExcludeEnum, LinkButtonOptions, MessageSelectMenuOptions, ButtonInteraction, SelectMenuInteraction, CommandInteraction, InteractionCollector, MessageComponentInteraction, MessageEmbed, MessageSelectOptionData, WebhookEditMessageOptions, Guild, Interaction, ContextMenuInteraction, InteractionReplyOptions, InteractionUpdateOptions, ReplyMessageOptions, MessageEditOptions, TextBasedChannel, Collection, Snowflake, MessageEmbedOptions, EmbedFieldData, MessageButton, MessageSelectMenu, MessageActionRow, PartialGroupDMChannel, BaseGuildVoiceChannel, GuildMember, VoiceBasedChannel } from 'discord.js';
import { ArgumentTypes, Awaitable, Ctor, Nullish } from '@sapphire/utilities';
import { APIMessage, APIGuildMember, APIInteractionGuildMember } from 'discord-api-types/v9';
import { MessageComponentTypes, MessageButtonStyles } from 'discord.js/typings/enums';

declare type MessageBuilderFileResolvable = NonNullable<MessageOptions['files']>[number];
declare type MessageBuilderResolvable = Omit<MessageOptions, 'embed' | 'disableMentions' | 'reply'> & {
    embeds?: MessageOptions['embeds'];
};
/**
 * A message builder class, it implements the {@link MessageOptions} interface.
 */
declare class MessageBuilder implements MessageOptions {
    /**
     * Whether or not the message should be spoken aloud.
     * @default false
     */
    tts?: MessageOptions['tts'];
    /**
     * The nonce for the message.
     * @default ''
     */
    nonce?: MessageOptions['nonce'];
    /**
     * The content for the message. If set to undefined and the builder is used to edit, the content will not be
     * replaced.
     */
    content?: MessageOptions['content'];
    /**
     * The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be replaced.
     * @remark There is a maximum of 10 embeds in 1 message
     */
    embeds?: MessageOptions['embeds'];
    /**
     * Which mentions should be parsed from the message content.
     */
    allowedMentions?: MessageOptions['allowedMentions'];
    /**
     * Files to send with the message. This should not be set when editing a message, as Discord does not support
     * editing file attachments.
     */
    files?: MessageOptions['files'];
    constructor(options?: MessageBuilderResolvable);
    /**
     * Sets the value for the {@link MessageBuilder.tts} field.
     * @param tts Whether or not the message should be spoken aloud.
     */
    setTTS(tts?: boolean): this;
    /**
     * Sets the value for the {@link MessageBuilder.nonce} field.
     * @param nonce The nonce for the message.
     */
    setNonce(nonce?: string): this;
    /**
     * Sets the value for the {@link MessageBuilder.content} field.
     * @param content The content for the message. If set to undefined and the builder is used to edit, the content will
     * not be replaced.
     */
    setContent(content?: string): this;
    /**
     * Sets the value for the {@link MessageBuilder.embed} field.
     * @param embeds The embeds for the message. If set to undefined and the builder is used to edit, the embed will not be
     * replaced. There is a maximum of 10 embeds per message
     * @remark When providing more than 10 embeds, the array will automatically be sliced down to the first 10.
     */
    setEmbeds(embeds?: MessageOptions['embeds']): this;
    /**
     * Sets the value for the {@link MessageBuilder.allowedMentions} field.
     * @param allowedMentions Which mentions should be parsed from the message content.
     */
    setAllowedMentions(allowedMentions?: MessageOptions['allowedMentions']): this;
    /**
     * Adds a new value for the {@link MessageBuilder.files} field array.
     * @param file The file to add to the {@link MessageBuilder.files} field array.
     */
    addFile(file: MessageBuilderFileResolvable): this;
    /**
     * Sets a single value for the {@link MessageBuilder.files} field array.
     * @param file The file to send with the message. This should not be set when editing a message, as Discord does not
     * support editing file attachments.
     */
    setFile(file: MessageBuilderFileResolvable): this;
    /**
     * Sets the value for the {@link MessageBuilder.files} field.
     * @param files The files to send with the message. This should not be set when editing a message, as Discord does
     * not support editing file attachments.
     */
    setFiles(files?: MessageBuilderFileResolvable[]): this;
    /**
     * The default values for all MessageBuilder instances.
     */
    static defaults: MessageBuilderResolvable;
}

/**
 * A union of all the various types of channels that Discord.js has
 */
declare type ChannelTypes = CategoryChannel | DMChannel | PartialDMChannel | NewsChannel | StageChannel | StoreChannel | TextChannel | ThreadChannel | VoiceChannel | GuildChannel | Channel;
/**
 * A union of all the channel types that a message can come from
 */
declare type TextBasedChannelTypes = Message['channel'];
/**
 * A union of all the voice-based channel types that Discord.js has
 */
declare type VoiceBasedChannelTypes = VoiceChannel | StageChannel;
/**
 * A union of all the channel types that belong to a guild, not including {@link ThreadChannel}
 */
declare type NonThreadGuildBasedChannelTypes = Extract<ChannelTypes, GuildChannel>;
/**
 * A union of all the channel types that belong to a guild, including {@link ThreadChannel}
 */
declare type GuildBasedChannelTypes = NonThreadGuildBasedChannelTypes | ThreadChannel;
/**
 * A union of guild based message channels, not including {@link ThreadChannel}
 */
declare type NonThreadGuildTextBasedChannelTypes = Extract<TextBasedChannelTypes, GuildChannel>;
/**
 * A union of guild based message channels, including {@link ThreadChannel}
 */
declare type GuildTextBasedChannelTypes = NonThreadGuildTextBasedChannelTypes | ThreadChannel;
/**
 * The types of a channel, with the addition of `'UNKNOWN'`
 */
declare type ChannelTypeString = ChannelTypes['type'] | 'UNKNOWN';

/**
 * A type to extend multiple discord types and simplify usage in {@link MessagePrompter}
 */
declare type MessagePrompterMessage = Omit<ArgumentTypes<PartialTextBasedChannelFields['send']>[0], 'flags'>;
declare type MessagePrompterChannelTypes = Exclude<ChannelTypes, VoiceBasedChannelTypes | StoreChannel | CategoryChannel>;

interface IMessagePrompterStrategyOptions {
    timeout?: number;
    explicitReturn?: boolean;
    editMessage?: Message;
}
interface IMessagePrompterConfirmStrategyOptions extends IMessagePrompterStrategyOptions {
    confirmEmoji?: string | EmojiIdentifierResolvable;
    cancelEmoji?: string | EmojiIdentifierResolvable;
}
interface IMessagePrompterNumberStrategyOptions extends IMessagePrompterStrategyOptions {
    start?: number;
    end?: number;
    numberEmojis?: string[] | EmojiIdentifierResolvable[];
}
interface IMessagePrompterReactionStrategyOptions extends IMessagePrompterStrategyOptions {
    reactions: string[] | EmojiIdentifierResolvable[];
}

declare abstract class MessagePrompterBaseStrategy {
    /**
     * The type of strategy that was used
     */
    type: string;
    /**
     * The timeout that was used in the collector
     */
    timeout: number;
    /**
     * Whether to return an explicit object with data, or the strategies' default
     */
    explicitReturn: boolean;
    /**
     * The message that has been sent in {@link MessagePrompter.run}
     */
    appliedMessage: Message | null;
    /**
     * The message that will be sent in {@link MessagePrompter.run}
     */
    message: MessagePrompterMessage;
    /**
     * The message the bot will edit to send its prompt in {@link MessagePrompter.run}
     */
    editMessage: Message | undefined;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(type: string, message: MessagePrompterMessage, options?: IMessagePrompterStrategyOptions);
    abstract run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<unknown[]>): Awaitable<unknown>;
    protected collectReactions(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>, reactions: string[] | EmojiIdentifierResolvable[]): Promise<IMessagePrompterExplicitReturnBase>;
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitReactions function
     */
    protected createReactionPromptFilter(reactions: string[] | EmojiIdentifierResolvable[], authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): CollectorOptions<[MessageReaction, User]>;
    /**
     * The default strategy options
     */
    static defaultStrategyOptions: IMessagePrompterStrategyOptions;
}

interface IMessagePrompterExplicitReturnBase {
    emoji?: GuildEmoji | ReactionEmoji;
    reaction?: string | EmojiIdentifierResolvable;
    strategy: MessagePrompterBaseStrategy;
    appliedMessage: Message;
    message: MessagePrompterMessage;
}
interface IMessagePrompterExplicitConfirmReturn extends IMessagePrompterExplicitReturnBase {
    confirmed: boolean;
}
interface IMessagePrompterExplicitNumberReturn extends IMessagePrompterExplicitReturnBase {
    number: number;
}
interface IMessagePrompterExplicitMessageReturn extends IMessagePrompterExplicitReturnBase {
    response?: Message;
}

declare class MessagePrompterConfirmStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterConfirmStrategyOptions {
    /**
     * The confirm emoji used
     */
    confirmEmoji: string | EmojiResolvable;
    /**
     * The cancel emoji used
     */
    cancelEmoji: string | EmojiResolvable;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param message The message to be sent {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options?: IMessagePrompterConfirmStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals confirm.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to a boolean denoting the value of the input (`true` for yes, `false` for no).
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitConfirmReturn | boolean>;
    /**
     * The default confirm emoji used for {@link MessagePrompterConfirmStrategy}
     */
    static confirmEmoji: string | EmojiResolvable;
    /**
     * The default cancel emoji used for {@link MessagePrompterConfirmStrategy}
     */
    static cancelEmoji: string | EmojiResolvable;
}

declare class MessagePrompterMessageStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterStrategyOptions {
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals message.
     * The handler will wait for one (1) message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the message object received.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[Message]>): Promise<IMessagePrompterExplicitMessageReturn | Message>;
    /**
     * Creates a filter for the collector to filter on
     * @return The filter for awaitMessages function
     */
    private createMessagePromptFilter;
}

declare class MessagePrompterNumberStrategy extends MessagePrompterBaseStrategy implements IMessagePrompterNumberStrategyOptions {
    /**
     * The available number emojis
     */
    numberEmojis: EmojiIdentifierResolvable[];
    /**
     * The available number emojis
     */
    start: number;
    /**
     * The available number emojis
     */
    end: number;
    /**
     * Constructor for the {@link MessagePrompterBaseStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterNumberStrategyOptions);
    /**
     * This executes the {@link MessagePrompter} and sends the message if {@link IMessagePrompterOptions.type} equals number.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the selected number within the range.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitNumberReturn | number>;
    /**
     * The default available number emojis
     */
    static numberEmojis: string[];
}

declare class MessagePrompterReactionStrategy extends MessagePrompterBaseStrategy implements MessagePrompterReactionStrategy {
    /**
     * The emojis used
     */
    reactions: EmojiIdentifierResolvable[];
    /**
     * Constructor for the {@link MessagePrompterReactionStrategy} class
     * @param messagePrompter The used instance of {@link MessagePrompter}
     * @param options Overrideable options if needed.
     */
    constructor(message: MessagePrompterMessage, options: IMessagePrompterReactionStrategyOptions);
    /**
     * This executes the {@link MessagePrompterReactionStrategy} and sends the message.
     * The handler will wait for one (1) reaction.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     * @returns A promise that resolves to the reaction object.
     */
    run(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<[MessageReaction, User]>): Promise<IMessagePrompterExplicitReturnBase | string | EmojiResolvable>;
}

interface StrategyReturns {
    confirm: IMessagePrompterExplicitConfirmReturn | boolean;
    message: IMessagePrompterExplicitMessageReturn | Message;
    number: IMessagePrompterExplicitNumberReturn | number;
    reaction: IMessagePrompterExplicitReturnBase | string | EmojiResolvable;
}
interface StrategyOptions {
    confirm: IMessagePrompterConfirmStrategyOptions;
    message: IMessagePrompterStrategyOptions;
    number: IMessagePrompterNumberStrategyOptions;
    reaction: IMessagePrompterReactionStrategyOptions;
}
interface StrategyFilters {
    confirm: [MessageReaction, User];
    message: [Message];
    number: [MessageReaction, User];
    reaction: [MessageReaction, User];
}
/**
 * This is a {@link MessagePrompter}, a utility that sends a message, prompting for user input. The prompt can resolve to any kind of input.
 * There are several specifiable types to prompt for user input, and they are as follows:
 * - Confirm
 *   This will send a simple Yes/No prompt, using reactions.
 * - Number
 *   This will prompt for an integer. By default it will be a number between 0 and 10 (inclusive), however you can also specify your own custom range (inclusive).
 * - Reactions
 *   This can be any kind of reaction emoji that Discord supports, and as many as you want. This type will return that reaction instead of a boolean.
 * - Message
 *   This will prompt the user and require a response in the form of a message. This can be helpful if you require a user to upload an image for example, or give text input.
 *
 * You must either use this class directly or extend it.
 *
 * {@link MessagePrompter} uses reactions to prompt for a yes/no answer and returns it.
 * You can modify the confirm and cancel reaction used for each message, or use the {@link MessagePrompter.defaultPrompts}.
 * {@link MessagePrompter.defaultPrompts} is also static so you can modify these directly.
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you sure you want to continue?');
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Choose a number between 5 and 10?', 'number', {
 * 		start: 5,
 * 		end: 10
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Are you happy or sad?', 'reaction', {
 * 		reactions: ['üôÇ', 'üôÅ']
 * });
 * const result = await handler.run(channel, author);
 * ```
 *
 * @example
 * ```typescript
 * const { MessagePrompter } = require('@sapphire/discord.js-utilities');
 *
 * const handler = new MessagePrompter('Do you love me?', 'message');
 * const result = await handler.run(channel, author);
 * ```
 */
declare class MessagePrompter<S extends keyof StrategyReturns = 'confirm'> {
    /**
     * The strategy used in {@link MessagePrompter.run}
     */
    strategy: MessagePrompterBaseStrategy;
    /**
     * Constructor for the {@link MessagePrompter} class
     * @param message The message to send.
     * @param strategy The strategy name or Instance to use
     * @param strategyOptions The options that are passed to the strategy
     */
    constructor(message: MessagePrompterMessage | MessagePrompterBaseStrategy, strategy?: S, strategyOptions?: S extends keyof StrategyOptions ? StrategyOptions[S] : never);
    /**
     * This executes the {@link MessagePrompter} and sends the message.
     * @param channel The channel to use.
     * @param authorOrFilter An author object to validate or a {@linkplain https://discord.js.org/#/docs/main/stable/typedef/CollectorFilter CollectorFilter} predicate callback.
     */
    run<Filter extends S extends keyof StrategyFilters ? StrategyFilters[S] : unknown[]>(channel: MessagePrompterChannelTypes, authorOrFilter: User | CollectorFilter<Filter>): S extends keyof StrategyReturns ? Promise<StrategyReturns[S]> : never;
    /**
     * The available strategies
     */
    static strategies: Map<keyof StrategyReturns, Ctor<ConstructorParameters<typeof MessagePrompterConfirmStrategy> | ConstructorParameters<typeof MessagePrompterNumberStrategy> | ConstructorParameters<typeof MessagePrompterReactionStrategy> | ConstructorParameters<typeof MessagePrompterMessageStrategy>, MessagePrompterConfirmStrategy | MessagePrompterNumberStrategy | MessagePrompterReactionStrategy | MessagePrompterMessageStrategy>>;
    /**
     * The default strategy to use
     */
    static defaultStrategy: keyof StrategyReturns;
}

declare type PaginatedMessageAction = PaginatedMessageActionButton | PaginatedMessageActionLink | PaginatedMessageActionMenu;
/**
 * To utilize buttons you can pass an object with the structure of {@link PaginatedMessageActionButton} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const StopAction: PaginatedMessageActionButton {
 *   customId: 'CustomStopAction',
 *   emoji: '‚èπÔ∏è',
 *   run: ({ collector }) => {
 *     collector.stop();
 *   }
 * }
 * ```
 */
interface PaginatedMessageActionButton extends Omit<InteractionButtonOptions, 'customId' | 'style'> {
    customId: string;
    type: ExcludeEnum<typeof MessageComponentTypes, 'SELECT_MENU' | 'ACTION_ROW'>;
    style: ExcludeEnum<typeof MessageButtonStyles, 'LINK'>;
    run(context: PaginatedMessageActionContext): Awaitable<unknown>;
}
/**
 * To utilize links you can pass an object with the structure of {@link PaginatedMessageActionLink} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 *  You can also give the object directly.
 *
 * const LinkSapphireJs: PaginatedMessageActionLink {
 *   url: 'https://sapphirejs.dev',
 *   label: 'Sapphire Website',
 *   emoji: 'üîó'
 * }
 * ```
 */
interface PaginatedMessageActionLink extends LinkButtonOptions {
    type: ExcludeEnum<typeof MessageComponentTypes, 'SELECT_MENU' | 'ACTION_ROW'>;
}
/**
 * To utilize Select Menus you can pass an object with the structure of {@link PaginatedMessageActionMenu} to {@link PaginatedMessage} actions.
 * @example
 * ```typescript
 * const StopAction: PaginatedMessageActionMenu {
 *   customId: 'CustomSelectMenu',
 *   type: Constants.MessageComponentTypes.SELECT_MENU,
 *   run: ({ handler, interaction }) => interaction.isSelectMenu() && (handler.index = parseInt(interaction.values[0], 10))
 * }
 * ```
 */
interface PaginatedMessageActionMenu extends Omit<MessageSelectMenuOptions, 'customId'> {
    customId: string;
    type: ExcludeEnum<typeof MessageComponentTypes, 'BUTTON' | 'ACTION_ROW'>;
    run(context: PaginatedMessageActionContext): Awaitable<unknown>;
}
/**
 * The context to be used in {@link PaginatedMessageActionButton}.
 */
interface PaginatedMessageActionContext {
    interaction: ButtonInteraction | SelectMenuInteraction;
    handler: PaginatedMessage;
    author: User;
    channel: Message['channel'];
    response: APIMessage | Message | CommandInteraction | SelectMenuInteraction | ButtonInteraction;
    collector: InteractionCollector<MessageComponentInteraction>;
}
interface PaginatedMessageOptions {
    /**
     * The pages to display in this {@link PaginatedMessage}
     */
    pages?: PaginatedMessagePage[];
    /**
     * Custom actions to provide when sending the paginated message
     */
    actions?: PaginatedMessageAction[];
    /**
     * The {@link MessageEmbed} or {@link MessageOptions} options to apply to the entire {@link PaginatedMessage}
     */
    template?: MessageEmbed | MessageOptions;
    /**
     * @seealso {@link PaginatedMessage.pageIndexPrefix}
     */
    pageIndexPrefix?: string;
    /**
     * @seealso {@link PaginatedMessage.embedFooterSeparator}
     */
    embedFooterSeparator?: string;
    /**
     * Additional options that are applied to each message when sending it to Discord.
     * Be careful with using this, misusing it can cause issues, such as sending empty messages.
     * @remark **This is for advanced usages only!**
     *
     * @default null
     */
    paginatedMessageData?: Omit<PaginatedMessageMessageOptionsUnion, 'components'> | null;
}
/**
 * The pages that are used for {@link PaginatedMessage.pages}
 *
 * Pages can be either a {@link Message},
 * or an {@link Awaitable} function that returns a {@link Message}.
 *
 * Furthermore, {@link MessageOptions} can be used to
 * construct the pages without state. This library also provides {@link MessageBuilder}, which can be used as a chainable
 * alternative to raw objects, similar to how {@link MessageEmbed}
 * works.
 *
 * Ideally, however, you should use the utility functions
 * {@link PaginatedMessage.addPageBuilder `addPageBuilder`}, {@link PaginatedMessage.addPageContent `addPageContent`}, and {@link PaginatedMessage.addPageEmbed `addPageEmbed`}
 * as opposed to manually constructing {@link PaginatedMessagePage `MessagePages`}. This is because a {@link PaginatedMessage} does a lot of post-processing
 * on the provided pages and we can only guarantee this will work properly when using the utility methods.
 */
declare type PaginatedMessagePage = ((index: number, pages: PaginatedMessagePage[], handler: PaginatedMessage) => Awaitable<PaginatedMessageMessageOptionsUnion>) | PaginatedMessageMessageOptionsUnion;
/**
 * The type of the custom function that can be set for the {@link PaginatedMessage.selectMenuOptions}
 */
declare type PaginatedMessageSelectMenuOptionsFunction = (pageIndex: number, internationalizationContext: PaginatedMessageInternationalizationContext) => Awaitable<Omit<MessageSelectOptionData, 'value'>>;
/**
 * The type of the custom function that can be set for the {@link PaginatedMessage.wrongUserInteractionReply}
 */
declare type PaginatedMessageWrongUserInteractionReplyFunction = (targetUser: User, interactionUser: User, internationalizationContext: PaginatedMessageInternationalizationContext) => Awaitable<Parameters<MessageComponentInteraction['reply']>[0]>;
declare type PaginatedMessageEmbedResolvable = MessageOptions['embeds'];
declare type PaginatedMessageMessageOptionsUnion = Omit<MessageOptions, 'flags'> | WebhookEditMessageOptions;
/**
 * @internal This is a duplicate of the same interface in `@sapphire/plugin-i18next`
 * Duplicated here for the type of the parameters in the functions
 *
 * Context for {@link InternationalizationHandler.fetchLanguage} functions.
 * This context enables implementation of per-guild, per-channel, and per-user localization.
 */
interface PaginatedMessageInternationalizationContext {
    /** The {@link Guild} object to fetch the preferred language for, or `null` if the language is to be fetched in a DM. */
    guild: Guild | null;
    /** The {@link DiscordChannel} object to fetch the preferred language for. */
    channel: Message['channel'] | StoreChannel | StageChannel | VoiceChannel | null;
    /**
     * @deprecated Use {@link InternationalizationContext.user} instead; this will be removed in the next major version.
     * The user to fetch the preferred language for.
     */
    author?: User | null;
    /** The user to fetch the preferred language for. */
    user: User | null;
    /** The {@link Interaction.guildLocale} provided by the Discord API */
    interactionGuildLocale?: Interaction['guildLocale'];
    /** The {@link Interaction.locale} provided by the Discord API */
    interactionLocale?: Interaction['locale'];
}
interface SafeReplyToInteractionParameters<T extends 'edit' | 'reply' | never = never> {
    messageOrInteraction: APIMessage | Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction;
    interactionEditReplyContent: WebhookEditMessageOptions;
    interactionReplyContent: InteractionReplyOptions;
    componentUpdateContent: InteractionUpdateOptions;
    messageMethod?: T;
    messageMethodContent?: T extends 'reply' ? ReplyMessageOptions : MessageEditOptions;
}

/**
 * This is a {@link PaginatedMessage}, a utility to paginate messages (usually embeds).
 * You must either use this class directly or extend it.
 *
 * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.
 * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.
 *
 * {@link PaginatedMessage} uses {@linkplain https://discord.js.org/#/docs/main/stable/typedef/MessageComponent MessageComponent} buttons that perform the specified action when clicked.
 * You can either use your own actions or the {@link PaginatedMessage.defaultActions}.
 * {@link PaginatedMessage.defaultActions} is also static so you can modify these directly.
 *
 * {@link PaginatedMessage} also uses pages via {@linkplain https://discord.js.org/#/docs/main/stable/class/Message Messages}.
 *
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage();
 * // Once you have an instance of PaginatedMessage you can call various methods on it to add pages to it.
 * // For more details see each method's documentation.
 *
 * myPaginatedMessage.addPageEmbed((embed) => {
 *		embed
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return embed;
 * });
 *
 * myPaginatedMessage.addPageBuilder((builder) => {
 *		const embed = new MessageEmbed()
 *			.setColor('#FF0000')
 *			.setDescription('example description');
 *
 *		return builder
 *			.setContent('example content')
 *			.setEmbeds([embed]);
 * });
 *
 * myPaginatedMessage.addPageContent('Example');
 *
 * myPaginatedMessage.run(message)
 * ```
 *
 * @remark You can also provide a MessageEmbed template. This will be applied to every page.
 * If a page itself has an embed then the two will be merged, with the content of
 * the page's embed taking priority over the template.
 *
 * Furthermore, if the template has a footer then it will be applied _after_ the page index part of the footer
 * with a space preceding the template. For example, when setting `- Powered by Sapphire Framework`
 * the resulting footer will be `1/2 - Powered by Sapphire Framework`
 * @example
 * ```typescript
 * const myPaginatedMessage = new PaginatedMessage({
 * 	template: new MessageEmbed().setColor('#FF0000').setFooter('- Powered by Sapphire framework')
 * });
 * ```
 *
 * @remark To utilize actions you can implement IPaginatedMessageAction into a class.
 * @example
 * ```typescript
 * class ForwardAction implements IPaginatedMessageAction {
 *   public id = '‚ñ∂Ô∏è';
 *
 *   public run({ handler }) {
 *     if (handler.index !== handler.pages.length - 1) ++handler.index;
 *   }
 * }
 *
 * // You can also give the object directly.
 *
 * const StopAction: IPaginatedMessageAction = {
 *   customId: 'CustomStopAction',
 *   run: ({ collector }) => {
 *     collector.stop();
 *   }
 * }
 * ```
 */
declare class PaginatedMessage {
    #private;
    /**
     * The pages to be converted to {@link PaginatedMessage.messages}
     */
    pages: PaginatedMessagePage[];
    /**
     * The response message used to edit on page changes.
     */
    response: APIMessage | Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction | null;
    /**
     * The collector used for handling component interactions.
     */
    collector: InteractionCollector<MessageComponentInteraction> | null;
    /**
     * The pages which were converted from {@link PaginatedMessage.pages}
     */
    messages: (PaginatedMessagePage | null)[];
    /**
     * The actions which are to be used.
     */
    actions: Map<string, PaginatedMessageAction>;
    /**
     * The handler's current page/message index.
     */
    index: number;
    /**
     * The amount of milliseconds to idle before the paginator is closed.
     * @default 14.5 minutes
     * @remark This is to ensure it is a bit before interactions expire.
     */
    idle: number;
    /**
     * The template for this {@link PaginatedMessage}.
     * You can use templates to set defaults that will apply to each and every page in the {@link PaginatedMessage}
     */
    template: PaginatedMessageMessageOptionsUnion;
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.pageIndexPrefix``` (static property)
     */
    pageIndexPrefix: string;
    /**
     * Custom separator to show after the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ```PaginatedMessage.embedFooterSeparator``` (static property)
     */
    embedFooterSeparator: string;
    /**
     * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
     * @default ```PaginatedMessage.stopPaginatedMessageCustomIds``` (static property)
     */
    stopPaginatedMessageCustomIds: string[];
    /**
     * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client having the `'CHANNEL'` partial.
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     *
     * @default ```PaginatedMessage.emitPartialDMChannelWarning``` (static property)
     */
    emitPartialDMChannelWarning: boolean;
    protected paginatedMessageData: Omit<PaginatedMessageMessageOptionsUnion, 'components'> | null;
    protected selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction;
    protected selectMenuPlaceholder: string | undefined;
    protected wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction;
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the maximum amount of pages in the {@link SelectMenu}.
     */
    protected hasEmittedMaxPageWarning: boolean;
    /**
     * Tracks whether a warning was already emitted for this {@link PaginatedMessage}
     * concerning the {@link PaginatedMessage} being called in a `DMChannel`
     * without the client having the `'Channel'` partial.
     *
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     */
    protected hasEmittedPartialDMChannelWarning: boolean;
    /**
     * Constructor for the {@link PaginatedMessage} class
     * @param __namedParameters The {@link PaginatedMessageOptions} for this instance of the {@link PaginatedMessage} class
     */
    constructor({ pages, actions, template, pageIndexPrefix, embedFooterSeparator, paginatedMessageData }?: PaginatedMessageOptions);
    /**
     * Sets the {@link PaginatedMessage.selectMenuOptions} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param newOptions The new options generator to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setSelectMenuOptions(newOptions: PaginatedMessageSelectMenuOptionsFunction): this;
    /**
     * Sets the {@link PaginatedMessage.selectMenuPlaceholder} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param placeholder The new placeholder to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setSelectMenuPlaceholder(placeholder: string | undefined): this;
    /**
     * Sets the {@link PaginatedMessage.wrongUserInteractionReply} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param wrongUserInteractionReply The new `wrongUserInteractionReply` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setWrongUserInteractionReply(wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction): this;
    /**
     * Sets the {@link PaginatedMessage.stopPaginatedMessageCustomIds} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param stopPaginatedMessageCustomIds The new `stopPaginatedMessageCustomIds` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setStopPaginatedMessageCustomIds(stopPaginatedMessageCustomIds: string[]): this;
    /**
     * Sets the {@link PaginatedMessage.emitPartialDMChannelWarning} for this instance of {@link PaginatedMessage}.
     * This will only apply to this one instance and no others.
     * @param emitPartialDMChannelWarning The new `emitPartialDMChannelWarning` to set
     * @returns The current instance of {@link PaginatedMessage}
     */
    setEmitPartialDMChannelWarning(emitPartialDMChannelWarning: boolean): this;
    /**
     * Sets the handler's current page/message index.
     * @param index The number to set the index to.
     */
    setIndex(index: number): this;
    /**
     * Sets the amount of time to idle before the paginator is closed.
     * @param idle The number to set the idle to.
     */
    setIdle(idle: number): this;
    /**
     * Clears all current actions and sets them. The order given is the order they will be used.
     * @param actions The actions to set. This can be either a Button, Link Button, or Select Menu.
     * @param includeDefaultActions Whether to merge in the {@link PaginatedMessage.defaultActions} when setting the actions.
     * If you set this to true then you do not need to manually add `...PaginatedMessage.defaultActions` as seen in the first example.
     * The default value is `false` for backwards compatibility within the current major version.
     *
     * @remark You can retrieve the default actions for the regular pagination
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   ...PaginatedMessage.defaultActions,
     * ])
     * ```
     *
     * @remark You can add custom Message Buttons by providing `style`, `customId`, `type`, `run` and at least one of `label` or `emoji`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     style: 'PRIMARY',
     *     label: 'My Button',
     *     customId: 'custom_button',
     *     type: Constants.MessageComponentTypes.BUTTON,
     *     run: (context) => console.log(context)
     *   }
     * ], true);
     * ```
     *
     * @remark You can add custom Message **Link** Buttons by providing `style`, `url`, `type`, and at least one of `label` or `emoji`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     style: 'LINK',
     *     label: 'Sapphire Website',
     *     emoji: 'üî∑',
     *     url: 'https://sapphirejs.dev',
     *     type: Constants.MessageComponentTypes.BUTTON
     *   }
     * ], true);
     * ```
     *
     * @remark You can add custom Select Menus by providing `customId`, `type`, and `run`.
     * @example
     * ```typescript
     * const display = new PaginatedMessage();
     *
     * display.setActions([
     *   {
     *     customId: 'custom_menu',
     *     type: Constants.MessageComponentTypes.SELECT_MENU,
     *     run: (context) => console.log(context) // Do something here
     *   }
     * ], true);
     * ```
     */
    setActions(actions: PaginatedMessageAction[], includeDefaultActions?: boolean): this;
    /**
     * Adds actions to the existing ones. The order given is the order they will be used.
     * @param actions The actions to add.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the actions.
     */
    addActions(actions: PaginatedMessageAction[]): this;
    /**
     * Adds an action to the existing ones. This will be added as the last action.
     * @param action The action to add.
     * @see {@link PaginatedMessage.setActions} for examples on how to structure the action.
     */
    addAction(action: PaginatedMessageAction): this;
    /**
     * Checks whether or not the handler has a specific page.
     * @param index The index to check.
     */
    hasPage(index: number): boolean;
    /**
     * Clears all current pages and messages and sets them. The order given is the order they will be used.
     * @param pages The pages to set.
     */
    setPages(pages: PaginatedMessagePage[]): this;
    /**
     * Adds a page to the existing ones. This will be added as the last page.
     * @remark While you can use this method you should first check out
     * {@link PaginatedMessage.addPageBuilder},
     * {@link PaginatedMessage.addPageContent} and
     * {@link PaginatedMessage.addPageEmbed} as
     * these are easier functional methods of adding pages and will likely already suffice for your needs.
     *
     * @param page The page to add.
     */
    addPage(page: PaginatedMessagePage): this;
    /**
     * Adds a page to the existing ones using a {@link MessageBuilder}. This will be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder((builder) => {
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbeds([embed]);
     * });
     * ```
     * @example
     * ```typescript
     * const { MessageEmbed } = require('discord.js');
     * const { MessageBuilder, PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const builder = new MessageBuilder()
     * 	.setContent('example content')
     * 	.setEmbeds([embed]);
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageBuilder(builder);
     * ```
     */
    addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageBuilder}. This wil be added as the last page.
     * @param builder Either a callback whose first parameter is `new MessageBuilder()`, or an already constructed {@link MessageBuilder}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     * const { MessageEmbed } = require('discord.js');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageBuilder(async (builder) => {
     * 		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		const embed = new MessageEmbed()
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return builder
     * 			.setContent('example content')
     * 			.setEmbeds([embed]);
     * });
     * ```
     */
    addAsyncPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => Promise<MessageBuilder>)): this;
    /**
     * Adds a page to the existing ones using simple message content. This will be added as the last page.
     * @param content The content to set.
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageContent('example content');
     * ```
     */
    addPageContent(content: string): this;
    /**
     * Adds a page to the existing ones using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed((embed) => {
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription('example description');
     *
     * 		return embed;
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbed(embed);
     * ```
     */
    addPageEmbed(embed: MessageEmbed | ((embed: MessageEmbed) => MessageEmbed)): this;
    /**
     * Adds a page to the existing ones asynchronously using a {@link MessageEmbed}. This wil be added as the last page.
     * @param embed Either a callback whose first parameter is `new MessageEmbed()`, or an already constructed {@link MessageEmbed}
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbed(async (embed) => {
     *		const someRemoteData = await fetch('https://contoso.com/api/users');
     *
     * 		embed
     * 			.setColor('#FF0000')
     * 			.setDescription(someRemoteData.data);
     *
     * 		return embed;
     * });
     * ```
     */
    addAsyncPageEmbed(embed: MessageEmbed | ((builder: MessageEmbed) => Promise<MessageEmbed>)): this;
    /**
     * Adds a page to the existing ones asynchronously using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds((embed1, embed2, embed3) => { // You can add up to 10 embeds
     * 		embed1
     * 			.setColor('#FF0000')
     * 			.setDescription('example description 1');
     *
     * 		embed2
     * 			.setColor('#00FF00')
     * 			.setDescription('example description 2');
     *
     * 		embed3
     * 			.setColor('#0000FF')
     * 			.setDescription('example description 3');
     *
     * 		return [embed1, embed2, embed3];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addPageEmbeds(embeds: MessageEmbed[] | ((embed1: MessageEmbed, embed2: MessageEmbed, embed3: MessageEmbed, embed4: MessageEmbed, embed5: MessageEmbed, embed6: MessageEmbed, embed7: MessageEmbed, embed8: MessageEmbed, embed9: MessageEmbed, embed10: MessageEmbed) => MessageEmbed[])): this;
    /**
     * Adds a page to the existing ones using multiple {@link MessageEmbed}'s. This wil be added as the last page.
     * @remark When using this with a callback this will construct 10 {@link MessageEmbed}'s in the callback parameters, regardless of how many are actually used.
     * If this a performance impact you do not want to cope with then it is recommended to use {@link PaginatedMessage.addPageBuilder} instead, which will let you add
     * as many embeds as you want, albeit manually
     * @param embeds Either a callback which receives 10 parameters of `new MessageEmbed()`, or an array of already constructed {@link MessageEmbed}'s
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const paginatedMessage = new PaginatedMessage().addAsyncPageEmbeds(async (embed0, embed1, embed2) => {
     * 	const someRemoteData = (await fetch('https://contoso.com/api/users')) as any;
     *
     * 	for (const [index, user] of Object.entries(someRemoteData.users.slice(0, 10)) as [`${0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10}`, any][]) {
     * 		switch (index) {
     * 			case '0': {
     * 				embed0.setColor('#FF0000').setDescription('example description 1').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '1': {
     * 				embed1.setColor('#00FF00').setDescription('example description 2').setAuthor(user.name);
     * 				break;
     * 			}
     * 			case '2': {
     * 				embed2.setColor('#0000FF').setDescription('example description 3').setAuthor(user.name);
     * 				break;
     * 			}
     * 		}
     * 	}
     *
     * 	return [embed0, embed1, embed2];
     * });
     * ```
     * @example
     * ```typescript
     * const { PaginatedMessage } = require('@sapphire/discord.js-utilities');
     *
     * const embed1 = new MessageEmbed()
     * 	.setColor('#FF0000')
     * 	.setDescription('example description 1');
     *
     * const embed2 = new MessageEmbed()
     * 	.setColor('#00FF00')
     * 	.setDescription('example description 2');
     *
     * const embed3 = new MessageEmbed()
     * 	.setColor('#0000FF')
     * 	.setDescription('example description 3');
     *
     * const paginatedMessage = new PaginatedMessage()
     * 	.addAsyncPageEmbeds([embed1, embed2, embed3]); // You can add up to 10 embeds
     * ```
     */
    addAsyncPageEmbeds(embeds: MessageEmbed[] | ((embed1: MessageEmbed, embed2: MessageEmbed, embed3: MessageEmbed, embed4: MessageEmbed, embed5: MessageEmbed, embed6: MessageEmbed, embed7: MessageEmbed, embed8: MessageEmbed, embed9: MessageEmbed, embed10: MessageEmbed) => Promise<MessageEmbed[]>)): this;
    /**
     * Add pages to the existing ones. The order given is the order they will be used.
     * @param pages The pages to add.
     */
    addPages(pages: PaginatedMessagePage[]): this;
    /**
     * Executes the {@link PaginatedMessage} and sends the pages corresponding with {@link PaginatedMessage.index}.
     * The handler will start collecting message component interactions.
     *
     * @remark Please note that for {@link PaginatedMessage} to work in DMs to your client, you need to add the `'CHANNEL'` partial to your `client.options.partials`.
     * Message based commands can always be used in DMs, whereas Chat Input interactions can only be used in DMs when they are registered globally.
     *
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message or an interaction
     * (either a {@link CommandInteraction}, a {@link ContextMenuInteraction}, a {@link SelectMenuInteraction} or a {@link ButtonInteraction}),
     * but it can also be another message from your client, i.e. to indicate a loading state.
     *
     * @param target The user who will be able to interact with the buttons of this {@link PaginatedMessage}.
     * If `messageOrInteraction` is an instance of {@link Message} then this defaults to {@link Message.author messageOrInteraction.author},
     * and if it is an instance of {@link CommandInteraction} then it defaults to {@link CommandInteraction.user messageOrInteraction.user}.
     */
    run(messageOrInteraction: Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction, target?: User): Promise<this>;
    /**
     * Executed whenever {@link PaginatedMessage.run} is called.
     */
    resolvePagesOnRun(): Promise<void>;
    /**
     * Executed whenever an action is triggered and resolved.
     * @param index The index to resolve.
     */
    resolvePage(index: number): Promise<PaginatedMessagePage>;
    /**
     * Clones the current handler into a new instance.
     */
    clone(): PaginatedMessage;
    /**
     * Sets up the message.
     *
     * @param messageOrInteraction The message or interaction that triggered this {@link PaginatedMessage}.
     * Generally this will be the command message or an interaction
     * (either a {@link CommandInteraction}, a {@link ContextMenuInteraction}, a {@link SelectMenuInteraction} or a {@link ButtonInteraction}),
     * but it can also be another message from your client, i.e. to indicate a loading state.
     *
     * @param author The author the handler is for.
     */
    protected setUpMessage(messageOrInteraction: Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction, targetUser: User): Promise<void>;
    /**
     * Sets up the message's collector.
     * @param channel The channel the handler is running at.
     * @param targetUser The user the handler is for.
     */
    protected setUpCollector(channel: TextBasedChannel, targetUser: User): void;
    /**
     * Handles the load of a page.
     * @param page The page to be loaded.
     * @param channel The channel the paginated message runs at.
     * @param index The index of the current page.
     */
    protected handlePageLoad(page: PaginatedMessagePage, index: number): Promise<PaginatedMessageMessageOptionsUnion>;
    /**
     * Handles the `collect` event from the collector.
     * @param targetUser The user the handler is for.
     * @param channel The channel the handler is running at.
     * @param interaction The button interaction that was received.
     */
    protected handleCollect(targetUser: User, channel: Message['channel'], interaction: ButtonInteraction | SelectMenuInteraction): Promise<void>;
    /**
     * Handles the `end` event from the collector.
     * @param reason The reason for which the collector was ended.
     */
    protected handleEnd(_: Collection<Snowflake, ButtonInteraction | SelectMenuInteraction>, reason: string): void;
    /**
     * Applies footer to the last embed of the page
     * @param message The message options
     * @param index The current index
     * @returns The message options with the footer applied
     */
    protected applyFooter(message: PaginatedMessageMessageOptionsUnion, index: number): PaginatedMessageMessageOptionsUnion;
    /**
     * Constructs a {@link PaginatedMessageInternationalizationContext} including a deprecation notice for {@link PaginatedMessageInternationalizationContext.author}
     * @param messageOrInteraction The message or interaction for which the {@link PaginatedMessageInternationalizationContext} should be resolved.
     * @param targetUser The target user for whom this interaction is
     * @returns A constructed {@link PaginatedMessageInternationalizationContext}
     */
    protected resolvePaginatedMessageInternationalizationContext(messageOrInteraction: Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction, targetUser: User): PaginatedMessageInternationalizationContext;
    private applyTemplate;
    private applyTemplateEmbed;
    private mergeEmbeds;
    private mergeArrays;
    /**
     * The default actions of this handler.
     */
    static defaultActions: PaginatedMessageAction[];
    /**
     * Whether to emit the warning about running a {@link PaginatedMessage} in a DM channel without the client the `'CHANNEL'` partial.
     * @remark When using message based commands (as opposed to Application Commands) then you will also need to specify the `DIRECT_MESSAGE` intent for {@link PaginatedMessage} to work.
     *
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setEmitPartialDMChannelWarning(newBoolean)`
     * @default true
     */
    static emitPartialDMChannelWarning: boolean;
    /**
     * A list of `customId` that are bound to actions that will stop the {@link PaginatedMessage}
     * @default ['@sapphire/paginated-messages.stop']
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by using `paginatedMessageInstance.setStopPaginatedMessageCustomIds(customIds)`
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.stopPaginatedMessageCustomIds = ['my-custom-stop-custom-id'];
     * ```
     */
    static stopPaginatedMessageCustomIds: string[];
    /**
     * The reasons sent by {@linkplain https://discord.js.org/#/docs/main/stable/class/InteractionCollector?scrollTo=e-end InteractionCollector#end}
     * event when the message (or its owner) has been deleted.
     */
    static deletionStopReasons: string[];
    /**
     * Custom text to show in front of the page index in the embed footer.
     * PaginatedMessage will automatically add a space (` `) after the given text. You do not have to add it yourself.
     * @default ""
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.pageIndexPrefix = 'Page';
     * // This will make the footer of the embed something like "Page 1/2"
     * ```
     */
    static pageIndexPrefix: string;
    /**
     * Custom separator for the page index in the embed footer.
     * @default "‚Ä¢"
     * @remark To overwrite this property change it somewhere in a "setup" file, i.e. where you also call `client.login()` for your client.
     * Alternatively, you can also customize it on a per-PaginatedMessage basis by passing `embedFooterSeparator` in the options of the constructor.
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.embedFooterSeparator = '|';
     * // This will make the separator of the embed footer something like "Page 1/2 | Today at 4:20"
     * ```
     */
    static embedFooterSeparator: string;
    /**
     * The messages that are currently being handled by a {@link PaginatedMessage}
     * The key is the ID of the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that only 1 {@link PaginatedMessage} can run on a specified message at once.
     * This is important when having an editable commands solution.
     */
    static readonly messages: Map<string, PaginatedMessage>;
    /**
     * The current {@link InteractionCollector} handlers that are active.
     * The key is the ID of of the author who sent the message that triggered this {@link PaginatedMessage}
     *
     * This is to ensure that any given author can only trigger 1 {@link PaginatedMessage}.
     * This is important for performance reasons, and users should not have more than 1 {@link PaginatedMessage} open at once.
     */
    static readonly handlers: Map<string, PaginatedMessage>;
    /**
     * A generator for {@link MessageSelectOption} that will be used to generate the options for the {@link MessageSelectMenu}.
     * We do not allow overwriting the {@link MessageSelectOption#value} property with this, as it is vital to how we handle
     * select menu interactions.
     *
     * @param pageIndex The index of the page to add to the {@link MessageSelectMenu}. We will add 1 to this number because our pages are 0 based,
     * so this will represent the pages as seen by the user.
     * @default
     * ```ts
     * {
     * 	label: `Page ${pageIndex}`
     * }
     * ```
     * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * PaginatedMessage.selectMenuOptions = (pageIndex) => ({
     * 	 label: `Go to page: ${pageIndex}`,
     * 	 description: 'This is a description'
     * });
     * ```
     */
    static selectMenuOptions: PaginatedMessageSelectMenuOptionsFunction;
    /**
     * A generator for {@link MessageComponentInteraction#reply} that will be called and sent whenever an untargeted user interacts with one of the buttons.
     * When modifying this it is recommended that the message is set to be ephemeral so only the user that is pressing the buttons can see them.
     * Furthermore, we also recommend setting `allowedMentions: { users: [], roles: [] }`, so you don't have to worry about accidentally pinging anyone.
     *
     * When setting just a string, we will add `{ ephemeral: true, allowedMentions: { users: [], roles: [] } }` for you.
     *
     * @param targetUser The {@link User} this {@link PaginatedMessage} was intended for.
     * @param interactionUser The {@link User} that actually clicked the button.
     * @default
     * ```ts
     * {
     * 	content: `Please stop interacting with the components on this message. They are only for ${Formatters.userMention(targetUser.id)}.`,
     * 	ephemeral: true,
     * 	allowedMentions: { users: [], roles: [] }
     * }
     * ```
     * @remark To overwrite this property change it in a "setup" file prior to calling `client.login()` for your client.
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     *
     * // We  will add ephemeral and no allowed mention for string only overwrites
     * PaginatedMessage.wrongUserInteractionReply = (targetUser) =>
     *     `These buttons are only for ${Formatters.userMention(targetUser.id)}. Press them as much as you want, but I won't do anything with your clicks.`;
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedMessage } from '@sapphire/discord.js-utilities';
     * import { Formatters } from 'discord.js';
     *
     * PaginatedMessage.wrongUserInteractionReply = (targetUser) => ({
     * 	content: `These buttons are only for ${Formatters.userMention(
     * 		targetUser.id
     * 	)}. Press them as much as you want, but I won't do anything with your clicks.`,
     * 	ephemeral: true,
     * 	allowedMentions: { users: [], roles: [] }
     * });
     * ```
     */
    static wrongUserInteractionReply: PaginatedMessageWrongUserInteractionReplyFunction;
    private static resolveTemplate;
}
interface PaginatedMessage {
    constructor: typeof PaginatedMessage;
}

/**
 * This is a LazyPaginatedMessage. Instead of resolving all pages that are functions on {@link PaginatedMessage.run} will resolve when requested.
 */
declare class LazyPaginatedMessage extends PaginatedMessage {
    /**
     * Only resolves the page corresponding with the handler's current index.
     */
    resolvePagesOnRun(): Promise<void>;
    /**
     * Resolves the page corresponding with the given index. This also resolves the index's before and after the given index.
     * @param index The index to resolve. Defaults to handler's current index.
     */
    resolvePage(index: number): Promise<PaginatedMessagePage>;
    addPageBuilder(builder: MessageBuilder | ((builder: MessageBuilder) => MessageBuilder)): this;
    addPageContent(content: string): this;
    addPageEmbed(embed: MessageEmbed | ((builder: MessageEmbed) => MessageEmbed)): this;
    addPageEmbeds(embeds: MessageEmbed[] | ((embed1: MessageEmbed, embed2: MessageEmbed, embed3: MessageEmbed, embed4: MessageEmbed, embed5: MessageEmbed, embed6: MessageEmbed, embed7: MessageEmbed, embed8: MessageEmbed, embed9: MessageEmbed, embed10: MessageEmbed) => MessageEmbed[])): this;
}

/**
 * This is a utility of {@link PaginatedMessage}, except it exclusively adds pagination inside a field of an embed.
 * You must either use this class directly or extend it.
 *
 * It differs from PaginatedMessageEmbedFields as the items here are the shape you want, and are then concatenated
 * in a single field with a given formatter function, whereas PaginatedMessageEmbedFields takes fields as the items
 * and add them to the embed.
 *
 * @example
 * ```typescript
 * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
 *
 * new PaginatedFieldMessageEmbed()
 *    .setTitleField('Test pager field')
 *    .setTemplate({ embed })
 *    .setItems([
 *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
 *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
 *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
 *     ])
 *    .formatItems((item) => `${item.title}\n${item.value}`)
 *    .setItemsPerPage(2)
 *    .make()
 *    .run(message);
 * ```
 */
declare class PaginatedFieldMessageEmbed<T> extends PaginatedMessage {
    private embedTemplate;
    private totalPages;
    private items;
    private itemsPerPage;
    private fieldTitle;
    /**
     * Set the items to paginate.
     * @param items The pages to set
     */
    setItems(items: T[]): this;
    /**
     * Set the title of the embed field that will be used to paginate the items.
     * @param title The field title
     */
    setTitleField(title: string): this;
    /**
     * Sets the amount of items that should be shown per page.
     * @param itemsPerPage The number of items
     */
    setItemsPerPage(itemsPerPage: number): this;
    /**
     * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.
     *
     * @param template MessageEmbed
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedFieldMessageEmbed().setTemplate(new MessageEmbed().setTitle('Test pager embed')).make().run(message);
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedFieldMessageEmbed().setTemplate({ title: 'Test pager embed' }).make().run(message);
     * ```
     */
    setTemplate(template: MessageEmbedOptions | MessageEmbed | ((embed: MessageEmbed) => MessageEmbed)): this;
    /**
     * Sets a format callback that will be mapped to each embed field in the array of items when the embed is paginated. This should convert each item to a format that is either text itself or can be serialized as text.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     * @param value The formatter callback to be applied to each embed item
     */
    formatItems(formatter: (item: T, index: number, array: T[]) => any): this;
    /**
     * Build the pages of the given array.
     *
     * You must call the [[PaginatedFieldMessageEmbed.make]] and [[PaginatedFieldMessageEmbed.run]] methods last, in that order, for the pagination to work.
     *
     * @example
     * ```typescript
     * import { PaginatedFieldMessageEmbed } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedFieldMessageEmbed()
     *    .setTitleField('Test field')
     *    .setTemplate({ embed })
     *    .setItems([
     *       { title: 'Sapphire Framework', value: 'discord.js Framework' },
     *       { title: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     *       { title: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     *     ])
     *    .formatItems((item) => `${item.title}\n${item.value}`)
     *    .make()
     *    .run(message);
     * ```
     */
    make(): this;
    private generatePages;
    private paginateArray;
    private resolveTemplate;
}

/**
 * This is a utility of {@link PaginatedMessage}, except it exclusively paginates the fields of an embed.
 * You must either use this class directly or extend it.
 *
 * It differs from PaginatedFieldMessageEmbed as the items here are whole fields, that are added to the embed,
 * whereas PaginatedFieldMessageEmbed concatenates the items in a single field with a given formatter function.
 *
 * @example
 * ```typescript
 * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
 *
 * new PaginatedMessageEmbedFields()
 * 	.setTemplate({ title: 'Test pager embed', color: '#006080' })
 * 	.setItems([
 * 		{ name: 'Sapphire Framework', value: 'discord.js Framework' },
 * 		{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
 * 		{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
 * 	])
 * 	.setItemsPerPage(2)
 * 	.make()
 * 	.run(message);
 * ```
 */
declare class PaginatedMessageEmbedFields extends PaginatedMessage {
    private embedTemplate;
    private totalPages;
    private items;
    private itemsPerPage;
    /**
     * Set the items to paginate.
     * @param items The pages to set
     */
    setItems(items: EmbedFieldData[]): this;
    /**
     * Sets the amount of items that should be shown per page.
     * @param itemsPerPage The number of items
     */
    setItemsPerPage(itemsPerPage: number): this;
    /**
     * Sets the template to be used to display the embed fields as pages. This template can either be set from a template {@link MessageEmbed} instance or an object with embed options.
     * All fields in the given template will be overwritten when calling {@link PaginatedMessageEmbedFields.make}.
     *
     * @param template MessageEmbed
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setTemplate(new MessageEmbed().setColor('#006080').setTitle('Test pager embed'))
     * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
     * 	.make()
     * 	.run(message);
     * ```
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     * import { MessageEmbed } from 'discord.js';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setTemplate({ title: 'Test pager embed', color: '#006080' })
     * 	.setItems([{ name: 'My field', value: 'The field\'s value' }])
     * 	.make()
     * 	.run(message);
     * ```
     */
    setTemplate(template: MessageEmbed | MessageEmbedOptions | ((embed: MessageEmbed) => MessageEmbed)): this;
    /**
     * Build the pages of the given array.
     *
     * You must call the [[PaginatedMessageEmbedFields.make]] and [[PaginatedMessageEmbedFields.run]] methods last, in that order, for the pagination to work.
     *
     * @example
     * ```typescript
     * import { PaginatedMessageEmbedFields } from '@sapphire/discord.js-utilities';
     *
     * new PaginatedMessageEmbedFields()
     * 	.setItems([
     * 		{ name: 'Sapphire Framework', value: 'discord.js Framework' },
     * 		{ name: 'Sapphire Framework 2', value: 'discord.js Framework 2' },
     * 		{ name: 'Sapphire Framework 3', value: 'discord.js Framework 3' }
     * 	])
     * 	.setItemsPerPage(3)
     * 	.make()
     * 	.run(message);
     * ```
     */
    make(): this;
    private generatePages;
    private paginateArray;
    private resolveTemplate;
}

/**
 * Checks whether the PaginatedMessage runs on an {@link CommandInteraction}, {@link ContextMenuInteraction}, {@link SelectMenuInteraction} or {@link Message}
 * @param messageOrInteraction The message or interaction that the PaginatedMessage runs on
 * @returns `true` if the PaginatedMessage runs on an an {@link CommandInteraction}, {@link ContextMenuInteraction} or {@link SelectMenuInteraction}, `false` if it runs on a {@link Message}
 */
declare function runsOnInteraction(messageOrInteraction: APIMessage | Message | CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction): messageOrInteraction is CommandInteraction | ContextMenuInteraction | SelectMenuInteraction | ButtonInteraction;
declare function actionIsButtonOrMenu(action: PaginatedMessageAction): action is PaginatedMessageActionButton | PaginatedMessageActionMenu;
declare function isMessageButtonInteraction(interaction: InteractionButtonOptions | MessageSelectMenuOptions): interaction is InteractionButtonOptions;
declare function isMessageButtonComponent(component: MessageButton | MessageSelectMenu): component is MessageButton;
declare function createPartitionedMessageRow(components: (MessageButton | MessageSelectMenu)[]): MessageActionRow[];
/**
 * Safely replies to a message or interaction. This is primarily to save duplicated code in the main `PaginatedMessage` class
 * @param parameters The parameters to create a safe reply to interaction parameters
 */
declare function safelyReplyToInteraction<T extends 'edit' | 'reply'>(parameters: SafeReplyToInteractionParameters<T>): Promise<void>;

/**
 * Checks whether a given channel is a {@link CategoryChannel}
 * @param channel The channel to check
 */
declare function isCategoryChannel(channel: ChannelTypes | Nullish): channel is CategoryChannel;
/**
 * Checks whether a given channel is a {@link DMChannel}
 * @param channel The channel to check
 */
declare function isDMChannel(channel: ChannelTypes | Nullish): channel is DMChannel | PartialDMChannel;
/**
 * Checks whether a given channel is a {@link PartialGroupDMChannel}
 * @param channel The channel to check
 */
declare function isGroupChannel(channel: Channel | PartialDMChannel | Nullish): channel is PartialGroupDMChannel;
/**
 * Checks if a channel comes from a guild.
 * @param channel The channel to check
 * @returns Whether or not the channel is guild-based.
 */
declare function isGuildBasedChannel(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes;
/**
 * Checks whether or not a channel comes from a guild.
 * @remark As opposed to {@link isGuildBasedChannel} this checks if there is `guild` property on the channel.
 * @param channel The channel to check.
 * @returns Whether or not the channel is guild-based.
 */
declare function isGuildBasedChannelByGuildKey(channel: ChannelTypes | Nullish): channel is GuildTextBasedChannelTypes;
/**
 * Checks whether a given channel is a {@link NewsChannel}.
 * @param channel The channel to check.
 */
declare function isNewsChannel(channel: ChannelTypes | Nullish): channel is NewsChannel;
/**
 * Checks whether a given channel is a {@link StoreChannel}
 * @param channel The channel to check
 * @deprecated See [Self-serve Game Selling Deprecation](https://support-dev.discord.com/hc/en-us/articles/4414590563479) for more information.
 */
declare function isStoreChannel(channel: ChannelTypes | Nullish): channel is StoreChannel;
/**
 * Checks whether a given channel is a {@link TextChannel}.
 * @param channel The channel to check.
 */
declare function isTextChannel(channel: ChannelTypes | Nullish): channel is TextChannel;
/**
 * Checks whether a given channel is a {@link VoiceChannel}
 * @param channel The channel to check
 */
declare function isVoiceChannel(channel: ChannelTypes | Nullish): channel is VoiceChannel;
/**
 * Checks whether a given channel is a {@link StageChannel}
 * @param channel The channel to check
 */
declare function isStageChannel(channel: ChannelTypes | Nullish): channel is StageChannel;
/**
 * Checks whether a given channel is a {@link ThreadChannel}
 * @param channel The channel to check.
 */
declare function isThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel;
/**
 * Checks whether a given channel is a News {@link ThreadChannel}
 * @param channel The channel to check.
 */
declare function isNewsThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel;
/**
 * Checks whether a given channel is a Public {@link ThreadChannel}
 * @param channel The channel to check.
 */
declare function isPublicThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel;
/**
 * Checks whether a given channel is a Private {@link ThreadChannel}
 * @param channel The channel to check.
 */
declare function isPrivateThreadChannel(channel: ChannelTypes | Nullish): channel is ThreadChannel;
/**
 * Checks whether a given channel is a {@link TextBasedChannelTypes}. This means it has a `send` method.
 * @param channel The channel to check.
 */
declare function isTextBasedChannel(channel: ChannelTypes | Nullish): channel is TextBasedChannelTypes;
/**
 * Checks whether a given channel is a {@link BaseGuildVoiceChannel}.
 * @param channel: The channel to check.
 */
declare function isVoiceBasedChannel(channel: Channel | Nullish): channel is BaseGuildVoiceChannel;
/**
 * Checks whether a given channel allows NSFW content or not
 * @param channel The channel to check.
 */
declare function isNsfwChannel(channel: ChannelTypes | Nullish): boolean;
/**
 * Checks whether a given message is an instance of {@link Message}, and not {@link APIMessage}
 * @param message The message to check
 * @returns `true` if the message is an instance of `Message`, false otherwise.
 */
declare function isMessageInstance(message: APIMessage | Message): message is Message;
/**
 * Checks whether a given member is an instance of {@link GuildMember}, and not {@link APIInteractionGuildMember}, {@link APIGuildMember}, or {@link Nullish}
 * @param member The member to check
 * @returns `true` if the member is an instance of `GuildMember`, false otherwise.
 */
declare function isGuildMember(member: GuildMember | APIGuildMember | APIInteractionGuildMember | Nullish): member is GuildMember;

/**
 * Determines whether or not we can read messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can read messages in the specified channel.
 */
declare function canReadMessages(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send messages in the specified channel.
 */
declare function canSendMessages(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send embeds in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send embeds in the specified channel.
 */
declare function canSendEmbeds(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send attachments in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can send attachments in the specified channel.
 */
declare function canSendAttachments(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can send react to messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can react to messages in the specified channel.
 */
declare function canReact(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether or not we can remove reactions from messages in a given channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not we can remove reactions from messages in the specified channel.
 */
declare function canRemoveAllReactions(channel: ChannelTypes | Nullish): boolean;
/**
 * Determines whether the client can join the given voice based channel.
 * @param channel The channel to test the permissions from.
 * @returns Whether or not the client can join the specified channel.
 */
declare function canJoinVoiceChannel(channel: VoiceBasedChannel | Nullish): boolean;

export { ChannelTypeString, ChannelTypes, GuildBasedChannelTypes, GuildTextBasedChannelTypes, IMessagePrompterConfirmStrategyOptions, IMessagePrompterExplicitConfirmReturn, IMessagePrompterExplicitMessageReturn, IMessagePrompterExplicitNumberReturn, IMessagePrompterExplicitReturnBase, IMessagePrompterNumberStrategyOptions, IMessagePrompterReactionStrategyOptions, IMessagePrompterStrategyOptions, LazyPaginatedMessage, MessageBuilder, MessageBuilderFileResolvable, MessageBuilderResolvable, MessagePrompter, MessagePrompterBaseStrategy, MessagePrompterChannelTypes, MessagePrompterConfirmStrategy, MessagePrompterMessage, MessagePrompterMessageStrategy, MessagePrompterNumberStrategy, MessagePrompterReactionStrategy, NonThreadGuildBasedChannelTypes, NonThreadGuildTextBasedChannelTypes, PaginatedFieldMessageEmbed, PaginatedMessage, PaginatedMessageAction, PaginatedMessageActionButton, PaginatedMessageActionContext, PaginatedMessageActionLink, PaginatedMessageActionMenu, PaginatedMessageEmbedFields, PaginatedMessageEmbedResolvable, PaginatedMessageInternationalizationContext, PaginatedMessageMessageOptionsUnion, PaginatedMessageOptions, PaginatedMessagePage, PaginatedMessageSelectMenuOptionsFunction, PaginatedMessageWrongUserInteractionReplyFunction, SafeReplyToInteractionParameters, StrategyFilters, StrategyOptions, StrategyReturns, TextBasedChannelTypes, VoiceBasedChannelTypes, actionIsButtonOrMenu, canJoinVoiceChannel, canReact, canReadMessages, canRemoveAllReactions, canSendAttachments, canSendEmbeds, canSendMessages, createPartitionedMessageRow, isCategoryChannel, isDMChannel, isGroupChannel, isGuildBasedChannel, isGuildBasedChannelByGuildKey, isGuildMember, isMessageButtonComponent, isMessageButtonInteraction, isMessageInstance, isNewsChannel, isNewsThreadChannel, isNsfwChannel, isPrivateThreadChannel, isPublicThreadChannel, isStageChannel, isStoreChannel, isTextBasedChannel, isTextChannel, isThreadChannel, isVoiceBasedChannel, isVoiceChannel, runsOnInteraction, safelyReplyToInteraction };
