"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Cron: () => Cron,
  Duration: () => Duration,
  DurationFormatter: () => DurationFormatter,
  Time: () => Time,
  TimeTypes: () => TimeTypes,
  TimerManager: () => TimerManager,
  Timestamp: () => Timestamp
});
module.exports = __toCommonJS(src_exports);

// src/lib/constants.ts
var TimeTypes = /* @__PURE__ */ ((TimeTypes2) => {
  TimeTypes2["Second"] = "second";
  TimeTypes2["Minute"] = "minute";
  TimeTypes2["Hour"] = "hour";
  TimeTypes2["Day"] = "day";
  TimeTypes2["Week"] = "week";
  TimeTypes2["Month"] = "month";
  TimeTypes2["Year"] = "year";
  return TimeTypes2;
})(TimeTypes || {});
var Time = /* @__PURE__ */ ((Time2) => {
  Time2[Time2["Millisecond"] = 1] = "Millisecond";
  Time2[Time2["Second"] = 1e3] = "Second";
  Time2[Time2["Minute"] = 6e4] = "Minute";
  Time2[Time2["Hour"] = 36e5] = "Hour";
  Time2[Time2["Day"] = 864e5] = "Day";
  Time2[Time2["Month"] = 2628e6] = "Month";
  Time2[Time2["Year"] = 31536e6] = "Year";
  return Time2;
})(Time || {});
var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var tokens = /* @__PURE__ */ new Map([
  ["Y", 4],
  ["Q", 1],
  ["M", 4],
  ["D", 4],
  ["d", 4],
  ["X", 1],
  ["x", 1],
  ["H", 2],
  ["h", 2],
  ["a", 1],
  ["A", 1],
  ["m", 2],
  ["s", 2],
  ["S", 3],
  ["Z", 2],
  ["l", 4],
  ["L", 4],
  ["T", 1],
  ["t", 1]
]);
var partRegex = /^(?:(\*)|(\d+)(?:-(\d+))?)(?:\/(\d+))?$/;
var wildcardRegex = /\bh\b|\B\?\B/g;
var allowedNum = [
  [0, 59],
  [0, 23],
  [1, 31],
  [1, 12],
  [0, 6]
];
var predefined = {
  "@annually": "0 0 1 1 *",
  "@yearly": "0 0 1 1 *",
  "@monthly": "0 0 1 * *",
  "@weekly": "0 0 * * 0",
  "@daily": "0 0 * * *",
  "@hourly": "0 * * * *"
};
var cronTokens = {
  jan: 1,
  feb: 2,
  mar: 3,
  apr: 4,
  may: 5,
  jun: 6,
  jul: 7,
  aug: 8,
  sep: 9,
  oct: 10,
  nov: 11,
  dec: 12,
  sun: 0,
  mon: 1,
  tue: 2,
  wed: 3,
  thu: 4,
  fri: 5,
  sat: 6
};
var tokensRegex = new RegExp(Object.keys(cronTokens).join("|"), "g");
var DEFAULT_UNITS = {
  ["year" /* Year */]: {
    1: "year",
    DEFAULT: "years"
  },
  ["month" /* Month */]: {
    1: "month",
    DEFAULT: "months"
  },
  ["week" /* Week */]: {
    1: "week",
    DEFAULT: "weeks"
  },
  ["day" /* Day */]: {
    1: "day",
    DEFAULT: "days"
  },
  ["hour" /* Hour */]: {
    1: "hour",
    DEFAULT: "hours"
  },
  ["minute" /* Minute */]: {
    1: "minute",
    DEFAULT: "minutes"
  },
  ["second" /* Second */]: {
    1: "second",
    DEFAULT: "seconds"
  }
};
var DEFAULT_SEPARATORS = {
  left: " ",
  right: " "
};

// src/lib/Cron.ts
var import_utilities = require("@sapphire/utilities");
var Cron = class {
  constructor(cron) {
    __publicField(this, "cron");
    __publicField(this, "normalized");
    __publicField(this, "minutes");
    __publicField(this, "hours");
    __publicField(this, "days");
    __publicField(this, "months");
    __publicField(this, "dows");
    this.cron = cron.toLowerCase();
    this.normalized = Cron.normalize(this.cron);
    [this.minutes, this.hours, this.days, this.months, this.dows] = Cron.parseString(this.normalized);
  }
  next(outset = new Date(), origin = true) {
    if (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {
      return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
    }
    if (!origin)
      return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));
    const now = new Date(outset.getTime() + 6e4);
    for (const hour of this.hours) {
      if (hour < now.getUTCHours())
        continue;
      for (const minute of this.minutes) {
        if (hour === now.getUTCHours() && minute < now.getUTCMinutes())
          continue;
        return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));
      }
    }
    return this.next(new Date(outset.getTime() + 864e5 /* Day */), false);
  }
  static normalize(cron) {
    if (Reflect.has(predefined, cron))
      return Reflect.get(predefined, cron);
    const now = new Date();
    cron = cron.split(" ").map((val, i) => val.replace(wildcardRegex, (match) => {
      if (match === "h")
        return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();
      if (match === "?") {
        switch (i) {
          case 0:
            return now.getUTCMinutes().toString();
          case 1:
            return now.getUTCHours().toString();
          case 2:
            return now.getUTCDate().toString();
          case 3:
            return now.getUTCMonth().toString();
          case 4:
            return now.getUTCDay().toString();
        }
      }
      return match;
    })).join(" ");
    return cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));
  }
  static parseString(cron) {
    const parts = cron.split(" ");
    if (parts.length !== 5)
      throw new Error("Invalid Cron Provided");
    return parts.map((part, i) => Cron.parsePart(part, i));
  }
  static parsePart(cronPart, id) {
    if (cronPart.includes(",")) {
      const res = [];
      for (const part of cronPart.split(","))
        res.push(...Cron.parsePart(part, id));
      return [...new Set(res)].sort((a, b) => a - b);
    }
    const [, wild, minStr, maxStr, step] = partRegex.exec(cronPart);
    let [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];
    if (wild)
      [min, max] = allowedNum[id];
    else if (!max && !step)
      return [min];
    [min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);
    return (0, import_utilities.range)(min, max, parseInt(step, 10) || 1);
  }
};

// src/lib/Duration.ts
var tokens2 = /* @__PURE__ */ new Map([
  ["nanosecond", 1 / 1e6],
  ["nanoseconds", 1 / 1e6],
  ["ns", 1 / 1e6],
  ["millisecond", 1],
  ["milliseconds", 1],
  ["ms", 1],
  ["second", 1e3],
  ["seconds", 1e3],
  ["sec", 1e3],
  ["secs", 1e3],
  ["s", 1e3],
  ["minute", 1e3 * 60],
  ["minutes", 1e3 * 60],
  ["min", 1e3 * 60],
  ["mins", 1e3 * 60],
  ["m", 1e3 * 60],
  ["hour", 1e3 * 60 * 60],
  ["hours", 1e3 * 60 * 60],
  ["hr", 1e3 * 60 * 60],
  ["hrs", 1e3 * 60 * 60],
  ["h", 1e3 * 60 * 60],
  ["day", 1e3 * 60 * 60 * 24],
  ["days", 1e3 * 60 * 60 * 24],
  ["d", 1e3 * 60 * 60 * 24],
  ["week", 1e3 * 60 * 60 * 24 * 7],
  ["weeks", 1e3 * 60 * 60 * 24 * 7],
  ["wk", 1e3 * 60 * 60 * 24 * 7],
  ["wks", 1e3 * 60 * 60 * 24 * 7],
  ["w", 1e3 * 60 * 60 * 24 * 7],
  ["month", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
  ["months", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
  ["b", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
  ["mo", 1e3 * 60 * 60 * 24 * (365.25 / 12)],
  ["year", 1e3 * 60 * 60 * 24 * 365.25],
  ["years", 1e3 * 60 * 60 * 24 * 365.25],
  ["yr", 1e3 * 60 * 60 * 24 * 365.25],
  ["yrs", 1e3 * 60 * 60 * 24 * 365.25],
  ["y", 1e3 * 60 * 60 * 24 * 365.25]
]);
var _Duration = class {
  constructor(pattern) {
    __publicField(this, "offset");
    this.offset = _Duration.parse(pattern.toLowerCase());
  }
  get fromNow() {
    return this.dateFrom(new Date());
  }
  dateFrom(date) {
    return new Date(date.getTime() + this.offset);
  }
  static parse(pattern) {
    let result = 0;
    let valid = false;
    pattern.replace(_Duration.kCommaRegex, "").replace(_Duration.kAanRegex, "1").replace(_Duration.kPatternRegex, (_, i, units) => {
      const token = tokens2.get(units);
      if (token !== void 0) {
        result += Number(i) * token;
        valid = true;
      }
      return "";
    });
    return valid ? result : NaN;
  }
};
var Duration = _Duration;
__publicField(Duration, "kPatternRegex", /(-?\d*\.?\d+(?:e[-+]?\d+)?)\s*([a-zÎ¼]*)/gi);
__publicField(Duration, "kCommaRegex", /,/g);
__publicField(Duration, "kAanRegex", /\ban?\b/gi);

// src/lib/DurationFormatter.ts
var kTimeDurations = [
  ["year" /* Year */, 31536e6],
  ["month" /* Month */, 2628e6],
  ["week" /* Week */, 1e3 * 60 * 60 * 24 * 7],
  ["day" /* Day */, 1e3 * 60 * 60 * 24],
  ["hour" /* Hour */, 1e3 * 60 * 60],
  ["minute" /* Minute */, 1e3 * 60],
  ["second" /* Second */, 1e3]
];
var DurationFormatter = class {
  constructor(units = DEFAULT_UNITS) {
    this.units = units;
  }
  format(duration, precision = 7, {
    left: leftSeparator = DEFAULT_SEPARATORS.left,
    right: rightSeparator = DEFAULT_SEPARATORS.right
  } = DEFAULT_SEPARATORS) {
    const output = [];
    const negative = duration < 0;
    if (negative)
      duration *= -1;
    for (const [type, timeDuration] of kTimeDurations) {
      const substraction = duration / timeDuration;
      if (substraction < 1)
        continue;
      const floored = Math.floor(substraction);
      duration -= floored * timeDuration;
      output.push(addUnit(floored, this.units[type], leftSeparator));
      if (output.length >= precision)
        break;
    }
    return `${negative ? "-" : ""}${output.join(rightSeparator) || addUnit(0, this.units.second, leftSeparator)}`;
  }
};
function addUnit(time, unit, separator) {
  if (Reflect.has(unit, time))
    return `${time}${separator}${Reflect.get(unit, time)}`;
  return `${time}${separator}${unit.DEFAULT}`;
}

// src/lib/TimerManager.ts
var TimerManager = class extends null {
  static setTimeout(fn, delay, ...args) {
    const timeout = setTimeout(() => {
      this.storedTimeouts.delete(timeout);
      fn(...args);
    }, delay);
    this.storedTimeouts.add(timeout);
    return timeout;
  }
  static clearTimeout(timeout) {
    clearTimeout(timeout);
    this.storedTimeouts.delete(timeout);
  }
  static setInterval(fn, delay, ...args) {
    const interval = setInterval(fn, delay, ...args);
    this.storedIntervals.add(interval);
    return interval;
  }
  static clearInterval(interval) {
    clearInterval(interval);
    this.storedIntervals.delete(interval);
  }
  static destroy() {
    for (const i of this.storedTimeouts)
      clearTimeout(i);
    for (const i of this.storedIntervals)
      clearInterval(i);
    this.storedTimeouts.clear();
    this.storedIntervals.clear();
  }
};
__publicField(TimerManager, "storedTimeouts", /* @__PURE__ */ new Set());
__publicField(TimerManager, "storedIntervals", /* @__PURE__ */ new Set());

// src/lib/Timestamp.ts
var tokenResolvers = /* @__PURE__ */ new Map([
  ["Y", (time) => String(time.getFullYear()).slice(2)],
  ["YY", (time) => String(time.getFullYear()).slice(2)],
  ["YYY", (time) => String(time.getFullYear())],
  ["YYYY", (time) => String(time.getFullYear())],
  ["Q", (time) => String((time.getMonth() + 1) / 3)],
  ["M", (time) => String(time.getMonth() + 1)],
  ["MM", (time) => String(time.getMonth() + 1).padStart(2, "0")],
  ["MMM", (time) => months[time.getMonth()]],
  ["MMMM", (time) => months[time.getMonth()]],
  ["D", (time) => String(time.getDate())],
  ["DD", (time) => String(time.getDate()).padStart(2, "0")],
  ["DDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
  ["DDDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
  [
    "d",
    (time) => {
      const day = String(time.getDate());
      if (day !== "11" && day.endsWith("1"))
        return `${day}st`;
      if (day !== "12" && day.endsWith("2"))
        return `${day}nd`;
      if (day !== "13" && day.endsWith("3"))
        return `${day}rd`;
      return `${day}th`;
    }
  ],
  ["dd", (time) => days[time.getDay()].slice(0, 2)],
  ["ddd", (time) => days[time.getDay()].slice(0, 3)],
  ["dddd", (time) => days[time.getDay()]],
  ["X", (time) => String(time.valueOf() / 1e3 /* Second */)],
  ["x", (time) => String(time.valueOf())],
  ["H", (time) => String(time.getHours())],
  ["HH", (time) => String(time.getHours()).padStart(2, "0")],
  ["h", (time) => String(time.getHours() % 12 || 12)],
  ["hh", (time) => String(time.getHours() % 12 || 12).padStart(2, "0")],
  ["a", (time) => time.getHours() < 12 ? "am" : "pm"],
  ["A", (time) => time.getHours() < 12 ? "AM" : "PM"],
  ["m", (time) => String(time.getMinutes())],
  ["mm", (time) => String(time.getMinutes()).padStart(2, "0")],
  ["s", (time) => String(time.getSeconds())],
  ["ss", (time) => String(time.getSeconds()).padStart(2, "0")],
  ["S", (time) => String(time.getMilliseconds())],
  ["SS", (time) => String(time.getMilliseconds()).padStart(2, "0")],
  ["SSS", (time) => String(time.getMilliseconds()).padStart(3, "0")],
  ["T", (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`],
  [
    "t",
    (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")}:${String(time.getSeconds()).padStart(2, "0")} ${time.getHours() < 12 ? "am" : "pm"}`
  ],
  ["L", (time) => `${String(time.getMonth() + 1).padStart(2, "0")}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
  ["l", (time) => `${String(time.getMonth() + 1)}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
  ["LL", (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
  ["ll", (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
  [
    "LLL",
    (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
  ],
  [
    "lll",
    (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
  ],
  [
    "LLLL",
    (time) => `${days[time.getDay()]}, ${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
  ],
  [
    "llll",
    (time) => `${days[time.getDay()].slice(0, 3)} ${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
  ],
  [
    "Z",
    (time) => {
      const offset = time.getTimezoneOffset();
      const unsigned = offset >= 0;
      const absolute = Math.abs(offset);
      return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
    }
  ],
  [
    "ZZ",
    (time) => {
      const offset = time.getTimezoneOffset();
      const unsigned = offset >= 0;
      const absolute = Math.abs(offset);
      return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
    }
  ]
]);
var Timestamp = class {
  constructor(pattern) {
    __publicField(this, "pattern");
    __publicField(this, "template");
    this.pattern = pattern;
    this.template = Timestamp.parse(pattern);
  }
  display(time = new Date()) {
    return Timestamp.display(this.template, time);
  }
  displayUTC(time) {
    return Timestamp.display(this.template, Timestamp.utc(time));
  }
  edit(pattern) {
    this.pattern = pattern;
    this.template = Timestamp.parse(pattern);
    return this;
  }
  toString() {
    return this.display();
  }
  static displayArbitrary(pattern, time = new Date()) {
    return Timestamp.display(Timestamp.parse(pattern), time);
  }
  static displayUTCArbitrary(pattern, time = new Date()) {
    return Timestamp.display(Timestamp.parse(pattern), Timestamp.utc(time));
  }
  static utc(time = new Date()) {
    time = Timestamp.resolveDate(time);
    return new Date(time.valueOf() + time.getTimezoneOffset() * 6e4);
  }
  static display(template, time) {
    let output = "";
    const parsedTime = Timestamp.resolveDate(time);
    for (const { content, type } of template)
      output += content || tokenResolvers.get(type)(parsedTime);
    return output;
  }
  static parse(pattern) {
    const template = [];
    for (let i = 0; i < pattern.length; i++) {
      let current = "";
      const currentChar = pattern[i];
      const tokenMax = tokens.get(currentChar);
      if (typeof tokenMax === "number") {
        current += currentChar;
        while (pattern[i + 1] === currentChar && current.length < tokenMax)
          current += pattern[++i];
        template.push({ type: current, content: null });
      } else if (currentChar === "[") {
        while (i + 1 < pattern.length && pattern[i + 1] !== "]")
          current += pattern[++i];
        i++;
        template.push({ type: "literal", content: current || "[" });
      } else {
        current += currentChar;
        while (i + 1 < pattern.length && !tokens.has(pattern[i + 1]) && pattern[i + 1] !== "[")
          current += pattern[++i];
        template.push({ type: "literal", content: current });
      }
    }
    return template;
  }
  static resolveDate(time) {
    return time instanceof Date ? time : new Date(time);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Cron,
  Duration,
  DurationFormatter,
  Time,
  TimeTypes,
  TimerManager,
  Timestamp
});
//# sourceMappingURL=index.js.map