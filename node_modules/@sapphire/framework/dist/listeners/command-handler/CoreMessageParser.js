"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreListener = void 0;
const discord_js_utilities_1 = require("@sapphire/discord.js-utilities");
const discord_js_1 = require("discord.js");
const Listener_1 = require("../../lib/structures/Listener");
const Events_1 = require("../../lib/types/Events");
class CoreListener extends Listener_1.Listener {
    constructor(context) {
        super(context, { event: Events_1.Events.PreMessageParsed });
        this.requiredPermissions = new discord_js_1.Permissions(['VIEW_CHANNEL', 'SEND_MESSAGES']).freeze();
    }
    async run(message) {
        // If the bot cannot run the command due to lack of permissions, return.
        const canRun = await this.canRunInChannel(message);
        if (!canRun)
            return;
        let prefix = null;
        const mentionPrefix = this.getMentionPrefix(message);
        const { client } = this.container;
        const { regexPrefix } = client.options;
        if (mentionPrefix) {
            if (message.content.length === mentionPrefix.length) {
                client.emit(Events_1.Events.MentionPrefixOnly, message);
                return;
            }
            prefix = mentionPrefix;
        }
        else if (regexPrefix?.test(message.content)) {
            prefix = regexPrefix;
        }
        else {
            const prefixes = await client.fetchPrefix(message);
            const parsed = this.getPrefix(message.content, prefixes);
            if (parsed !== null)
                prefix = parsed;
        }
        if (prefix === null)
            client.emit(Events_1.Events.NonPrefixedMessage, message);
        else
            client.emit(Events_1.Events.PrefixedMessage, message, prefix);
    }
    async canRunInChannel(message) {
        if ((0, discord_js_utilities_1.isDMChannel)(message.channel))
            return true;
        const me = message.guild.me ?? (message.client.id ? await message.guild.members.fetch(message.client.id) : null);
        if (!me)
            return false;
        if (me.isCommunicationDisabled())
            return false;
        const channel = message.channel;
        return channel.permissionsFor(me).has(this.requiredPermissions, false);
    }
    getMentionPrefix(message) {
        if (this.container.client.disableMentionPrefix)
            return null;
        // If the content is shorter than 20 characters, or does not start with `<@` then skip early:
        if (message.content.length < 20 || !message.content.startsWith('<@'))
            return null;
        // Calculate the offset and the ID that is being provided
        const [offset, id] = message.content[2] === '&'
            ? [3, message.guild?.roles.botRoleFor(message.guild.me)?.id]
            : [message.content[2] === '!' ? 3 : 2, this.container.client.id];
        if (!id)
            return null;
        // If the mention doesn't end with `>`, skip early:
        if (message.content[offset + id.length] !== '>')
            return null;
        // Check whether or not the ID is the same as the managed role ID:
        const mentionId = message.content.substr(offset, id.length);
        if (mentionId === id)
            return message.content.substr(0, offset + id.length + 1);
        return null;
    }
    getPrefix(content, prefixes) {
        if (prefixes === null)
            return null;
        const { caseInsensitivePrefixes } = this.container.client.options;
        if (caseInsensitivePrefixes)
            content = content.toLowerCase();
        if (typeof prefixes === 'string') {
            return content.startsWith(caseInsensitivePrefixes ? prefixes.toLowerCase() : prefixes) ? prefixes : null;
        }
        return prefixes.find((prefix) => content.startsWith(caseInsensitivePrefixes ? prefix.toLowerCase() : prefix)) ?? null;
    }
}
exports.CoreListener = CoreListener;
//# sourceMappingURL=CoreMessageParser.js.map