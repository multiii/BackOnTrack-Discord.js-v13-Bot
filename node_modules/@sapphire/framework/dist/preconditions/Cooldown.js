"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CorePrecondition = void 0;
const ratelimits_1 = require("@sapphire/ratelimits");
require("../lib/errors/Identifiers");
const Precondition_1 = require("../lib/structures/Precondition");
require("../lib/types/Enums");
class CorePrecondition extends Precondition_1.AllFlowsPrecondition {
    constructor() {
        super(...arguments);
        this.buckets = new WeakMap();
    }
    messageRun(message, command, context) {
        const cooldownId = this.getIdFromMessage(message, context);
        return this.sharedRun(message.author.id, command, context, cooldownId, 'message');
    }
    chatInputRun(interaction, command, context) {
        const cooldownId = this.getIdFromInteraction(interaction, context);
        return this.sharedRun(interaction.user.id, command, context, cooldownId, 'chat input');
    }
    contextMenuRun(interaction, command, context) {
        const cooldownId = this.getIdFromInteraction(interaction, context);
        return this.sharedRun(interaction.user.id, command, context, cooldownId, 'context menu');
    }
    sharedRun(authorId, command, context, cooldownId, commandType) {
        // If the command it is testing for is not this one, return ok:
        if (context.external)
            return this.ok();
        // If there is no delay (undefined, null, 0), return ok:
        if (!context.delay)
            return this.ok();
        // If the user has provided any filtered users and the authorId is in that array, return ok:
        if (context.filteredUsers?.includes(authorId))
            return this.ok();
        const ratelimit = this.getManager(command, context).acquire(cooldownId);
        if (ratelimit.limited) {
            const remaining = ratelimit.remainingTime;
            return this.error({
                identifier: "preconditionCooldown" /* Identifiers.PreconditionCooldown */,
                message: `There is a cooldown in effect for this ${commandType} command. It'll be available at ${new Date(ratelimit.expires).toISOString()}.`,
                context: { remaining }
            });
        }
        ratelimit.consume();
        return this.ok();
    }
    getIdFromMessage(message, context) {
        switch (context.scope) {
            case 1 /* BucketScope.Global */:
                return 'global';
            case 0 /* BucketScope.Channel */:
                return message.channel.id;
            case 2 /* BucketScope.Guild */:
                return message.guild?.id ?? message.channel.id;
            default:
                return message.author.id;
        }
    }
    getIdFromInteraction(interaction, context) {
        switch (context.scope) {
            case 1 /* BucketScope.Global */:
                return 'global';
            case 0 /* BucketScope.Channel */:
                return interaction.channelId;
            case 2 /* BucketScope.Guild */:
                return interaction.guildId ?? interaction.channelId;
            default:
                return interaction.user.id;
        }
    }
    getManager(command, context) {
        let manager = this.buckets.get(command);
        if (!manager) {
            manager = new ratelimits_1.RateLimitManager(context.delay, context.limit);
            this.buckets.set(command, manager);
        }
        return manager;
    }
}
exports.CorePrecondition = CorePrecondition;
//# sourceMappingURL=Cooldown.js.map