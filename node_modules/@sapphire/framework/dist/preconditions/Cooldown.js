"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CorePrecondition = void 0;
const ratelimits_1 = require("@sapphire/ratelimits");
require("../lib/errors/Identifiers");
const Precondition_1 = require("../lib/structures/Precondition");
require("../lib/types/Enums");
class CorePrecondition extends Precondition_1.Precondition {
    constructor() {
        super(...arguments);
        this.buckets = new WeakMap();
    }
    run(message, command, context) {
        // If the command it is testing for is not this one, return ok:
        if (context.external)
            return this.ok();
        // If there is no delay (undefined, null, 0), return ok:
        if (!context.delay)
            return this.ok();
        // If the user has provided any filtered users and the message author is in that array, return ok:
        if (context.filteredUsers?.includes(message.author.id))
            return this.ok();
        const ratelimit = this.getManager(command, context).acquire(this.getId(message, context));
        if (ratelimit.limited) {
            const remaining = ratelimit.remainingTime;
            return this.error({
                identifier: "preconditionCooldown" /* PreconditionCooldown */,
                message: `There is a cooldown in effect for this command. It can be used again in ${Math.ceil(remaining / 1000)} second${remaining > 1000 ? 's' : ''}.`,
                context: { remaining }
            });
        }
        ratelimit.consume();
        return this.ok();
    }
    getId(message, context) {
        switch (context.scope) {
            case 1 /* Global */:
                return 'global';
            case 0 /* Channel */:
                return message.channel.id;
            case 2 /* Guild */:
                return message.guild?.id ?? message.channel.id;
            default:
                return message.author.id;
        }
    }
    getManager(command, context) {
        let manager = this.buckets.get(command);
        if (!manager) {
            manager = new ratelimits_1.RateLimitManager(context.delay, context.limit);
            this.buckets.set(command, manager);
        }
        return manager;
    }
}
exports.CorePrecondition = CorePrecondition;
//# sourceMappingURL=Cooldown.js.map