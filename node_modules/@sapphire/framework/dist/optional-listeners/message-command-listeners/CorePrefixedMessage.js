"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreListener = void 0;
const Listener_1 = require("../../lib/structures/Listener");
const Events_1 = require("../../lib/types/Events");
class CoreListener extends Listener_1.Listener {
    constructor(context) {
        super(context, { event: Events_1.Events.PrefixedMessage });
    }
    run(message, prefix) {
        const { client, stores } = this.container;
        // Retrieve the command name and validate:
        const commandPrefix = this.getCommandPrefix(message.content, prefix);
        const prefixLess = message.content.slice(commandPrefix.length).trim();
        // The character that separates the command name from the arguments, this will return -1 when '[p]command' is
        // passed, and a non -1 value when '[p]command arg' is passed instead.
        const spaceIndex = prefixLess.indexOf(' ');
        const commandName = spaceIndex === -1 ? prefixLess : prefixLess.slice(0, spaceIndex);
        if (commandName.length === 0) {
            client.emit(Events_1.Events.UnknownMessageCommandName, { message, prefix, commandPrefix });
            return;
        }
        // Retrieve the command and validate:
        const command = stores.get('commands').get(client.options.caseInsensitiveCommands ? commandName.toLowerCase() : commandName);
        if (!command) {
            client.emit(Events_1.Events.UnknownMessageCommand, { message, prefix, commandName, commandPrefix });
            return;
        }
        // If the command exists but is missing a message handler, emit a different event (maybe an application command variant exists)
        if (!command.messageRun) {
            client.emit(Events_1.Events.CommandDoesNotHaveMessageCommandHandler, { message, prefix, commandPrefix, command });
            return;
        }
        // Run the last stage before running the command:
        const parameters = spaceIndex === -1 ? '' : prefixLess.substring(spaceIndex + 1).trim();
        client.emit(Events_1.Events.PreMessageCommandRun, {
            message,
            command: command,
            parameters,
            context: { commandName, commandPrefix, prefix }
        });
    }
    getCommandPrefix(content, prefix) {
        return typeof prefix === 'string' ? prefix : prefix.exec(content)[0];
    }
}
exports.CoreListener = CoreListener;
//# sourceMappingURL=CorePrefixedMessage.js.map