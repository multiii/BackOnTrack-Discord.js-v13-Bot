"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Listener = void 0;
const pieces_1 = require("@sapphire/pieces");
const result_1 = require("@sapphire/result");
const Events_1 = require("../types/Events");
/**
 * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In
 * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Events, Listener } from '@sapphire/framework';
 *
 * // Define a class extending `Listener`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreListener extends Listener<typeof Events.Ready> {
 *   public constructor(context: Listener.Context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   public run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Events, Listener } = require('@sapphire/framework');
 *
 * // Define a class extending `Listener`, then export it.
 * module.exports = class CoreListener extends Listener {
 *   constructor(context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 */
class Listener extends pieces_1.Piece {
    constructor(context, options = {}) {
        super(context, options);
        this.emitter =
            typeof options.emitter === 'undefined'
                ? this.container.client
                : (typeof options.emitter === 'string' ? Reflect.get(this.container.client, options.emitter) : options.emitter) ??
                    null;
        this.event = options.event ?? this.name;
        this.once = options.once ?? false;
        this._listener = this.emitter && this.event ? (this.once ? this._runOnce.bind(this) : this._run.bind(this)) : null;
        // If there's no emitter or no listener, disable:
        if (this.emitter === null || this._listener === null)
            this.enabled = false;
    }
    onLoad() {
        if (this._listener) {
            const emitter = this.emitter;
            // Increment the maximum amount of listeners by one:
            const maxListeners = emitter.getMaxListeners();
            if (maxListeners !== 0)
                emitter.setMaxListeners(maxListeners + 1);
            emitter[this.once ? 'once' : 'on'](this.event, this._listener);
        }
        return super.onLoad();
    }
    onUnload() {
        if (!this.once && this._listener) {
            const emitter = this.emitter;
            // Increment the maximum amount of listeners by one:
            const maxListeners = emitter.getMaxListeners();
            if (maxListeners !== 0)
                emitter.setMaxListeners(maxListeners - 1);
            emitter.off(this.event, this._listener);
            this._listener = null;
        }
        return super.onUnload();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            once: this.once,
            event: this.event
        };
    }
    async _run(...args) {
        // @ts-expect-error This seems to be a TS bug, so for now ts-expect-error it
        const result = await (0, result_1.fromAsync)(() => this.run(...args));
        if ((0, result_1.isErr)(result)) {
            this.container.client.emit(Events_1.Events.ListenerError, result.error, { piece: this });
        }
    }
    async _runOnce(...args) {
        await this._run(...args);
        await this.unload();
    }
}
exports.Listener = Listener;
//# sourceMappingURL=Listener.js.map