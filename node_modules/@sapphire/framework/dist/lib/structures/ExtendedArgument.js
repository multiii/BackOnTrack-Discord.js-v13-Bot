"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendedArgument = void 0;
const Result_1 = require("../parsers/Result");
const Argument_1 = require("./Argument");
/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 * Use {@link Argument} instead, and abstract the resolving of the argument data to an external resolver.
 * ---
 * The extended argument class. This class is abstract and is to be extended by subclasses which
 * will implement the {@link ExtendedArgument#handle} method.
 * Much like the {@link Argument} class, this class handles parsing user-specified command arguments
 * into typed command parameters. However, this class can be used to expand upon an existing
 * argument in order to process its transformed value rather than just the argument string.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { ApplyOptions } from '@sapphire/decorators';
 * import { ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions } from '@sapphire/framework';
 * import type { Channel, TextChannel } from 'discord.js';
 *
 * // Just like with `Argument`, you can use `export default` or `export =` too.
 * (at)ApplyOptions<ExtendedArgumentOptions>({
 *   name: 'textChannel',
 *   baseArgument: 'channel'
 * })
 * export class TextChannelArgument extends ExtendedArgument<'channel', TextChannel> {
 *   public handle(parsed: Channel, { argument }: ExtendedArgumentContext): Argument.Result<TextChannel> {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed as TextChannel)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel.' });
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { ExtendedArgument } = require('@sapphire/framework');
 *
 * module.exports = class TextChannelArgument extends ExtendedArgument {
 *   constructor(context) {
 *     super(context, { name: 'textChannel', baseArgument: 'channel' });
 *   }
 *
 *   handle(parsed, { argument }) {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel' });
 *   }
 * }
 * ```
 */
class ExtendedArgument extends Argument_1.Argument {
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    constructor(context, options) {
        super(context, options);
        this.baseArgument = options.baseArgument;
    }
    /**
     * Represents the underlying argument that transforms the raw argument
     * into the value used to compute the extended argument's value.
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    get base() {
        return this.container.stores.get('arguments').get(this.baseArgument);
    }
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    async run(parameter, context) {
        const result = await this.base.run(parameter, context);
        // If the result was successful (i.e. is of type `Ok<ArgType[K]>`), pass its
        // value to [[ExtendedArgument#handle]] for further parsing. Otherwise, return
        // the error as is; it'll provide contextual information from the base argument.
        return (0, Result_1.isOk)(result) ? this.handle(result.value, { ...context, parameter }) : result;
    }
}
exports.ExtendedArgument = ExtendedArgument;
//# sourceMappingURL=ExtendedArgument.js.map