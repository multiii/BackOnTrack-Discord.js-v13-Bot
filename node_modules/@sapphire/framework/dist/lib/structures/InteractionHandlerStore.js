"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractionHandlerFilters = exports.InteractionHandlerStore = void 0;
const pieces_1 = require("@sapphire/pieces");
const result_1 = require("@sapphire/result");
const Events_1 = require("../types/Events");
const InteractionHandler_1 = require("./InteractionHandler");
class InteractionHandlerStore extends pieces_1.Store {
    constructor() {
        super(InteractionHandler_1.InteractionHandler, { name: 'interaction-handlers' });
    }
    async run(interaction) {
        // Early-exit for optimization
        if (this.size === 0)
            return false;
        const promises = [];
        // Iterate through every registered handler
        for (const handler of this.values()) {
            const filter = exports.InteractionHandlerFilters.get(handler.interactionHandlerType);
            // If the filter is missing (we don't support it or someone didn't register it manually while waiting for us to implement it),
            // or it doesn't match the expected handler type, skip the handler
            if (!filter?.(interaction))
                continue;
            // Get the result of the `parse` method in the handler
            const result = await (0, result_1.fromAsync)(() => handler.parse(interaction));
            if ((0, result_1.isErr)(result)) {
                // If the `parse` method threw an error (spoiler: please don't), skip the handler
                this.container.client.emit(Events_1.Events.InteractionHandlerParseError, result.error, { interaction, handler });
                continue;
            }
            const finalValue = result.value;
            // If the `parse` method returned a `Some` (whatever that `Some`'s value is, it should be handled)
            if ((0, result_1.isSome)(finalValue)) {
                // Schedule the run of the handler method
                const promise = (0, result_1.fromAsync)(() => handler.run(interaction, finalValue.value)).then((res) => {
                    return (0, result_1.isErr)(res) ? (0, result_1.err)({ handler, error: res.error }) : res;
                });
                promises.push(promise);
            }
        }
        // Yet another early exit
        if (promises.length === 0)
            return false;
        const results = await Promise.allSettled(promises);
        for (const result of results) {
            const res = result.value;
            if (!(0, result_1.isErr)(res))
                continue;
            const value = res.error;
            this.container.client.emit(Events_1.Events.InteractionHandlerError, value.error, { interaction, handler: value.handler });
        }
        return true;
    }
}
exports.InteractionHandlerStore = InteractionHandlerStore;
exports.InteractionHandlerFilters = new Map([
    ["BUTTON" /* InteractionHandlerTypes.Button */, (interaction) => interaction.isButton()],
    ["SELECT_MENU" /* InteractionHandlerTypes.SelectMenu */, (interaction) => interaction.isSelectMenu()],
    ["MODAL_SUBMIT" /* InteractionHandlerTypes.ModalSubmit */, (interaction) => interaction.isModalSubmit()],
    ["MESSAGE_COMPONENT" /* InteractionHandlerTypes.MessageComponent */, (interaction) => interaction.isMessageComponent()],
    ["AUTOCOMPLETE" /* InteractionHandlerTypes.Autocomplete */, (Interaction) => Interaction.isAutocomplete()]
]);
//# sourceMappingURL=InteractionHandlerStore.js.map