"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreconditionContainerArray = exports.PreconditionRunCondition = exports.PreconditionRunMode = void 0;
const discord_js_1 = require("discord.js");
const PreconditionConditionAnd_1 = require("./conditions/PreconditionConditionAnd");
const PreconditionConditionOr_1 = require("./conditions/PreconditionConditionOr");
const PreconditionContainerSingle_1 = require("./PreconditionContainerSingle");
/**
 * The run mode for a {@link PreconditionContainerArray}.
 * @since 1.0.0
 */
var PreconditionRunMode;
(function (PreconditionRunMode) {
    /**
     * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous
     * tasks, but is performance savvy.
     * @since 1.0.0
     */
    PreconditionRunMode[PreconditionRunMode["Sequential"] = 0] = "Sequential";
    /**
     * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have
     * completed.
     * @since 1.0.0
     */
    PreconditionRunMode[PreconditionRunMode["Parallel"] = 1] = "Parallel";
})(PreconditionRunMode = exports.PreconditionRunMode || (exports.PreconditionRunMode = {}));
/**
 * The condition for a {@link PreconditionContainerArray}.
 */
var PreconditionRunCondition;
(function (PreconditionRunCondition) {
    /**
     * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.
     * @since 1.0.0
     */
    PreconditionRunCondition[PreconditionRunCondition["And"] = 0] = "And";
    /**
     * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.
     * @since 1.0.0
     */
    PreconditionRunCondition[PreconditionRunCondition["Or"] = 1] = "Or";
})(PreconditionRunCondition = exports.PreconditionRunCondition || (exports.PreconditionRunCondition = {}));
function isSingle(entry) {
    return typeof entry === 'string' || Reflect.has(entry, 'name');
}
/**
 * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.
 *
 * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level
 * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).
 *
 * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:
 * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.
 * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.
 * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.
 *
 * In other words, it is identical to doing:
 * ```typescript
 * Connect && (Moderator || (DJ && SongAuthor));
 * ```
 * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),
 * see {@link PreconditionContainerArray.conditions} for more information.
 * @since 1.0.0
 */
class PreconditionContainerArray {
    constructor(data = [], parent = null) {
        this.entries = [];
        this.runCondition = parent?.runCondition === PreconditionRunCondition.And ? PreconditionRunCondition.Or : PreconditionRunCondition.And;
        if (Array.isArray(data)) {
            const casted = data;
            this.mode = parent?.mode ?? 0 /* PreconditionRunMode.Sequential */;
            this.parse(casted);
        }
        else {
            const casted = data;
            this.mode = casted.mode;
            this.parse(casted.entries);
        }
    }
    /**
     * Adds a new entry to the array.
     * @since 1.0.0
     * @param entry The value to add to the entries.
     */
    add(entry) {
        this.entries.push(entry);
        return this;
    }
    append(entry) {
        this.entries.push(entry instanceof PreconditionContainerArray ? entry : new PreconditionContainerSingle_1.PreconditionContainerSingle(entry));
        return this;
    }
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    messageRun(message, command, context = {}) {
        return this.mode === 0 /* PreconditionRunMode.Sequential */
            ? this.condition.messageSequential(message, command, this.entries, context)
            : this.condition.messageParallel(message, command, this.entries, context);
    }
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    chatInputRun(interaction, command, context = {}) {
        return this.mode === 0 /* PreconditionRunMode.Sequential */
            ? this.condition.chatInputSequential(interaction, command, this.entries, context)
            : this.condition.chatInputParallel(interaction, command, this.entries, context);
    }
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    contextMenuRun(interaction, command, context = {}) {
        return this.mode === 0 /* PreconditionRunMode.Sequential */
            ? this.condition.contextMenuSequential(interaction, command, this.entries, context)
            : this.condition.contextMenuParallel(interaction, command, this.entries, context);
    }
    /**
     * Parses the precondition entry resolvables, and adds them to the entries.
     * @since 1.0.0
     * @param entries The entries to parse.
     */
    parse(entries) {
        for (const entry of entries) {
            this.add(isSingle(entry) //
                ? new PreconditionContainerSingle_1.PreconditionContainerSingle(entry)
                : new PreconditionContainerArray(entry, this));
        }
        return this;
    }
    /**
     * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.
     * @since 1.0.0
     */
    get condition() {
        return PreconditionContainerArray.conditions.get(this.runCondition);
    }
}
exports.PreconditionContainerArray = PreconditionContainerArray;
/**
 * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then
 * inserting {@link IPreconditionCondition}s.
 * @since 1.0.0
 * @example
 * ```typescript
 * // Adding more kinds of conditions
 *
 * // Set the new condition:
 * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);
 *
 * // Augment Sapphire to add the new condition, in case of a JavaScript
 * // project, this can be moved to an `Augments.d.ts` (or any other name)
 * // file somewhere:
 * declare module '@sapphire/framework' {
 *   export enum PreconditionRunCondition {
 *     Random = 2
 *   }
 * }
 * ```
 */
PreconditionContainerArray.conditions = new discord_js_1.Collection([
    [PreconditionRunCondition.And, PreconditionConditionAnd_1.PreconditionConditionAnd],
    [PreconditionRunCondition.Or, PreconditionConditionOr_1.PreconditionConditionOr]
]);
//# sourceMappingURL=PreconditionContainerArray.js.map