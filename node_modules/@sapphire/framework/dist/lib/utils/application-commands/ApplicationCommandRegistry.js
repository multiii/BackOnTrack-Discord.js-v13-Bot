"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationCommandRegistry = void 0;
const pieces_1 = require("@sapphire/pieces");
const v9_1 = require("discord-api-types/v9");
require("../../types/Enums");
const ApplicationCommandRegistries_1 = require("./ApplicationCommandRegistries");
const computeDifferences_1 = require("./computeDifferences");
const normalizeInputs_1 = require("./normalizeInputs");
class ApplicationCommandRegistry {
    constructor(commandName) {
        this.chatInputCommands = new Set();
        this.contextMenuCommands = new Set();
        this.apiCalls = [];
        this.commandName = commandName;
    }
    get command() {
        return pieces_1.container.stores.get('commands').get(this.commandName);
    }
    registerChatInputCommand(command, options) {
        const builtData = (0, normalizeInputs_1.normalizeChatInputCommand)(command);
        this.chatInputCommands.add(builtData.name);
        this.apiCalls.push({
            builtData,
            registerOptions: options ?? { registerCommandIfMissing: true, behaviorWhenNotIdentical: (0, ApplicationCommandRegistries_1.getDefaultBehaviorWhenNotIdentical)() },
            type: 0 /* InternalRegistryAPIType.ChatInput */
        });
        if (options?.idHints) {
            for (const hint of options.idHints) {
                this.chatInputCommands.add(hint);
            }
        }
        return this;
    }
    registerContextMenuCommand(command, options) {
        const builtData = (0, normalizeInputs_1.normalizeContextMenuCommand)(command);
        this.contextMenuCommands.add(builtData.name);
        this.apiCalls.push({
            builtData,
            registerOptions: options ?? { registerCommandIfMissing: true, behaviorWhenNotIdentical: (0, ApplicationCommandRegistries_1.getDefaultBehaviorWhenNotIdentical)() },
            type: 1 /* InternalRegistryAPIType.ContextMenu */
        });
        if (options?.idHints) {
            for (const hint of options.idHints) {
                this.contextMenuCommands.add(hint);
            }
        }
        return this;
    }
    addChatInputCommandNames(...names) {
        const flattened = names.flat(Infinity);
        for (const command of flattened) {
            this.debug(`Registering name "${command}" to internal chat input map`);
            this.warn(`Registering the chat input command "${command}" using a name is not recommended.`, 'Please use the "addChatInputCommandIds" method instead with a command id.');
            this.chatInputCommands.add(command);
        }
        return this;
    }
    addContextMenuCommandNames(...names) {
        const flattened = names.flat(Infinity);
        for (const command of flattened) {
            this.debug(`Registering name "${command}" to internal context menu map`);
            this.warn(`Registering the context menu command "${command}" using a name is not recommended.`, 'Please use the "addContextMenuCommandIds" method instead with a command id.');
            this.contextMenuCommands.add(command);
        }
        return this;
    }
    addChatInputCommandIds(...commandIds) {
        const flattened = commandIds.flat(Infinity);
        for (const entry of flattened) {
            try {
                BigInt(entry);
                this.debug(`Registering id "${entry}" to internal chat input map`);
            }
            catch {
                // Don't be silly, save yourself the headaches and do as we say
                this.debug(`Registering name "${entry}" to internal chat input map`);
                this.warn(`Registering the chat input command "${entry}" using a name *and* trying to bypass this warning by calling "addChatInputCommandIds" is not recommended.`, 'Please use the "addChatInputCommandIds" method with a valid command id instead.');
            }
            this.chatInputCommands.add(entry);
        }
        return this;
    }
    addContextMenuCommandIds(...commandIds) {
        const flattened = commandIds.flat(Infinity);
        for (const entry of flattened) {
            try {
                BigInt(entry);
                this.debug(`Registering id "${entry}" to internal context menu map`);
            }
            catch {
                this.debug(`Registering name "${entry}" to internal context menu map`);
                // Don't be silly, save yourself the headaches and do as we say
                this.warn(`Registering the context menu command "${entry}" using a name *and* trying to bypass this warning by calling "addContextMenuCommandIds" is not recommended.`, 'Please use the "addContextMenuCommandIds" method with a valid command id instead.');
            }
            this.contextMenuCommands.add(entry);
        }
        return this;
    }
    async runAPICalls(applicationCommands, globalCommands, guildCommands) {
        // Early return for no API calls
        if (this.apiCalls.length === 0) {
            const { command } = this;
            // If we have no command piece in store, then we simply return (can happen if the registry is used directly)
            if (!command) {
                this.trace('No API calls to run, and no command to register');
                return;
            }
            // If this is set to true, we expected at least one command to be registered, and this seems to usually fix it for people using TS ðŸ¤·
            // That, and we haven't had any JS users yet reporting issues with this, so we'll just leave it in for now
            if (command.chatInputCommandOptions.register) {
                this.warn('Expected command to have at least one command registered since chatInputCommandOptions.register is set to true, but none were actually registered.', "If you're using TypeScript, please try clearing the compiled code output folder, re-building your project, and restarting.");
            }
            else {
                this.trace('No API calls to run, and no command to register');
            }
            return;
        }
        this.debug(`Preparing to process ${this.apiCalls.length} possible command registrations / updates...`);
        const results = await Promise.allSettled(this.apiCalls.map((call) => this.handleAPICall(applicationCommands, globalCommands, guildCommands, call)));
        const errored = results.filter((result) => result.status === 'rejected');
        if (errored.length) {
            this.error(`Received ${errored.length} errors while processing command registrations / updates`);
            for (const error of errored) {
                this.error(error.reason.stack ?? error.reason);
            }
        }
    }
    async handleAPICall(commandsManager, globalCommands, allGuildsCommands, apiCall) {
        const { builtData, registerOptions } = apiCall;
        const commandName = builtData.name;
        const behaviorIfNotEqual = registerOptions.behaviorWhenNotIdentical ?? (0, ApplicationCommandRegistries_1.getDefaultBehaviorWhenNotIdentical)();
        const findCallback = (entry) => {
            // If the command is a chat input command, we need to check if the entry is a chat input command
            if (apiCall.type === 0 /* InternalRegistryAPIType.ChatInput */ && entry.type !== 'CHAT_INPUT')
                return false;
            // If the command is a context menu command, we need to check if the entry is a context menu command of the same type
            if (apiCall.type === 1 /* InternalRegistryAPIType.ContextMenu */) {
                if (entry.type === 'CHAT_INPUT')
                    return false;
                let apiCallType;
                switch (apiCall.builtData.type) {
                    case v9_1.ApplicationCommandType.Message:
                        apiCallType = 'MESSAGE';
                        break;
                    case v9_1.ApplicationCommandType.User:
                        apiCallType = 'USER';
                        break;
                    default:
                        throw new Error(`Unhandled context command type: ${apiCall.builtData.type}`);
                }
                if (apiCallType !== entry.type)
                    return false;
            }
            // Find the command by name or by id hint (mostly useful for context menus)
            const isInIdHint = registerOptions.idHints?.includes(entry.id);
            return typeof isInIdHint === 'boolean' ? isInIdHint || entry.name === commandName : entry.name === commandName;
        };
        let type;
        switch (apiCall.type) {
            case 0 /* InternalRegistryAPIType.ChatInput */:
                type = 'chat input';
                break;
            case 1 /* InternalRegistryAPIType.ContextMenu */:
                switch (apiCall.builtData.type) {
                    case v9_1.ApplicationCommandType.Message:
                        type = 'message context menu';
                        break;
                    case v9_1.ApplicationCommandType.User:
                        type = 'user context menu';
                        break;
                    default:
                        type = 'unknown-type context menu';
                }
                break;
            default:
                type = 'unknown';
        }
        if (!registerOptions.guildIds?.length) {
            const globalCommand = globalCommands.find(findCallback);
            if (globalCommand) {
                switch (apiCall.type) {
                    case 0 /* InternalRegistryAPIType.ChatInput */:
                        this.addChatInputCommandIds(globalCommand.id);
                        break;
                    case 1 /* InternalRegistryAPIType.ContextMenu */:
                        this.addContextMenuCommandIds(globalCommand.id);
                        break;
                }
                this.debug(`Checking if command "${commandName}" is identical with global ${type} command with id "${globalCommand.id}"`);
                await this.handleCommandPresent(globalCommand, builtData, behaviorIfNotEqual);
            }
            else if (registerOptions.registerCommandIfMissing ?? true) {
                this.debug(`Creating new global ${type} command with name "${commandName}"`);
                await this.createMissingCommand(commandsManager, builtData, type);
            }
            else {
                this.debug(`Doing nothing about missing global ${type} command with name "${commandName}"`);
            }
            return;
        }
        for (const guildId of registerOptions.guildIds) {
            const guildCommands = allGuildsCommands.get(guildId);
            if (!guildCommands) {
                this.debug(`There are no commands for guild with id "${guildId}". Will create ${type} command "${commandName}".`);
                await this.createMissingCommand(commandsManager, builtData, type, guildId);
                continue;
            }
            const existingGuildCommand = guildCommands.find(findCallback);
            if (existingGuildCommand) {
                this.debug(`Checking if guild ${type} command "${commandName}" is identical to command "${existingGuildCommand.id}"`);
                switch (apiCall.type) {
                    case 0 /* InternalRegistryAPIType.ChatInput */:
                        this.addChatInputCommandIds(existingGuildCommand.id);
                        break;
                    case 1 /* InternalRegistryAPIType.ContextMenu */:
                        this.addContextMenuCommandIds(existingGuildCommand.id);
                        break;
                }
                await this.handleCommandPresent(existingGuildCommand, builtData, behaviorIfNotEqual);
            }
            else if (registerOptions.registerCommandIfMissing ?? true) {
                this.debug(`Creating new guild ${type} command with name "${commandName}" for guild "${guildId}"`);
                await this.createMissingCommand(commandsManager, builtData, type, guildId);
            }
            else {
                this.debug(`Doing nothing about missing guild ${type} command with name "${commandName}" for guild "${guildId}"`);
            }
        }
    }
    async handleCommandPresent(applicationCommand, apiData, behaviorIfNotEqual, guildId) {
        const now = Date.now();
        // Step 0: compute differences
        const differences = (0, computeDifferences_1.getCommandDifferences)((0, normalizeInputs_1.convertApplicationCommandToApiData)(applicationCommand), apiData);
        const later = Date.now() - now;
        this.debug(`Took ${later}ms to process differences`);
        // Step 1: if there are no differences, return
        if (!differences.length) {
            this.debug(`${guildId ? 'Guild command' : 'Command'} "${apiData.name}" is identical to command "${applicationCommand.name}" (${applicationCommand.id})`);
            return;
        }
        this.logCommandDifferences(differences, applicationCommand, behaviorIfNotEqual === "LOG_TO_CONSOLE" /* RegisterBehavior.LogToConsole */);
        // Step 2: if the behavior is to log to console, log the differences
        if (behaviorIfNotEqual === "LOG_TO_CONSOLE" /* RegisterBehavior.LogToConsole */) {
            return;
        }
        // Step 3: if the behavior is to update, update the command
        try {
            await applicationCommand.edit(apiData);
            this.debug(`Updated command ${applicationCommand.name} (${applicationCommand.id}) with new api data`);
        }
        catch (error) {
            this.error(`Failed to update command ${applicationCommand.name} (${applicationCommand.id})`, error);
        }
    }
    logCommandDifferences(differences, applicationCommand, logAsWarn) {
        const finalMessage = [];
        const pad = ' '.repeat(5);
        for (const difference of differences) {
            finalMessage.push([
                `â””â”€â”€ At path: ${difference.key}`,
                `${pad}â”œâ”€â”€ Received: ${difference.original}`,
                `${pad}â””â”€â”€ Expected: ${difference.expected}`,
                ''
            ].join('\n'));
        }
        const header = `Found differences for command "${applicationCommand.name}" (${applicationCommand.id}) versus provided api data\n`;
        logAsWarn ? this.warn(header, ...finalMessage) : this.debug(header, ...finalMessage);
    }
    async createMissingCommand(commandsManager, apiData, type, guildId) {
        try {
            // TODO (favna): Replace with ts-expect-error after website rewrite is done
            // @ts-ignore Currently there's a discord-api-types version clash between builders and discord.js
            const result = await commandsManager.create(apiData, guildId);
            this.info(`Successfully created ${type}${guildId ? ' guild' : ''} command "${apiData.name}" with id "${result.id}". You should add the id to the "idHints" property of the register method you used!`);
            switch (apiData.type) {
                case undefined:
                case v9_1.ApplicationCommandType.ChatInput:
                    this.addChatInputCommandIds(result.id);
                    break;
                case v9_1.ApplicationCommandType.Message:
                case v9_1.ApplicationCommandType.User:
                    this.addContextMenuCommandIds(result.id);
                    break;
            }
        }
        catch (err) {
            this.error(`Failed to register${guildId ? ' guild' : ''} application command with name "${apiData.name}"${guildId ? ` for guild "${guildId}"` : ''}`, err);
        }
    }
    info(message, ...other) {
        pieces_1.container.logger.info(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);
    }
    error(message, ...other) {
        pieces_1.container.logger.error(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);
    }
    warn(message, ...other) {
        pieces_1.container.logger.warn(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);
    }
    debug(message, ...other) {
        pieces_1.container.logger.debug(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);
    }
    trace(message, ...other) {
        pieces_1.container.logger.trace(`ApplicationCommandRegistry[${this.commandName}] ${message}`, ...other);
    }
}
exports.ApplicationCommandRegistry = ApplicationCommandRegistry;
//# sourceMappingURL=ApplicationCommandRegistry.js.map