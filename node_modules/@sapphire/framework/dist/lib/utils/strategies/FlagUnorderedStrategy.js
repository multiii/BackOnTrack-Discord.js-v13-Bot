"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlagUnorderedStrategy = void 0;
const never = () => null;
const always = () => true;
class FlagUnorderedStrategy {
    constructor({ flags, options, prefixes = ['--', '-', 'â€”'], separators = ['=', ':'] } = {}) {
        this.flags = flags || [];
        this.options = options || [];
        this.prefixes = prefixes;
        this.separators = separators;
        if (this.flags === true)
            this.allowedFlag = always;
        else if (this.flags.length === 0)
            this.matchFlag = never;
        if (this.options === true) {
            this.allowedOption = always;
        }
        else if (this.options.length === 0) {
            this.matchOption = never;
            this.matchCompactOption = never;
        }
    }
    matchFlag(s) {
        const prefix = this.prefixes.find((p) => s.startsWith(p));
        if (!prefix)
            return null;
        s = s.slice(prefix.length);
        // Flags must not contain separators.
        if (this.separators.some((p) => s.includes(p)))
            return null;
        // The flag must be an allowed one.
        if (this.allowedFlag(s))
            return s;
        // If it did not match a flag, return null.
        return null;
    }
    matchOption(s) {
        const prefix = this.prefixes.find((p) => s.startsWith(p));
        if (!prefix)
            return null;
        s = s.slice(prefix.length);
        const separator = this.separators.find((p) => s.endsWith(p));
        if (!separator)
            return null;
        s = s.slice(0, -separator.length);
        if (this.allowedOption(s))
            return s;
        return null;
    }
    matchCompactOption(s) {
        const pre = this.prefixes.find((x) => s.startsWith(x));
        if (!pre)
            return null;
        s = s.slice(pre.length);
        const sep = this.separators.find((x) => s.includes(x));
        if (!sep)
            return null;
        const i = s.indexOf(sep);
        if (i + sep.length === s.length)
            return null;
        const k = s.slice(0, i);
        if (!this.allowedOption(k))
            return null;
        const v = s.slice(i + sep.length);
        return [k, v];
    }
    allowedFlag(s) {
        return this.flags.includes(s);
    }
    allowedOption(s) {
        return this.options.includes(s);
    }
}
exports.FlagUnorderedStrategy = FlagUnorderedStrategy;
//# sourceMappingURL=FlagUnorderedStrategy.js.map