/// <reference types="node" />
import { SlashCommandBuilder, SlashCommandSubcommandsOnlyBuilder, SlashCommandOptionsOnlyBuilder, ContextMenuCommandBuilder } from '@discordjs/builders';
import * as discord_js from 'discord.js';
import { ChatInputApplicationCommandData, UserApplicationCommandData, MessageApplicationCommandData, ApplicationCommandManager, Collection, ApplicationCommand, Message, DMChannel, Guild, CategoryChannel, NewsChannel, ThreadChannel, StageChannel, TextChannel, VoiceChannel, GuildMember, PartialDMChannel, Role, User, CommandInteraction, ContextMenuInteraction, AutocompleteInteraction, Snowflake, PermissionResolvable, Permissions, BaseCommandInteraction, TextBasedChannel, PermissionString, ClientOptions, Interaction, Client, ClientEvents } from 'discord.js';
import { AliasPiece, AliasPieceJSON, PieceContext, Piece, AliasStore, PieceOptions, PieceJSON, Store, StoreRegistry } from '@sapphire/pieces';
export { AliasPiece, AliasPieceOptions, AliasStore, LoaderError, MissingExportsError, Piece, PieceContext, PieceOptions, Store, StoreOptions, StoreRegistry, StoreRegistryEntries, container } from '@sapphire/pieces';
import { Awaitable, NonNullObject } from '@sapphire/utilities';
export { Awaitable } from '@sapphire/utilities';
import { LocalizationMap } from 'discord-api-types/v9';
import * as Lexure from 'lexure';
import { ChannelTypes, GuildBasedChannelTypes, TextBasedChannelTypes } from '@sapphire/discord.js-utilities';
import * as _sapphire_result from '@sapphire/result';
import { Result, Ok, Err, Maybe, UnwrapMaybeValue, None } from '@sapphire/result';
export * from '@sapphire/result';
import { URL } from 'url';
import { RateLimitManager } from '@sapphire/ratelimits';
import { EventEmitter } from 'events';

declare const enum CooldownLevel {
    Author = "author",
    Channel = "channel",
    Guild = "guild"
}
declare const enum PluginHook {
    PreGenericsInitialization = "preGenericsInitialization",
    PreInitialization = "preInitialization",
    PostInitialization = "postInitialization",
    PreLogin = "preLogin",
    PostLogin = "postLogin"
}
/**
 * The scope the cooldown applies to.
 */
declare const enum BucketScope {
    /**
     * Per channel cooldowns.
     */
    Channel = 0,
    /**
     * Global cooldowns.
     */
    Global = 1,
    /**
     * Per guild cooldowns.
     */
    Guild = 2,
    /**
     * Per user cooldowns.
     */
    User = 3
}
declare const enum RegisterBehavior {
    Overwrite = "OVERWRITE",
    LogToConsole = "LOG_TO_CONSOLE"
}
declare const enum InternalRegistryAPIType {
    ChatInput = 0,
    ContextMenu = 1
}

declare class ApplicationCommandRegistry {
    readonly commandName: string;
    readonly chatInputCommands: Set<string>;
    readonly contextMenuCommands: Set<string>;
    private readonly apiCalls;
    constructor(commandName: string);
    get command(): Command<Args, CommandOptions> | undefined;
    registerChatInputCommand(command: ChatInputApplicationCommandData | SlashCommandBuilder | SlashCommandSubcommandsOnlyBuilder | SlashCommandOptionsOnlyBuilder | Omit<SlashCommandBuilder, 'addSubcommand' | 'addSubcommandGroup'> | ((builder: SlashCommandBuilder) => unknown), options?: ApplicationCommandRegistryRegisterOptions): this;
    registerContextMenuCommand(command: UserApplicationCommandData | MessageApplicationCommandData | ContextMenuCommandBuilder | ((builder: ContextMenuCommandBuilder) => unknown), options?: ApplicationCommandRegistryRegisterOptions): this;
    addChatInputCommandNames(...names: string[] | string[][]): this;
    addContextMenuCommandNames(...names: string[] | string[][]): this;
    addChatInputCommandIds(...commandIds: string[] | string[][]): this;
    addContextMenuCommandIds(...commandIds: string[] | string[][]): this;
    protected runAPICalls(applicationCommands: ApplicationCommandManager, globalCommands: Collection<string, ApplicationCommand>, guildCommands: Map<string, Collection<string, ApplicationCommand>>): Promise<void>;
    private handleAPICall;
    private handleCommandPresent;
    private logCommandDifferences;
    private createMissingCommand;
    private info;
    private error;
    private warn;
    private debug;
    private trace;
}
declare namespace ApplicationCommandRegistry {
    interface RegisterOptions {
        /**
         * If this is specified, the application commands will only be registered for these guild ids.
         */
        guildIds?: string[];
        /**
         * If we should register the command when it is missing
         * @default true
         */
        registerCommandIfMissing?: boolean;
        /**
         * Specifies what we should do when the command is present, but not identical with the data you provided
         * @default `ApplicationCommandRegistries.getDefaultBehaviorWhenNotIdentical()`
         */
        behaviorWhenNotIdentical?: RegisterBehavior;
        /**
         * Specifies a list of command ids that we should check in the event of a name mismatch
         * @default []
         */
        idHints?: string[];
    }
}
declare type ApplicationCommandRegistryRegisterOptions = ApplicationCommandRegistry.RegisterOptions;

/**
 * Acquires a registry for a command by its name.
 * @param commandName The name of the command.
 * @returns The application command registry for the command
 */
declare function acquire(commandName: string): ApplicationCommandRegistry;
/**
 * Sets the default behavior when registered commands aren't identical to provided data.
 * @param behavior The default behavior to have. Set this to `null` to reset it to the default
 * of `RegisterBehavior.LogToConsole`.
 */
declare function setDefaultBehaviorWhenNotIdentical(behavior?: RegisterBehavior | null): void;
declare function getDefaultBehaviorWhenNotIdentical(): RegisterBehavior;

/**
 * The UserError class to be emitted in the pieces.
 * @property name This will be `'UserError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class UserError extends Error {
    /**
     * An identifier, useful to localize emitted errors.
     */
    readonly identifier: string;
    /**
     * User-provided context.
     */
    readonly context: unknown;
    /**
     * Constructs an UserError.
     * @param type The identifier, useful to localize emitted errors.
     * @param message The error message.
     */
    constructor(options: UserError.Options);
    get name(): string;
}
declare namespace UserError {
    /**
     * The options for {@link UserError}.
     * @since 1.0.0
     */
    interface Options {
        /**
         * The identifier for this error.
         * @since 1.0.0
         */
        identifier: string;
        /**
         * The message to be passed to the Error constructor.
         * @since 1.0.0
         */
        message?: string;
        /**
         * The extra context to provide more information about this error.
         * @since 1.0.0
         * @default null
         */
        context?: unknown;
    }
}

/**
 * Defines a synchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.
 */
declare type ArgumentResult<T> = Awaitable<Result<T, UserError>>;
/**
 * Defines an asynchronous result of an {@link Argument}, check {@link Argument.Result} for the synchronous version.
 */
declare type AsyncArgumentResult<T> = Promise<Result<T, UserError>>;
interface IArgument<T> {
    /**
     * The name of the argument, this is used to make the identification of an argument easier.
     */
    readonly name: string;
    /**
     * The method which is called when invoking the argument.
     * @param parameter The string parameter to parse.
     * @param context The context for the method call, contains the message, command, and other options.
     */
    run(parameter: string, context: Argument.Context<T>): Argument.Result<T>;
}
interface ArgumentOptions extends AliasPiece.Options {
}
interface ArgumentContext<T = unknown> extends Record<PropertyKey, unknown> {
    argument: IArgument<T>;
    args: Args;
    message: Message;
    command: MessageCommand;
    commandContext: MessageCommand.RunContext;
    minimum?: number;
    maximum?: number;
    inclusive?: boolean;
}
/**
 * The base argument class. This class is abstract and is to be extended by subclasses implementing the methods. In
 * Sapphire's workflow, arguments are called when using {@link Args}'s methods (usually used inside {@link Command}s by default).
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Argument, PieceContext } from '@sapphire/framework';
 * import { URL } from 'url';
 *
 * // Define a class extending `Argument`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreArgument extends Argument<URL> {
 *   public constructor(context: PieceContext) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   public run(argument: string): Argument.Result<URL> {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error(argument, 'ArgumentHyperlinkInvalidURL', 'The argument did not resolve to a valid URL.');
 *     }
 *   }
 * }
 *
 * // Augment the ArgType structure so `args.pick('url')`, `args.repeat('url')`
 * // and others have a return type of `URL`.
 * declare module '@sapphire/framework' {
 *   export interface ArgType {
 *     url: URL;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Argument } = require('@sapphire/framework');
 *
 * // Define a class extending `Argument`, then export it.
 * module.exports = class CoreArgument extends Argument {
 *   constructor(context) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   run(argument) {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error(argument, 'ArgumentHyperlinkInvalidURL', 'The argument did not resolve to a valid URL.');
 *     }
 *   }
 * }
 * ```
 */
declare abstract class Argument<T = unknown, O extends Argument.Options = Argument.Options> extends AliasPiece<O> implements IArgument<T> {
    abstract run(parameter: string, context: Argument.Context<T>): Argument.Result<T>;
    /**
     * Wraps a value into a successful value.
     * @param value The value to wrap.
     */
    ok(value: T): Argument.Result<T>;
    /**
     * Constructs an {@link ArgumentError} with a custom type.
     * @param parameter The parameter that triggered the argument.
     * @param type The identifier for the error.
     * @param message The description message for the rejection.
     */
    error(options: Omit<ArgumentError.Options<T>, 'argument'>): Argument.Result<T>;
}
declare namespace Argument {
    type Options = ArgumentOptions;
    type Context<T = unknown> = ArgumentContext<T>;
    type Result<T> = ArgumentResult<T>;
    type AsyncResult<T> = AsyncArgumentResult<T>;
}

/**
 * Errors thrown by the argument parser
 * @since 1.0.0
 * @property name This will be `'ArgumentError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class ArgumentError<T = unknown> extends UserError {
    readonly argument: IArgument<T>;
    readonly parameter: string;
    constructor(options: ArgumentError.Options<T>);
    get name(): string;
}
declare namespace ArgumentError {
    /**
     * The options for {@link ArgumentError}.
     * @since 1.0.0
     */
    interface Options<T> extends Omit<UserError.Options, 'identifier'> {
        /**
         * The argument that caused the error.
         * @since 1.0.0
         */
        argument: IArgument<T>;
        /**
         * The parameter that failed to be parsed.
         * @since 1.0.0
         */
        parameter: string;
        /**
         * The identifier.
         * @since 1.0.0
         * @default argument.name
         */
        identifier?: string;
    }
}

declare const enum Identifiers {
    ArgsMissing = "argsMissing",
    ArgsUnavailable = "argsUnavailable",
    ArgumentBooleanError = "booleanError",
    ArgumentChannelError = "channelError",
    ArgumentDateError = "dateError",
    ArgumentDateTooEarly = "dateTooEarly",
    ArgumentDateTooFar = "dateTooFar",
    ArgumentDMChannelError = "dmChannelError",
    ArgumentEmojiError = "emojiError",
    ArgumentFloatError = "floatError",
    ArgumentFloatTooLarge = "floatTooLarge",
    ArgumentFloatTooSmall = "floatTooSmall",
    ArgumentGuildCategoryChannelError = "categoryChannelError",
    ArgumentGuildChannelError = "guildChannelError",
    ArgumentGuildChannelMissingGuildError = "guildChannelMissingGuildError",
    ArgumentGuildNewsChannelError = "guildNewsChannelError",
    ArgumentGuildNewsThreadChannelError = "guildNewsChannelError",
    ArgumentGuildPrivateThreadChannelError = "guildPrivateThreadChannelError",
    ArgumentGuildPublicThreadChannelError = "guildPublicThreadChannelError",
    ArgumentGuildStageVoiceChannelError = "guildStageVoiceChannelError",
    ArgumentGuildTextChannelError = "guildTextChannelError",
    ArgumentGuildThreadChannelError = "guildThreadChannelError",
    ArgumentGuildVoiceChannelError = "guildVoiceChannelError",
    ArgumentHyperlinkError = "hyperlinkError",
    ArgumentIntegerError = "integerError",
    ArgumentIntegerTooLarge = "integerTooLarge",
    ArgumentIntegerTooSmall = "integerTooSmall",
    ArgumentMemberError = "memberError",
    ArgumentMemberMissingGuild = "memberMissingGuild",
    ArgumentMessageError = "messageError",
    ArgumentNumberError = "numberError",
    ArgumentNumberTooLarge = "numberTooLarge",
    ArgumentNumberTooSmall = "numberTooSmall",
    ArgumentRoleError = "roleError",
    ArgumentRoleMissingGuild = "roleMissingGuild",
    ArgumentStringTooLong = "stringTooLong",
    ArgumentStringTooShort = "stringTooShort",
    ArgumentUserError = "userError",
    ArgumentEnumEmptyError = "enumEmptyError",
    ArgumentEnumError = "enumError",
    CommandDisabled = "commandDisabled",
    PreconditionCooldown = "preconditionCooldown",
    PreconditionDMOnly = "preconditionDmOnly",
    PreconditionGuildNewsOnly = "preconditionGuildNewsOnly",
    PreconditionGuildNewsThreadOnly = "preconditionGuildNewsThreadOnly",
    PreconditionGuildOnly = "preconditionGuildOnly",
    PreconditionGuildPrivateThreadOnly = "preconditionGuildPrivateThreadOnly",
    PreconditionGuildPublicThreadOnly = "preconditionGuildPublicThreadOnly",
    PreconditionGuildTextOnly = "preconditionGuildTextOnly",
    PreconditionNSFW = "preconditionNsfw",
    PreconditionClientPermissions = "preconditionClientPermissions",
    PreconditionClientPermissionsNoClient = "preconditionClientPermissionsNoClient",
    PreconditionClientPermissionsNoPermissions = "preconditionClientPermissionsNoPermissions",
    PreconditionUserPermissions = "preconditionUserPermissions",
    PreconditionUserPermissionsNoPermissions = "preconditionUserPermissionsNoPermissions",
    PreconditionThreadOnly = "preconditionThreadOnly",
    PreconditionMissingMessageHandler = "preconditionMissingMessageHandler",
    PreconditionMissingChatInputHandler = "preconditionMissingChatInputHandler",
    PreconditionMissingContextMenuHandler = "preconditionMissingContextMenuHandler"
}

declare function resolveBoolean(parameter: string, customs?: {
    truths?: readonly string[];
    falses?: readonly string[];
}): Result<boolean, Identifiers.ArgumentBooleanError>;

declare function resolveChannel(parameter: string, message: Message): Result<ChannelTypes, Identifiers.ArgumentChannelError>;

declare function resolveDate(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<Date, Identifiers.ArgumentDateError | Identifiers.ArgumentDateTooEarly | Identifiers.ArgumentDateTooFar>;

declare function resolveDMChannel(parameter: string, message: Message): Result<DMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveEmoji(parameter: string): Ok<EmojiObject> | Err<Identifiers>;
interface EmojiObject {
    name: string | null;
    id: string | null;
    animated?: boolean;
}

declare function resolveEnum(parameter: string, options?: {
    enum?: string[];
    caseInsensitive?: boolean;
}): Result<string, Identifiers.ArgumentEnumEmptyError | Identifiers.ArgumentEnumError>;

declare function resolveFloat(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentFloatError | Identifiers.ArgumentFloatTooSmall | Identifiers.ArgumentFloatTooLarge>;

declare function resolveGuildCategoryChannel(parameter: string, guild: Guild): Result<CategoryChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildCategoryChannelError>;

declare function resolveGuildChannel(parameter: string, guild: Guild): Result<GuildBasedChannelTypes, Identifiers.ArgumentGuildChannelError>;

declare function resolveGuildNewsChannel(parameter: string, guild: Guild): Result<NewsChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildNewsChannelError>;

declare function resolveGuildNewsThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildNewsThreadChannelError>;

declare function resolveGuildPrivateThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPrivateThreadChannelError>;

declare function resolveGuildPublicThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPublicThreadChannelError>;

declare function resolveGuildStageVoiceChannel(parameter: string, guild: Guild): Result<StageChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildStageVoiceChannelError>;

declare function resolveGuildTextChannel(parameter: string, guild: Guild): Result<TextChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildTextChannelError>;

declare function resolveGuildThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError>;

declare function resolveGuildVoiceChannel(parameter: string, guild: Guild): Result<VoiceChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildVoiceChannelError>;

declare function resolveHyperlink(parameter: string): Result<URL, Identifiers.ArgumentHyperlinkError>;

declare function resolveInteger(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentIntegerError | Identifiers.ArgumentIntegerTooSmall | Identifiers.ArgumentIntegerTooLarge>;

declare function resolveMember(parameter: string, guild: Guild): Promise<Result<GuildMember, Identifiers.ArgumentMemberError>>;

interface MessageResolverOptions {
    channel?: TextBasedChannelTypes;
    message: Message;
}
declare function resolveMessage(parameter: string, options: MessageResolverOptions): Promise<Result<Message, Identifiers.ArgumentMessageError>>;

declare function resolveNumber(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentNumberError | Identifiers.ArgumentNumberTooSmall | Identifiers.ArgumentNumberTooLarge>;

declare function resolvePartialDMChannel(parameter: string, message: Message): Result<DMChannel | PartialDMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveRole(parameter: string, guild: Guild): Promise<Result<Role, Identifiers.ArgumentRoleError>>;

declare function resolveString(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<string, Identifiers.ArgumentStringTooShort | Identifiers.ArgumentStringTooLong>;

declare function resolveUser(parameter: string): Promise<Result<User, Identifiers.ArgumentUserError>>;

//# sourceMappingURL=index.d.ts.map

declare const index_d_resolveBoolean: typeof resolveBoolean;
declare const index_d_resolveChannel: typeof resolveChannel;
declare const index_d_resolveDate: typeof resolveDate;
declare const index_d_resolveDMChannel: typeof resolveDMChannel;
declare const index_d_resolveEmoji: typeof resolveEmoji;
type index_d_EmojiObject = EmojiObject;
declare const index_d_resolveEnum: typeof resolveEnum;
declare const index_d_resolveFloat: typeof resolveFloat;
declare const index_d_resolveGuildCategoryChannel: typeof resolveGuildCategoryChannel;
declare const index_d_resolveGuildChannel: typeof resolveGuildChannel;
declare const index_d_resolveGuildNewsChannel: typeof resolveGuildNewsChannel;
declare const index_d_resolveGuildNewsThreadChannel: typeof resolveGuildNewsThreadChannel;
declare const index_d_resolveGuildPrivateThreadChannel: typeof resolveGuildPrivateThreadChannel;
declare const index_d_resolveGuildPublicThreadChannel: typeof resolveGuildPublicThreadChannel;
declare const index_d_resolveGuildStageVoiceChannel: typeof resolveGuildStageVoiceChannel;
declare const index_d_resolveGuildTextChannel: typeof resolveGuildTextChannel;
declare const index_d_resolveGuildThreadChannel: typeof resolveGuildThreadChannel;
declare const index_d_resolveGuildVoiceChannel: typeof resolveGuildVoiceChannel;
declare const index_d_resolveHyperlink: typeof resolveHyperlink;
declare const index_d_resolveInteger: typeof resolveInteger;
declare const index_d_resolveMember: typeof resolveMember;
declare const index_d_resolveMessage: typeof resolveMessage;
declare const index_d_resolveNumber: typeof resolveNumber;
declare const index_d_resolvePartialDMChannel: typeof resolvePartialDMChannel;
declare const index_d_resolveRole: typeof resolveRole;
declare const index_d_resolveString: typeof resolveString;
declare const index_d_resolveUser: typeof resolveUser;
declare namespace index_d {
  export {
    index_d_resolveBoolean as resolveBoolean,
    index_d_resolveChannel as resolveChannel,
    index_d_resolveDate as resolveDate,
    index_d_resolveDMChannel as resolveDMChannel,
    index_d_resolveEmoji as resolveEmoji,
    index_d_EmojiObject as EmojiObject,
    index_d_resolveEnum as resolveEnum,
    index_d_resolveFloat as resolveFloat,
    index_d_resolveGuildCategoryChannel as resolveGuildCategoryChannel,
    index_d_resolveGuildChannel as resolveGuildChannel,
    index_d_resolveGuildNewsChannel as resolveGuildNewsChannel,
    index_d_resolveGuildNewsThreadChannel as resolveGuildNewsThreadChannel,
    index_d_resolveGuildPrivateThreadChannel as resolveGuildPrivateThreadChannel,
    index_d_resolveGuildPublicThreadChannel as resolveGuildPublicThreadChannel,
    index_d_resolveGuildStageVoiceChannel as resolveGuildStageVoiceChannel,
    index_d_resolveGuildTextChannel as resolveGuildTextChannel,
    index_d_resolveGuildThreadChannel as resolveGuildThreadChannel,
    index_d_resolveGuildVoiceChannel as resolveGuildVoiceChannel,
    index_d_resolveHyperlink as resolveHyperlink,
    index_d_resolveInteger as resolveInteger,
    index_d_resolveMember as resolveMember,
    index_d_resolveMessage as resolveMessage,
    index_d_resolveNumber as resolveNumber,
    index_d_resolvePartialDMChannel as resolvePartialDMChannel,
    index_d_resolveRole as resolveRole,
    index_d_resolveString as resolveString,
    index_d_resolveUser as resolveUser,
  };
}

/**
 * The argument parser to be used in {@link Command}.
 */
declare class Args {
    /**
     * The original message that triggered the command.
     */
    readonly message: Message;
    /**
     * The command that is being run.
     */
    readonly command: MessageCommand;
    /**
     * The context of the command being run.
     */
    readonly commandContext: MessageCommand.RunContext;
    /**
     * The internal Lexure parser.
     */
    protected readonly parser: Lexure.Args;
    /**
     * The states stored in the args.
     * @see Args#save
     * @see Args#restore
     */
    private readonly states;
    constructor(message: Message, command: MessageCommand, parser: Lexure.Args, context: MessageCommand.RunContext);
    /**
     * Sets the parser to the first token.
     */
    start(): Args;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((arg) => {
     *   const parsed = Number(argument);
     *   if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));
     *   return ok(parsed);
     * });
     * const a = await args.pickResult(resolver);
     * if (!a.success) throw new UserError('ArgumentNumberNaN', 'You must write a valid number.');
     *
     * await message.channel.send(`The result is: ${a.value ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pickResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the first one did not match.');
     *
     * const b = await args.pickResult('integer');
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the second one did not match.');
     *
     * await message.channel.send(`The result is: ${a.value + b.value}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pickResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((arg) => {
     *   const parsed = Number(argument);
     *   if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));
     *   return ok(parsed);
     * });
     * const a = await args.pick(resolver);
     *
     * await message.channel.send(`The result is: ${a ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pick<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pick('integer');
     * const b = await args.pick('integer');
     * await message.channel.send(`The result is: ${a + b}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pick<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const a = await args.restResult(resolver);
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write some text.');
     *
     * await message.channel.send(`The reversed value is... ${a.value}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    restResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the former did not match.');
     *
     * const b = await args.restResult('string', { minimum: 1 });
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the latter did not match.');
     *
     * await message.channel.send(`The repeated value is... ${b.value.repeat(a.value)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    restResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const a = await args.rest(resolver);
     * await message.channel.send(`The reversed value is... ${a}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    rest<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pick('integer');
     * const b = await args.rest('string', { minimum: 1 });
     * await message.channel.send(`The repeated value is... ${b.repeat(a)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    rest<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const result = await args.repeatResult(resolver, { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): olleH !dlroW"
     * ```
     */
    repeatResult<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<Result<T[], UserError>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const result = await args.repeatResult('string', { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeatResult<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<Result<ArgType[K][], UserError>>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const result = await args.repeat(resolver, { times: 5 });
     * await message.channel.send(`You have written ${result.length} word(s): ${result.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<T[]>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const words = await args.repeat('string', { times: 5 });
     * await message.channel.send(`You have written ${words.length} word(s): ${words.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<ArgType[K][]>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !reversedandscreamfirst hello world
     * const resolver = Args.make((arg) => ok(arg.split('').reverse().join('')));
     *
     * const result = await args.peekResult(() => args.repeatResult(resolver));
     * if (isOk(result)) await message.channel.send(
     *   `Reversed ${result.value.length} word(s): ${result.value.join(' ')}`
     * ); // Reversed 2 word(s): olleh dlrow
     *
     * const firstWord = await args.pickResult('string');
     * if (isOk(firstWord)) await message.channel.send(firstWord.value.toUpperCase()); // HELLO
     * ```
     */
    peekResult<T>(type: () => Argument.Result<T>): Promise<Result<T, UserError>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !reverseandscreamfirst sapphire community
     * const resolver = Args.make((arg) => ok(arg.split('').reverse().join('')));
     *
     * const peekedWord = await args.peekResult(resolver);
     * if (isOk(peekedWord)) await message.channel.send(peekedWord.value); // erihppas
     *
     * const firstWord = await args.pickResult('string');
     * if (isOk(firstWord)) await message.channel.send(firstWord.value.toUpperCase()); // SAPPHIRE
     * ```
     */
    peekResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !datethenaddtwo 1608867472611
     * const date = await args.peekResult('date');
     * if (isOk(date)) await message.channel.send(
     *   `Your date (in UTC): ${date.value.toUTCString()}`
     * ); // Your date (in UTC): Fri, 25 Dec 2020 03:37:52 GMT
     *
     * const result = await args.pickResult('number', { maximum: Number.MAX_SAFE_INTEGER - 2 });
     * if (isOk(result)) await message.channel.send(`Your number plus two: ${result.value + 2}`); // Your number plus two: 1608867472613
     * ```
     */
    peekResult<K extends keyof ArgType>(type: (() => Argument.Result<ArgType[K]>) | K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !bigintsumthensquarefirst 25 50 75
     * const resolver = Args.make((arg) => {
     *   try {
     *     return ok(BigInt(arg));
     *   } catch {
     *     return err(new UserError('InvalidBigInt', 'You must specify a valid number for a bigint.'));
     *   }
     * });
     *
     * const peeked = await args.peek(() => args.repeatResult(resolver));
     * await message.channel.send(`Sum: **${peeked.reduce((x, y) => x + y, 0)}**`); // Sum: 150
     *
     * const first = await args.pick(resolver);
     * await message.channel.send(`First bigint squared: ${first**2n}`); // First bigint squared: 625
     * ```
     */
    peek<T>(type: () => Argument.Result<T>): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !createdat 730159185517477900
     * const snowflakeResolver = Args.make((arg) =>
     * 	 SnowflakeRegex.test(arg) ? ok(BigInt(arg)) : err(new UserError('InvalidSnowflake', 'You must specify a valid snowflake.'));
     * );
     *
     * const snowflake = await args.peek(snowflakeResolver);
     * const timestamp = Number((snowflake >> 22n) + DiscordSnowflake.Epoch);
     * const createdAt = new Date(timestamp);
     *
     * await message.channel.send(
     *   `The snowflake ${snowflake} was registered on ${createdAt.toUTCString()}.`
     * ); // The snowflake 730159185517477900 was registered on Tue, 07 Jul 2020 20:31:55 GMT.
     *
     * const id = await args.pick('string');
     * await message.channel.send(`Your ID, reversed: ${id.split('').reverse().join('')}`); // Your ID, reversed: 009774715581951037
     * ```
     */
    peek<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !messagelink https://discord.com/channels/737141877803057244/737142209639350343/791843123898089483
     * const remoteMessage = await args.peek('message');
     * await message.channel.send(
     *   `${remoteMessage.author.tag}: ${remoteMessage.content}`
     * ); // RealShadowNova#7462: Yeah, Sapphire has been a great experience so far, especially being able to help and contribute.
     *
     * const url = await args.pick('hyperlink');
     * await message.channel.send(`Hostname: ${url.hostname}`); // Hostname: discord.com
     * ```
     */
    peek<K extends keyof ArgType>(type: (() => Argument.Result<ArgType[K]>) | K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves the next raw argument from the parser.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.nextMaybe());
     * // -> { exists: true, value: '1' }
     * ```
     */
    nextMaybe(): Maybe<string>;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be consider used if the transformation succeeds.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> { exists: true, value: 1 }
     * ```
     */
    nextMaybe<T>(cb: ArgsNextCallback<T>): Maybe<T>;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.next());
     * // -> '1'
     * ```
     */
    next(): string;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> 1
     * ```
     */
    next<T>(cb: ArgsNextCallback<T>): T;
    /**
     * Checks if one or more flag were given.
     * @param keys The name(s) of the flag.
     * @example
     * ```typescript
     * // Suppose args are from '--f --g'.
     * console.log(args.getFlags('f'));
     * // >>> true
     *
     * console.log(args.getFlags('g', 'h'));
     * // >>> true
     *
     * console.log(args.getFlags('h'));
     * // >>> false
     * ```
     */
    getFlags(...keys: readonly string[]): boolean;
    /**
     * Gets the last value of one or more options.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOption('a'));
     * // >>> '1'
     *
     * console.log(args.getOption('b', 'c'));
     * // >>> '2'
     *
     * console.log(args.getOption('d'));
     * // >>> null
     * ```
     */
    getOption(...keys: readonly string[]): string | null;
    /**
     * Gets all the values of one or more option.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptions('a'));
     * // >>> ['1', '1']
     *
     * console.log(args.getOptions('b', 'c'));
     * // >>> ['2', '3']
     *
     * console.log(args.getOptions('d'));
     * // >>> null
     * ```
     */
    getOptions(...keys: readonly string[]): string[] | null;
    /**
     * Saves the current state into the stack following a FILO strategy (first-in, last-out).
     * @see Args#restore
     */
    save(): void;
    /**
     * Restores the previously saved state from the stack.
     * @see Args#save
     */
    restore(): void;
    /**
     * Whether all arguments have been consumed.
     */
    get finished(): boolean;
    /**
     * Defines the `JSON.stringify` override.
     */
    toJSON(): {
        message: Message<boolean>;
        command: MessageCommand;
        commandContext: MessageCommandContext;
    };
    protected unavailableArgument<T>(type: string | IArgument<T>): Err<UserError>;
    protected missingArguments(): Err<UserError>;
    /**
     * Resolves an argument.
     * @param arg The argument name or {@link IArgument} instance.
     */
    private resolveArgument;
    /**
     * Converts a callback into an usable argument.
     * @param cb The callback to convert into an {@link IArgument}.
     */
    static make<T>(cb: IArgument<T>['run'], name?: string): IArgument<T>;
    /**
     * Constructs an {@link Ok} result.
     * @param value The value to pass.
     */
    static ok<T>(value: T): Ok<T>;
    /**
     * Constructs an {@link Err} result containing an {@link ArgumentError}.
     * @param options The options for the argument error.
     */
    static error<T>(options: ArgumentError.Options<T>): Err<ArgumentError<T>>;
}
interface ArgType {
    boolean: boolean;
    channel: ChannelTypes;
    date: Date;
    dmChannel: DMChannel;
    emoji: EmojiObject;
    float: number;
    guildCategoryChannel: CategoryChannel;
    guildChannel: GuildBasedChannelTypes;
    guildNewsChannel: NewsChannel;
    guildNewsThreadChannel: ThreadChannel & {
        type: 'GUILD_NEWS_THREAD';
        parent: NewsChannel | null;
    };
    guildPrivateThreadChannel: ThreadChannel & {
        type: 'GUILD_PRIVATE_THREAD';
        parent: TextChannel | null;
    };
    guildPublicThreadChannel: ThreadChannel & {
        type: 'GUILD_PUBLIC_THREAD';
        parent: TextChannel | null;
    };
    guildStageVoiceChannel: StageChannel;
    guildTextChannel: TextChannel;
    guildThreadChannel: ThreadChannel;
    guildVoiceChannel: VoiceChannel;
    hyperlink: URL;
    integer: number;
    member: GuildMember;
    message: Message;
    number: number;
    role: Role;
    string: string;
    url: URL;
    user: User;
    enum: string;
}
interface ArgOptions extends Omit<Argument.Context, 'message' | 'command'> {
}
interface RepeatArgOptions extends ArgOptions {
    /**
     * The maximum amount of times the argument can be repeated.
     * @default Infinity
     */
    times?: number;
}
/**
 * The callback used for {@link Args.nextMaybe} and {@link Args.next}.
 */
interface ArgsNextCallback<T> {
    /**
     * The value to be mapped.
     */
    (value: string): Maybe<T>;
}

/**
 * Defines the result's value for a PreconditionContainer.
 * @since 1.0.0
 */
declare type PreconditionContainerResult = Result<unknown, UserError>;
/**
 * Defines the return type of the generic {@link IPreconditionContainer.messageRun}.
 * @since 1.0.0
 */
declare type PreconditionContainerReturn = Awaitable<PreconditionContainerResult>;
/**
 * Async-only version of {@link PreconditionContainerReturn}, to be used when the run method is async.
 * @since 1.0.0
 */
declare type AsyncPreconditionContainerReturn = Promise<PreconditionContainerResult>;
/**
 * An abstracted precondition container to be implemented by classes.
 * @since 1.0.0
 */
interface IPreconditionContainer {
    /**
     * Runs a precondition container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    messageRun(message: Message, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs a precondition container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    chatInputRun(interaction: CommandInteraction, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs a precondition container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    contextMenuRun(interaction: ContextMenuInteraction, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
}

/**
 * Defines the condition for {@link PreconditionContainerArray}s to run.
 * @since 1.0.0
 */
interface IPreconditionCondition {
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.sequential}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     */
    messageSequential(message: Message, command: MessageCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.parallel}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     */
    messageParallel(message: Message, command: MessageCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.sequential}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     */
    chatInputSequential(interaction: CommandInteraction, command: ChatInputCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.parallel}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     */
    chatInputParallel(interaction: CommandInteraction, command: ChatInputCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.sequential}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     */
    contextMenuSequential(interaction: ContextMenuInteraction, command: ContextMenuCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.parallel}
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     * @param entries The containers to run.
     */
    contextMenuParallel(interaction: ContextMenuInteraction, command: ContextMenuCommand, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
}

/**
 * Defines the simple options for the {@link PreconditionContainerSingle}, where only the name of the precondition can
 * be defined.
 * @since 2.0.0
 */
interface SimplePreconditionSingleResolvableDetails {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 2.0.0
     */
    name: SimplePreconditionKeys;
}
/**
 * Defines the detailed options for the {@link PreconditionContainerSingle}, where both the {@link PreconditionContext} and the
 * name of the precondition can be defined.
 * @since 1.0.0
 */
interface PreconditionSingleResolvableDetails<K extends PreconditionKeys = PreconditionKeys> {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 1.0.0
     */
    name: K;
    /**
     * The context to be set at {@link PreconditionContainerSingle.context}.
     * @since 1.0.0
     */
    context: Preconditions[K];
}
/**
 * Defines the data accepted by {@link PreconditionContainerSingle}'s constructor.
 * @since 1.0.0
 */
declare type PreconditionSingleResolvable = SimplePreconditionKeys | SimplePreconditionSingleResolvableDetails | PreconditionSingleResolvableDetails;
/**
 * An {@link IPreconditionContainer} which runs a single precondition from {@link SapphireClient.preconditions}.
 * @since 1.0.0
 */
declare class PreconditionContainerSingle implements IPreconditionContainer {
    /**
     * The context to be used when calling {@link Precondition.run}. This will always be an empty object (`{}`) when the
     * container was constructed with a string, otherwise it is a direct reference to the value from
     * {@link PreconditionSingleResolvableDetails.context}.
     * @since 1.0.0
     */
    readonly context: Record<PropertyKey, unknown>;
    /**
     * The name of the precondition to run.
     * @since 1.0.0
     */
    readonly name: string;
    constructor(data: PreconditionSingleResolvable);
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    messageRun(message: Message, command: MessageCommand, context?: PreconditionContext): PreconditionResult;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    chatInputRun(interaction: CommandInteraction, command: ChatInputCommand, context?: PreconditionContext): PreconditionResult;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    contextMenuRun(interaction: ContextMenuInteraction, command: ContextMenuCommand, context?: PreconditionContext): PreconditionResult;
}

/**
 * The run mode for a {@link PreconditionContainerArray}.
 * @since 1.0.0
 */
declare const enum PreconditionRunMode {
    /**
     * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous
     * tasks, but is performance savvy.
     * @since 1.0.0
     */
    Sequential = 0,
    /**
     * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have
     * completed.
     * @since 1.0.0
     */
    Parallel = 1
}
/**
 * The condition for a {@link PreconditionContainerArray}.
 */
declare enum PreconditionRunCondition {
    /**
     * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.
     * @since 1.0.0
     */
    And = 0,
    /**
     * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.
     * @since 1.0.0
     */
    Or = 1
}
/**
 * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the
 * entries can be defined.
 * @since 1.0.0
 */
interface PreconditionArrayResolvableDetails {
    /**
     * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.
     * @since 1.0.0
     */
    entries: readonly PreconditionEntryResolvable[];
    /**
     * The mode the {@link PreconditionContainerArray} will run.
     * @since 1.0.0
     */
    mode: PreconditionRunMode;
}
/**
 * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.
 * @since 1.0.0
 */
declare type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;
/**
 * Defines the data accepted for each entry of the array.
 * @since 1.0.0
 * @seealso {@link PreconditionArrayResolvable}
 * @seealso {@link PreconditionArrayResolvableDetails.entries}
 */
declare type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;
/**
 * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.
 *
 * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level
 * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).
 *
 * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:
 * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.
 * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.
 * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.
 *
 * In other words, it is identical to doing:
 * ```typescript
 * Connect && (Moderator || (DJ && SongAuthor));
 * ```
 * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),
 * see {@link PreconditionContainerArray.conditions} for more information.
 * @since 1.0.0
 */
declare class PreconditionContainerArray implements IPreconditionContainer {
    /**
     * The mode at which this precondition will run.
     * @since 1.0.0
     */
    readonly mode: PreconditionRunMode;
    /**
     * The {@link IPreconditionContainer}s the array holds.
     * @since 1.0.0
     */
    readonly entries: IPreconditionContainer[];
    /**
     * The {@link PreconditionRunCondition} that defines how entries must be handled.
     * @since 1.0.0
     */
    readonly runCondition: PreconditionRunCondition;
    constructor(data?: PreconditionArrayResolvable, parent?: PreconditionContainerArray | null);
    /**
     * Adds a new entry to the array.
     * @since 1.0.0
     * @param entry The value to add to the entries.
     */
    add(entry: IPreconditionContainer): this;
    append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;
    append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    messageRun(message: Message, command: MessageCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    chatInputRun(interaction: CommandInteraction, command: ChatInputCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs the container.
     * @since 3.0.0
     * @param interaction The interaction that ran this precondition.
     * @param command The command the interaction invoked.
     */
    contextMenuRun(interaction: ContextMenuInteraction, command: ContextMenuCommand, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Parses the precondition entry resolvables, and adds them to the entries.
     * @since 1.0.0
     * @param entries The entries to parse.
     */
    protected parse(entries: Iterable<PreconditionEntryResolvable>): this;
    /**
     * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.
     * @since 1.0.0
     */
    protected get condition(): IPreconditionCondition;
    /**
     * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then
     * inserting {@link IPreconditionCondition}s.
     * @since 1.0.0
     * @example
     * ```typescript
     * // Adding more kinds of conditions
     *
     * // Set the new condition:
     * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);
     *
     * // Augment Sapphire to add the new condition, in case of a JavaScript
     * // project, this can be moved to an `Augments.d.ts` (or any other name)
     * // file somewhere:
     * declare module '@sapphire/framework' {
     *   export enum PreconditionRunCondition {
     *     Random = 2
     *   }
     * }
     * ```
     */
    static readonly conditions: Collection<PreconditionRunCondition, IPreconditionCondition>;
}

/**
 * The strategy options used in Sapphire.
 */
interface FlagStrategyOptions {
    /**
     * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    flags?: readonly string[] | boolean;
    /**
     * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    options?: readonly string[] | boolean;
    /**
     * The prefixes for both flags and options.
     * @default ['--', '-', '—']
     */
    prefixes?: string[];
    /**
     * The flag separators.
     * @default ['=', ':']
     */
    separators?: string[];
}

declare type MessageCommand = Command & Required<Pick<Command, 'messageRun'>>;
declare namespace MessageCommand {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = MessageCommandContext;
}
declare type ChatInputCommand = Command & Required<Pick<Command, 'chatInputRun'>>;
declare namespace ChatInputCommand {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = ChatInputCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = CommandInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
declare type ContextMenuCommand = Command & Required<Pick<Command, 'contextMenuRun'>>;
declare namespace ContextMenuCommand {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = ContextMenuCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = ContextMenuInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
declare type AutocompleteCommand = Command & Required<Pick<Command, 'autocompleteRun'>>;
declare namespace AutocompleteCommand {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunInTypes = CommandOptionsRunType;
    type RunContext = AutocompleteCommandContext;
    type Interaction<Cached extends discord_js.CacheType = discord_js.CacheType> = AutocompleteInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
/**
 * The allowed values for {@link Command.Options.runIn}.
 * @remark It is discouraged to use this type, we recommend using {@link Command.OptionsRunTypeEnum} instead.
 * @since 2.0.0
 */
declare type CommandOptionsRunType = 'DM' | 'GUILD_TEXT' | 'GUILD_NEWS' | 'GUILD_NEWS_THREAD' | 'GUILD_PUBLIC_THREAD' | 'GUILD_PRIVATE_THREAD' | 'GUILD_ANY';
/**
 * The allowed values for {@link Command.Options.runIn} as an enum.
 * @since 2.0.0
 */
declare const enum CommandOptionsRunTypeEnum {
    Dm = "DM",
    GuildText = "GUILD_TEXT",
    GuildNews = "GUILD_NEWS",
    GuildNewsThread = "GUILD_NEWS_THREAD",
    GuildPublicThread = "GUILD_PUBLIC_THREAD",
    GuildPrivateThread = "GUILD_PRIVATE_THREAD",
    GuildAny = "GUILD_ANY"
}
/**
 * The available command pre-conditions.
 * @since 2.0.0
 */
declare const enum CommandPreConditions {
    Cooldown = "Cooldown",
    DirectMessageOnly = "DMOnly",
    GuildNewsOnly = "GuildNewsOnly",
    GuildNewsThreadOnly = "GuildNewsThreadOnly",
    GuildOnly = "GuildOnly",
    GuildPrivateThreadOnly = "GuildPrivateThreadOnly",
    GuildPublicThreadOnly = "GuildPublicThreadOnly",
    GuildTextOnly = "GuildTextOnly",
    GuildThreadOnly = "GuildThreadOnly",
    NotSafeForWork = "NSFW",
    ClientPermissions = "ClientPermissions",
    UserPermissions = "UserPermissions"
}
/**
 * The {@link Command} options.
 * @since 1.0.0
 */
interface CommandOptions extends AliasPiece.Options, FlagStrategyOptions {
    /**
     * Whether to add aliases for commands with dashes in them
     * @since 1.0.0
     * @default false
     */
    generateDashLessAliases?: boolean;
    /**
     * Whether to add aliases for commands with underscores in them
     * @since 3.0.0
     * @default false
     */
    generateUnderscoreLessAliases?: boolean;
    /**
     * The description for the command.
     * @since 1.0.0
     * @default ''
     */
    description?: string;
    /**
     * The detailed description for the command.
     * @since 1.0.0
     * @default ''
     */
    detailedDescription?: DetailedDescriptionCommand;
    /**
     * The full category path for the command
     * @since 2.0.0
     * @default 'An array of folder names that lead back to the folder that is registered for in the commands store'
     * @example
     * ```typescript
     * // Given a file named `ping.js` at the path of `commands/General/ping.js`
     * ['General']
     *
     * // Given a file named `info.js` at the path of `commands/General/About/ping.js`
     * ['General', 'About']
     * ```
     */
    fullCategory?: string[];
    /**
     * The {@link Precondition}s to be run, accepts an array of their names.
     * @seealso {@link PreconditionContainerArray}
     * @since 1.0.0
     * @default []
     */
    preconditions?: readonly PreconditionEntryResolvable[];
    /**
     * The quotes accepted by this command, pass `[]` to disable them.
     * @since 1.0.0
     * @default
     * [
     *   ['"', '"'], // Double quotes
     *   ['“', '”'], // Fancy quotes (on iOS)
     *   ['「', '」'] // Corner brackets (CJK)
     *   ['«', '»'] // French quotes (guillemets)
     * ]
     */
    quotes?: [string, string][];
    /**
     * Sets whether or not the command should be treated as NSFW. If set to true, the `NSFW` precondition will be added to the list.
     * @since 2.0.0
     * @default false
     */
    nsfw?: boolean;
    /**
     * The amount of entries the cooldown can have before filling up, if set to a non-zero value alongside {@link Command.Options.cooldownDelay}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 1
     */
    cooldownLimit?: number;
    /**
     * The time in milliseconds for the cooldown entries to reset, if set to a non-zero value alongside {@link Command.Options.cooldownLimit}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 0
     */
    cooldownDelay?: number;
    /**
     * The scope of the cooldown entries.
     * @since 2.0.0
     * @default BucketScope.User
     */
    cooldownScope?: BucketScope;
    /**
     * The users that are exempt from the Cooldown precondition.
     * Use this to filter out someone like a bot owner
     * @since 2.0.0
     * @default undefined
     */
    cooldownFilteredUsers?: Snowflake[];
    /**
     * The required permissions for the client.
     * @since 2.0.0
     * @default 0
     */
    requiredClientPermissions?: PermissionResolvable;
    /**
     * The required permissions for the user.
     * @since 2.0.0
     * @default 0
     */
    requiredUserPermissions?: PermissionResolvable;
    /**
     * The channels the command should run in. If set to `null`, no precondition entry will be added. Some optimizations are applied when given an array to reduce the amount of preconditions run (e.g. `'GUILD_TEXT'` and `'GUILD_NEWS'` becomes `'GUILD_ANY'`, and if both `'DM'` and `'GUILD_ANY'` are defined, then no precondition entry is added as it runs in all channels).
     * @since 2.0.0
     * @default null
     */
    runIn?: Command.RunInTypes | CommandOptionsRunTypeEnum | readonly (Command.RunInTypes | CommandOptionsRunTypeEnum)[] | null;
    /**
     * If {@link SapphireClient.typing} is true, this option will override it.
     * Otherwise, this option has no effect - you may call {@link Channel#sendTyping}` in the run method if you want specific commands to display the typing status.
     * @default true
     */
    typing?: boolean;
    /**
     * Shortcuts for registering simple chat input commands
     *
     * :::warn
     *
     * You should only use this if your command does not take in options, and is just a chat input one.
     * Otherwise, please read the [guide about registering application commands](https://www.sapphirejs.dev/docs/Guide/commands/registering-application-commands) instead.
     *
     * :::
     *
     * @since 3.0.0
     */
    chatInputCommand?: CommandChatInputRegisterShortcut;
}
interface CommandChatInputRegisterShortcut {
    /**
     * Specifies what we should do when the command is present, but not identical with the data you provided
     * @default RegisterBehavior.LogToConsole
     */
    behaviorWhenNotIdentical?: RegisterBehavior;
    /**
     * If we should register the command, be it missing or present already
     * @default false
     */
    register: boolean;
    /**
     * If this is specified, the application commands will only be registered for these guild ids.
     *
     * :::tip
     *
     * If you want to register both guild and global chat input commands,
     * please read the [guide about registering application commands](https://www.sapphirejs.dev/docs/Guide/commands/registering-application-commands) instead.
     *
     * :::
     *
     */
    guildIds?: string[];
    /**
     * Specifies a list of command ids that we should check in the event of a name mismatch
     * @default []
     */
    idHints?: string[];
    /**
     * Sets the `defaultPermission` field for the chat input command
     *
     * :::warn
     *
     * This will be deprecated in the future for Discord's new permission system.
     *
     * :::
     */
    defaultPermission?: boolean;
    /**
     * Sets the `nameLocalizations` for the chat input command
     */
    nameLocalizations?: LocalizationMap;
    /**
     * Sets the `descriptionLocalizations` for the chat input command
     */
    descriptionLocalizations?: LocalizationMap;
}
interface MessageCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The prefix used to run this command.
     *
     * This is a string for the mention and default prefix, and a RegExp for the `regexPrefix`.
     */
    prefix: string | RegExp;
    /**
     * The alias used to run this command.
     */
    commandName: string;
    /**
     * The matched prefix, this will always be the same as {@link MessageCommand.RunContext.prefix} if it was a string, otherwise it is
     * the result of doing `prefix.exec(content)[0]`.
     */
    commandPrefix: string;
}
interface ChatInputCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface ContextMenuCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface AutocompleteCommandContext extends Record<PropertyKey, unknown> {
    /**
     * The name of the command.
     */
    commandName: string;
    /**
     * The id of the command.
     */
    commandId: string;
}
interface CommandJSON extends AliasPieceJSON {
    description: string;
    detailedDescription: DetailedDescriptionCommand;
    category: string | null;
}
declare class Command<PreParseReturn = Args, O extends Command.Options = Command.Options> extends AliasPiece<O> {
    /**
     * A basic summary about the command
     * @since 1.0.0
     */
    description: string;
    /**
     * The preconditions to be run.
     * @since 1.0.0
     */
    preconditions: PreconditionContainerArray;
    /**
     * Longer version of command's summary and how to use it
     * @since 1.0.0
     */
    detailedDescription: DetailedDescriptionCommand;
    /**
     * The full category for the command. Either an array of strings that denote every (sub)folder the command is in,
     * or `null` if it could not be resolved automatically.
     *
     * If this is `null` for how you setup your code then you can overwrite how the `fullCategory` is resolved by
     * extending this class and overwriting the assignment in the constructor.
     * @since 2.0.0
     */
    readonly fullCategory: readonly string[];
    /**
     * The strategy to use for the lexer.
     * @since 1.0.0
     */
    strategy: Lexure.UnorderedStrategy;
    /**
     * If {@link SapphireClient.typing} is true, it can be overridden for a specific command using this property, set via its options.
     * Otherwise, this property will be ignored.
     * @default true
     */
    typing: boolean;
    /**
     * The application command registry associated with this command.
     * @since 3.0.0
     */
    readonly applicationCommandRegistry: ApplicationCommandRegistry;
    /**
     * Options used to easily register chat input commands
     * @since 3.0.0
     * @private
     */
    readonly chatInputCommandOptions: CommandChatInputRegisterShortcut;
    /**
     * The lexer to be used for command parsing
     * @since 1.0.0
     * @private
     */
    protected lexer: Lexure.Lexer;
    /**
     * @since 1.0.0
     * @param context The context.
     * @param options Optional Command settings.
     */
    protected constructor(context: PieceContext, options?: O);
    /**
     * The message pre-parse method. This method can be overridden by plugins to define their own argument parser.
     * @param message The message that triggered the command.
     * @param parameters The raw parameters as a single string.
     * @param context The command-context used in this execution.
     */
    messagePreParse(message: Message, parameters: string, context: MessageCommand.RunContext): Awaitable<PreParseReturn>;
    /**
     * The main category for the command, if any.
     *
     * This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get category(): string | null;
    /**
     * The sub-category for the command, if any.
     *
     * This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise
     * it returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get subCategory(): string | null;
    /**
     * The parent category for the command.
     *
     * This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get parentCategory(): string | null;
    /**
     * Executes the message command's logic.
     * @param message The message that triggered the command.
     * @param args The value returned by {@link Command.messagePreParse}, by default an instance of {@link Args}.
     * @param context The context in which the command was executed.
     */
    messageRun?(message: Message, args: PreParseReturn, context: MessageCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the application command's logic.
     * @param interaction The interaction that triggered the command.
     */
    chatInputRun?(interaction: CommandInteraction, context: ChatInputCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the context menu's logic.
     * @param interaction The interaction that triggered the command.
     */
    contextMenuRun?(interaction: ContextMenuInteraction, context: ContextMenuCommand.RunContext): Awaitable<unknown>;
    /**
     * Executes the autocomplete logic.
     *
     * :::tip
     *
     * You may use this, or alternatively create an {@link InteractionHandler interaction handler} to handle autocomplete interactions.
     * Keep in mind that commands take precedence over interaction handlers.
     *
     * :::
     *
     * @param interaction The interaction that triggered the autocomplete.
     */
    autocompleteRun?(interaction: AutocompleteInteraction): Awaitable<unknown>;
    /**
     * Defines the JSON.stringify behavior of the command.
     */
    toJSON(): CommandJSON;
    /**
     * Registers the application commands that should be handled by this command.
     * @param registry This command's registry
     */
    registerApplicationCommands(registry: ApplicationCommandRegistry): Awaitable<void>;
    /**
     * Type-guard that ensures the command supports message commands by checking if the handler for it is present
     */
    supportsMessageCommands(): this is MessageCommand;
    /**
     * Type-guard that ensures the command supports chat input commands by checking if the handler for it is present
     */
    supportsChatInputCommands(): this is ChatInputCommand;
    /**
     * Type-guard that ensures the command supports context menu commands by checking if the handler for it is present
     */
    supportsContextMenuCommands(): this is ContextMenuCommand;
    /**
     * Type-guard that ensures the command supports handling autocomplete interactions by checking if the handler for it is present
     */
    supportsAutocompleteInteractions(): this is AutocompleteCommand;
    reload(): Promise<void>;
    /**
     * Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},
     * {@link Command#parseConstructorPreConditionsNsfw},
     * {@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and
     * {@link Command#parseConstructorPreConditionsCooldown}.
     * @since 2.0.0
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditions(options: Command.Options): void;
    /**
     * Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsNsfw(options: Command.Options): void;
    /**
     * Appends the `DMOnly`, `GuildOnly`, `NewsOnly`, and `TextOnly` preconditions based on the values passed in
     * {@link Command.Options.runIn}, optimizing in specific cases (`NewsOnly` + `TextOnly` = `GuildOnly`; `DMOnly` +
     * `GuildOnly` = `null`), defaulting to `null`, which doesn't add a precondition.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRunIn(options: Command.Options): void;
    /**
     * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredClientPermissions(options: Command.Options): void;
    /**
     * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredUserPermissions(options: Command.Options): void;
    /**
     * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and
     * {@link Command.Options.cooldownDelay} are both non-zero.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsCooldown(options: Command.Options): void;
    private resolveConstructorPreConditionsRunType;
}
declare namespace Command {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunInTypes = CommandOptionsRunType;
    type ChatInputInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.CommandInteraction<Cached>;
    type ContextMenuInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.ContextMenuInteraction<Cached>;
    type AutocompleteInteraction<Cached extends discord_js.CacheType = discord_js.CacheType> = discord_js.AutocompleteInteraction<Cached>;
    type Registry = ApplicationCommandRegistry;
}
declare type DetailedDescriptionCommand = string | DetailedDescriptionCommandObject;
interface DetailedDescriptionCommandObject extends NonNullObject {
}

interface CooldownPreconditionContext extends PreconditionContext {
    scope?: BucketScope;
    delay: number;
    limit?: number;
    filteredUsers?: Snowflake[];
}
declare class CorePrecondition$c extends AllFlowsPrecondition {
    buckets: WeakMap<Command<Args, CommandOptions>, RateLimitManager<string>>;
    messageRun(message: Message, command: Command, context: CooldownPreconditionContext): PreconditionResult;
    chatInputRun(interaction: CommandInteraction, command: Command, context: CooldownPreconditionContext): PreconditionResult;
    contextMenuRun(interaction: ContextMenuInteraction, command: Command, context: CooldownPreconditionContext): PreconditionResult;
    private sharedRun;
    private getIdFromMessage;
    private getIdFromInteraction;
    private getManager;
}

/**
 * Errors thrown by preconditions
 * @property name This will be `'PreconditionError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class PreconditionError extends UserError {
    readonly precondition: Precondition;
    constructor(options: PreconditionError.Options);
    get name(): string;
}
declare namespace PreconditionError {
    /**
     * The options for {@link PreconditionError}.
     * @since 1.0.0
     */
    interface Options extends Omit<UserError.Options, 'identifier'> {
        /**
         * The precondition that caused the error.
         * @since 1.0.0
         */
        precondition: Precondition;
        /**
         * The identifier.
         * @since 1.0.0
         * @default precondition.name
         */
        identifier?: string;
    }
}

declare type PreconditionResult = Awaitable<Result<unknown, UserError>>;
declare type AsyncPreconditionResult = Promise<Result<unknown, UserError>>;
/**
 * The registered preconditions and their contexts, if any. When registering new ones, it is recommended to use
 * [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) so
 * custom ones are registered.
 *
 * When a key's value is `never`, it means that it does not take any context, which allows you to pass its identifier as
 * a bare string (e.g. `preconditions: ['NSFW']`), however, if context is required, a non-`never` type should be passed,
 * which will type {@link PreconditionContainerArray#append} and require an object with the name and a `context` with
 * the defined type.
 *
 * @example
 * ```typescript
 * declare module '@sapphire/framework' {
 *   interface Preconditions {
 *     // A precondition named `Moderator` which does not read `context`:
 *     Moderator: never;
 *
 *     // A precondition named `ChannelPermissions` which does read `context`:
 *     ChannelPermissions: {
 *       permissions: Permissions;
 *     };
 *   }
 * }
 *
 * // [✔] These are valid:
 * preconditions.append('Moderator');
 * preconditions.append({ name: 'Moderator' });
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { permissions: new Permissions(8) }
 * });
 *
 * // [X] These are invalid:
 * preconditions.append({ name: 'Moderator', context: {} });
 * // ➡ `never` keys do not accept `context`.
 *
 * preconditions.append('ChannelPermissions');
 * // ➡ non-`never` keys always require `context`, a string cannot be used.
 *
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { unknownProperty: 1 }
 * });
 * // ➡ mismatching `context` properties, `{ unknownProperty: number }` is not
 * // assignable to `{ permissions: Permissions }`.
 * ```
 */
interface Preconditions {
    Cooldown: CooldownPreconditionContext;
    DMOnly: never;
    Enabled: never;
    GuildNewsOnly: never;
    GuildNewsThreadOnly: never;
    GuildOnly: never;
    GuildPrivateThreadOnly: never;
    GuildPublicThreadOnly: never;
    GuildTextOnly: never;
    GuildThreadOnly: never;
    NSFW: never;
    ClientPermissions: {
        permissions: Permissions;
    };
    UserPermissions: {
        permissions: Permissions;
    };
}
declare type PreconditionKeys = keyof Preconditions;
declare type SimplePreconditionKeys = {
    [K in PreconditionKeys]: Preconditions[K] extends never ? K : never;
}[PreconditionKeys];
interface PreconditionOptions extends Piece.Options {
    /**
     * The position for the precondition to be set at in the global precondition list. If set to `null`, this
     * precondition will not be set as a global one.
     * @default null
     */
    position?: number | null;
}
interface PreconditionContext extends Record<PropertyKey, unknown> {
    external?: boolean;
}
declare class Precondition<O extends Precondition.Options = Precondition.Options> extends Piece<O> {
    readonly position: number | null;
    constructor(context: Piece.Context, options?: Precondition.Options);
    messageRun?(message: Message, command: MessageCommand, context: Precondition.Context): Precondition.Result;
    chatInputRun?(interaction: CommandInteraction, command: ChatInputCommand, context: Precondition.Context): Precondition.Result;
    contextMenuRun?(interaction: ContextMenuInteraction, command: ContextMenuCommand, context: Precondition.Context): Precondition.Result;
    ok(): Precondition.Result;
    /**
     * Constructs a {@link PreconditionError} with the precondition parameter set to `this`.
     * @param options The information.
     */
    error(options?: Omit<PreconditionError.Options, 'precondition'>): Precondition.Result;
    protected fetchChannelFromInteraction(interaction: BaseCommandInteraction): Promise<TextBasedChannel>;
}
declare namespace Precondition {
    type Options = PreconditionOptions;
    type Context = PreconditionContext;
    type Result = PreconditionResult;
    type AsyncResult = AsyncPreconditionResult;
}
declare abstract class AllFlowsPrecondition extends Precondition {
    abstract messageRun(message: Message, command: MessageCommand, context: Precondition.Context): Precondition.Result;
    abstract chatInputRun(interaction: CommandInteraction, command: ChatInputCommand, context: Precondition.Context): Precondition.Result;
    abstract contextMenuRun(interaction: ContextMenuInteraction, command: ContextMenuCommand, context: Precondition.Context): Precondition.Result;
}
declare namespace AllFlowsPrecondition {
    type Options = PreconditionOptions;
    type Context = PreconditionContext;
    type Result = PreconditionResult;
    type AsyncResult = AsyncPreconditionResult;
}

interface PermissionPreconditionContext extends PreconditionContext {
    permissions?: Permissions;
}
declare class CorePrecondition$b extends AllFlowsPrecondition {
    private readonly dmChannelPermissions;
    messageRun(message: Message, _: Command, context: PermissionPreconditionContext): PreconditionResult;
    chatInputRun(interaction: CommandInteraction, _: Command, context: PermissionPreconditionContext): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction, _: Command, context: PermissionPreconditionContext): Promise<_sapphire_result.Result<unknown, UserError>>;
    private sharedRun;
    static readonly readablePermissions: Record<PermissionString, string>;
}

declare class CorePrecondition$a extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): PreconditionResult;
    contextMenuRun(interaction: ContextMenuInteraction): PreconditionResult;
}

declare class CorePrecondition$9 extends AllFlowsPrecondition {
    constructor(context: PieceContext);
    messageRun(_: Message, command: Command, context: AllFlowsPrecondition.Context): PreconditionResult;
    chatInputRun(_: CommandInteraction, command: Command, context: AllFlowsPrecondition.Context): PreconditionResult;
    contextMenuRun(_: ContextMenuInteraction, command: Command, context: AllFlowsPrecondition.Context): PreconditionResult;
}

declare class CorePrecondition$8 extends AllFlowsPrecondition {
    private readonly allowedTypes;
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$7 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$6 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): PreconditionResult;
    contextMenuRun(interaction: ContextMenuInteraction): PreconditionResult;
}

declare class CorePrecondition$5 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$4 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$3 extends AllFlowsPrecondition {
    private readonly allowedTypes;
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$2 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition$1 extends AllFlowsPrecondition {
    messageRun(message: Message): PreconditionResult;
    chatInputRun(interaction: CommandInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
    contextMenuRun(interaction: ContextMenuInteraction): Promise<_sapphire_result.Result<unknown, UserError>>;
}

declare class CorePrecondition extends AllFlowsPrecondition {
    private readonly dmChannelPermissions;
    messageRun(message: Message, _command: Command, context: PermissionPreconditionContext): PreconditionResult;
    chatInputRun(interaction: CommandInteraction, _command: Command, context: PermissionPreconditionContext): PreconditionResult;
    contextMenuRun(interaction: ContextMenuInteraction, _command: Command, context: PermissionPreconditionContext): PreconditionResult;
    private sharedRun;
}

declare type AsyncPluginHooks = PluginHook.PreLogin | PluginHook.PostLogin;
interface SapphirePluginAsyncHook {
    (this: SapphireClient, options: ClientOptions): Awaitable<unknown>;
}
declare type SyncPluginHooks = Exclude<PluginHook, AsyncPluginHooks>;
interface SapphirePluginHook {
    (this: SapphireClient, options: ClientOptions): unknown;
}
interface SapphirePluginHookEntry<T = SapphirePluginHook | SapphirePluginAsyncHook> {
    hook: T;
    type: PluginHook;
    name?: string;
}
declare class PluginManager {
    readonly registry: Set<SapphirePluginHookEntry<SapphirePluginAsyncHook | SapphirePluginHook>>;
    registerHook(hook: SapphirePluginHook, type: SyncPluginHooks, name?: string): this;
    registerHook(hook: SapphirePluginAsyncHook, type: AsyncPluginHooks, name?: string): this;
    registerPreGenericsInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPostInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    registerPostLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    use(plugin: typeof Plugin): this;
    values(): Generator<SapphirePluginHookEntry, void, unknown>;
    values(hook: SyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginHook>, void, unknown>;
    values(hook: AsyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginAsyncHook>, void, unknown>;
}

declare class ArgumentStore extends AliasStore<Argument> {
    constructor();
}

/**
 * Stores all Command pieces
 * @since 1.0.0
 */
declare class CommandStore extends AliasStore<Command> {
    constructor();
    /**
     * Get all the command categories.
     */
    get categories(): string[];
    unload(name: string | Command): Promise<Command<Args, CommandOptions>>;
    loadAll(): Promise<void>;
}

interface InteractionHandlerOptions extends PieceOptions {
    /**
     * The type of interaction this handler is for. Must be one of {@link InteractionHandlerTypes}.
     */
    readonly interactionHandlerType: InteractionHandlerTypes;
}
interface InteractionHandlerJSON extends PieceJSON {
    interactionHandlerType: InteractionHandlerTypes;
}
declare type InteractionHandlerParseResult<Instance extends InteractionHandler> = UnwrapMaybeValue<Awaited<ReturnType<Instance['parse']>>>;
declare abstract class InteractionHandler<O extends InteractionHandler.Options = InteractionHandler.Options> extends Piece<O> {
    /**
     * The type for this handler
     * @since 3.0.0
     */
    readonly interactionHandlerType: InteractionHandlerTypes;
    constructor(context: PieceContext, options: InteractionHandlerOptions);
    abstract run(interaction: Interaction, parsedData?: unknown): unknown;
    /**
     * A custom function that will be called when checking if an interaction should be passed to this handler.
     * You can use this method to not only filter by ids, but also pre-parse the data from the id for use in the run method.
     *
     * By default, all interactions of the type you specified will run in a handler. You should override this method
     * to change that behavior.
     *
     * @example
     * ```typescript
     * // Parsing a button handler
     * public override parse(interaction: ButtonInteraction) {
     *   if (interaction.customId.startsWith('my-awesome-clicky-button')) {
     * 	   // Returning a `some` here means that the run method should be called next!
     *     return this.some({ isMyBotAwesome: true, awesomenessLevel: 9001 });
     *   }
     *
     *   // Returning a `none` means this interaction shouldn't run in this handler
     *   return this.none();
     * }
     * ```
     *
     * @example
     * ```typescript
     * // Getting data from a database based on the custom id
     * public override async parse(interaction: ButtonInteraction) {
     *   // This code is purely for demonstration purposes only!
     *   if (interaction.customId.startsWith('example-data')) {
     *     const [, userId, channelId] = interaction.customId.split('.');
     *
     * 	   const dataFromDatabase = await container.prisma.exampleData.findFirst({ where: { userId, channelId } });
     *
     *     // Returning a `some` here means that the run method should be called next!
     *     return this.some(dataFromDatabase);
     *   }
     *
     *   // Returning a `none` means this interaction shouldn't run in this handler
     *   return this.none();
     * }
     * ```
     *
     * @returns A {@link Maybe} (or a {@link Promise Promised} {@link Maybe}) that indicates if this interaction should be
     * handled by this handler, and any extra data that should be passed to the {@link InteractionHandler.run run method}
     */
    parse(_interaction: Interaction): Awaitable<Maybe<unknown>>;
    some(): Maybe<never>;
    some<T>(data: T): Maybe<T>;
    none(): None;
    toJSON(): InteractionHandlerJSON;
}
declare namespace InteractionHandler {
    type Options = InteractionHandlerOptions;
    type JSON = InteractionHandlerJSON;
    type ParseResult<Instance extends InteractionHandler> = InteractionHandlerParseResult<Instance>;
}
declare const enum InteractionHandlerTypes {
    Button = "BUTTON",
    SelectMenu = "SELECT_MENU",
    ModalSubmit = "MODAL_SUBMIT",
    MessageComponent = "MESSAGE_COMPONENT",
    Autocomplete = "AUTOCOMPLETE"
}

declare class InteractionHandlerStore extends Store<InteractionHandler> {
    constructor();
    run(interaction: Interaction): Promise<boolean>;
}
declare const InteractionHandlerFilters: Map<InteractionHandlerTypes, (interaction: Interaction) => boolean>;

interface ListenerOptions extends Piece.Options {
    readonly emitter?: keyof Client | EventEmitter;
    readonly event?: string | symbol;
    readonly once?: boolean;
}
interface ListenerJSON extends Piece.JSON {
    event: string | symbol;
    once: boolean;
}
/**
 * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In
 * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Events, Listener } from '@sapphire/framework';
 *
 * // Define a class extending `Listener`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreListener extends Listener<typeof Events.Ready> {
 *   public constructor(context: Listener.Context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   public run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Events, Listener } = require('@sapphire/framework');
 *
 * // Define a class extending `Listener`, then export it.
 * module.exports = class CoreListener extends Listener {
 *   constructor(context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 */
declare abstract class Listener<E extends keyof ClientEvents | symbol = '', O extends Listener.Options = Listener.Options> extends Piece<O> {
    /**
     * The emitter, if any.
     * @since 2.0.0
     */
    readonly emitter: EventEmitter | null;
    /**
     * The name of the event the listener listens to.
     * @since 2.0.0
     */
    readonly event: string | symbol;
    /**
     * Whether or not the listener will be unloaded after the first run.
     * @since 2.0.0
     */
    readonly once: boolean;
    private _listener;
    constructor(context: Listener.Context, options?: O);
    abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;
    onLoad(): unknown;
    onUnload(): unknown;
    toJSON(): ListenerJSON;
    private _run;
    private _runOnce;
}
declare namespace Listener {
    type Options = ListenerOptions;
    type JSON = ListenerJSON;
    type Context = Piece.Context;
}

declare class ListenerStore extends Store<Listener> {
    constructor();
}

declare class PreconditionStore extends Store<Precondition> {
    private readonly globalPreconditions;
    constructor();
    messageRun(message: Message, command: MessageCommand, context?: PreconditionContext): AsyncPreconditionResult;
    chatInputRun(interaction: CommandInteraction, command: ChatInputCommand, context?: PreconditionContext): AsyncPreconditionResult;
    contextMenuRun(interaction: ContextMenuInteraction, command: ContextMenuCommand, context?: PreconditionContext): AsyncPreconditionResult;
    set(key: string, value: Precondition): this;
    delete(key: string): boolean;
    clear(): void;
}

/**
 * The logger levels for the {@link ILogger}.
 */
declare const enum LogLevel {
    /**
     * The lowest log level, used when calling {@link ILogger.trace}.
     */
    Trace = 10,
    /**
     * The debug level, used when calling {@link ILogger.debug}.
     */
    Debug = 20,
    /**
     * The info level, used when calling {@link ILogger.info}.
     */
    Info = 30,
    /**
     * The warning level, used when calling {@link ILogger.warn}.
     */
    Warn = 40,
    /**
     * The error level, used when calling {@link ILogger.error}.
     */
    Error = 50,
    /**
     * The critical level, used when calling {@link ILogger.fatal}.
     */
    Fatal = 60,
    /**
     * An unknown or uncategorized level.
     */
    None = 100
}
interface ILogger {
    /**
     * Checks whether a level is supported.
     * @param level The level to check.
     */
    has(level: LogLevel): boolean;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Trace} as level.
     * @param values The values to log.
     */
    trace(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Debug} as level.
     * @param values The values to log.
     */
    debug(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Info} as level.
     * @param values The values to log.
     */
    info(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Warn} as level.
     * @param values The values to log.
     */
    warn(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Error} as level.
     * @param values The values to log.
     */
    error(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Fatal} as level.
     * @param values The values to log.
     */
    fatal(...values: readonly unknown[]): void;
    /**
     * Writes the log message given a level and the value(s).
     * @param level The log level.
     * @param values The values to log.
     */
    write(level: LogLevel, ...values: readonly unknown[]): void;
}

/**
 * A valid prefix in Sapphire.
 * * `string`: a single prefix, e.g. `'!'`.
 * * `string[]`: an array of prefixes, e.g. `['!', '.']`.
 * * `null`: disabled prefix, locks the bot's command usage to mentions only.
 */
declare type SapphirePrefix = string | readonly string[] | null;
interface SapphirePrefixHook {
    (message: Message): Awaitable<SapphirePrefix>;
}
interface SapphireClientOptions {
    /**
     * The base user directory, if set to `null`, Sapphire will not call {@link StoreRegistry.registerPath},
     * meaning that you will need to manually set each folder for each store. Please read the aforementioned method's
     * documentation for more information.
     * @since 1.0.0
     * @default undefined
     */
    baseUserDirectory?: string | null;
    /**
     * Whether commands can be case insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitiveCommands?: boolean | null;
    /**
     * Whether prefixes can be case insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitivePrefixes?: boolean | null;
    /**
     * The default prefix, in case of `null`, only mention prefix will trigger the bot's commands.
     * @since 1.0.0
     * @default null
     */
    defaultPrefix?: SapphirePrefix;
    /**
     * The regex prefix, an alternative to a mention or regular prefix to allow creating natural language command messages
     * @since 1.0.0
     * @example
     * ```typescript
     * /^(hey +)?bot[,! ]/i
     *
     * // Matches:
     * // - hey bot,
     * // - hey bot!
     * // - hey bot
     * // - bot,
     * // - bot!
     * // - bot
     * ```
     */
    regexPrefix?: RegExp;
    /**
     * The prefix hook, by default it is a callback function that returns {@link SapphireClientOptions.defaultPrefix}.
     * @since 1.0.0
     * @default () => client.options.defaultPrefix
     */
    fetchPrefix?: SapphirePrefixHook;
    /**
     * The client's ID, this is automatically set by the CoreReady event.
     * @since 1.0.0
     * @default this.client.user?.id ?? null
     */
    id?: Snowflake;
    /**
     * The logger options, defaults to an instance of {@link Logger} when {@link ClientLoggerOptions.instance} is not specified.
     * @since 1.0.0
     * @default { instance: new Logger(LogLevel.Info) }
     */
    logger?: ClientLoggerOptions;
    /**
     * Whether or not trace logging should be enabled.
     * @since 2.0.0
     * @default container.logger.has(LogLevel.Trace)
     */
    enableLoaderTraceLoggings?: boolean;
    /**
     * If Sapphire should load the pre-included error event listeners that log any encountered errors to the {@link SapphireClient.logger} instance
     * @since 1.0.0
     * @default true
     */
    loadDefaultErrorListeners?: boolean;
    /**
     * If Sapphire should load the pre-included message command listeners that are used to process incoming messages for commands.
     * @since 3.0.0
     * @default false
     */
    loadMessageCommandListeners?: boolean;
    /**
     * Controls whether the bot will automatically appear to be typing when a command is accepted.
     * @default false
     */
    typing?: boolean;
    /**
     * Sets the default cooldown time for all commands.
     * @default "No cooldown options"
     */
    defaultCooldown?: CooldownOptions;
    /**
     * Controls whether the bot has mention as a prefix disabled
     * @default false
     */
    disableMentionPrefix?: boolean;
    /**
     * Whenever starting the bot process Sapphire may report errors when failing to fetch guild commands.
     * One of the causes for this can be when a bot was invited to a server without the `application.commands` scope.
     *
     * Normally this produce a log in the console at the WARN level, however because bot lists have a tendency to invite your
     * bot specifically without the scope to ensure that your Chat Input and Context Menu commands do not show up as usable commands
     * in that server, you may want to include their guild ids in this list.
     *
     * By adding ids to this list, whenever a guild id matches one of the ids in the list no warning log message will be emitted for that guild.
     *
     * Note that this specifically applies to the warning log:
     *
     * > ApplicationCommandRegistries: Failed to fetch guild commands for guild \<guild name\> (\<guild id\>). Make sure to authorize your application with the "applications.commands" scope in that guild.
     */
    preventFailedToFetchLogForGuildIds?: string[];
}
/**
 * The base {@link Client} extension that makes Sapphire work. When building a Discord bot with the framework, the developer
 * must either use this class, or extend it.
 *
 * Sapphire also automatically detects the folders to scan for pieces, please read {@link StoreRegistry.registerPath}
 * for reference. This method is called at the start of the {@link SapphireClient.login} method.
 *
 * @see {@link SapphireClientOptions} for all options available to the Sapphire Client. You can also provide all of discord.js' [ClientOptions](https://discord.js.org/#/docs/main/stable/typedef/ClientOptions)
 *
 * @since 1.0.0
 * @example
 * ```typescript
 * const client = new SapphireClient({
 *   presence: {
 *     activity: {
 *       name: 'for commands!',
 *       type: 'LISTENING'
 *     }
 *   }
 * });
 *
 * client.login(process.env.DISCORD_TOKEN)
 *   .catch(console.error);
 * ```
 *
 * @example
 * ```typescript
 * // Automatically scan from a specific directory, e.g. the main
 * // file is at `/home/me/bot/index.js` and all your pieces are at
 * // `/home/me/bot/pieces` (e.g. `/home/me/bot/pieces/commands/MyCommand.js`):
 * const client = new SapphireClient({
 *   baseUserDirectory: join(__dirname, 'pieces'),
 *   // More options...
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Opt-out automatic scanning:
 * const client = new SapphireClient({
 *   baseUserDirectory: null,
 *   // More options...
 * });
 * ```
 */
declare class SapphireClient<Ready extends boolean = boolean> extends Client<Ready> {
    /**
     * The client's ID, used for the user prefix.
     * @since 1.0.0
     */
    id: Snowflake | null;
    /**
     * The method to be overridden by the developer.
     * @since 1.0.0
     * @return A string for a single prefix, an array of strings for matching multiple, or null for no match (mention prefix only).
     * @example
     * ```typescript
     * // Return always the same prefix (unconfigurable):
     * client.fetchPrefix = () => '!';
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from a SQL database:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getOne('SELECT prefix FROM public.guild WHERE id = $1', [message.guild.id]);
     *   return guild?.prefix ?? '!';
     * };
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from an ORM:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getRepository(GuildEntity).findOne({ id: message.guild.id });
     *   return guild?.prefix ?? '!';
     * };
     * ```
     */
    fetchPrefix: SapphirePrefixHook;
    /**
     * The logger to be used by the framework and plugins. By default, a {@link Logger} instance is used, which emits the
     * messages to the console.
     * @since 1.0.0
     */
    logger: ILogger;
    /**
     * Whether the bot has mention as a prefix disabled
     * @default false
     * @example
     * ```typescript
     * client.disableMentionPrefix = false;
     * ```
     */
    disableMentionPrefix?: boolean;
    /**
     * The registered stores.
     * @since 1.0.0
     */
    stores: StoreRegistry;
    constructor(options: ClientOptions);
    /**
     * Loads all pieces, then logs the client in, establishing a websocket connection to Discord.
     * @since 1.0.0
     * @param token Token of the account to log in with.
     * @return Token of the account used.
     */
    login(token?: string): Promise<string>;
    static plugins: PluginManager;
    static use(plugin: typeof Plugin): typeof SapphireClient;
}
interface ClientLoggerOptions {
    level?: LogLevel;
    instance?: ILogger;
}
interface CooldownOptions {
    scope?: BucketScope;
    delay?: number;
    limit?: number;
    filteredUsers?: Snowflake[];
    filteredCommands?: string[];
}
declare module 'discord.js' {
    interface Client {
        id: Snowflake | null;
        logger: ILogger;
        stores: StoreRegistry;
        fetchPrefix: SapphirePrefixHook;
    }
    interface ClientOptions extends SapphireClientOptions {
    }
}
declare module '@sapphire/pieces' {
    interface Container {
        client: SapphireClient;
        logger: ILogger;
        stores: StoreRegistry;
        applicationCommandRegistries: {
            acquire: typeof acquire;
        };
    }
    interface StoreRegistryEntries {
        arguments: ArgumentStore;
        commands: CommandStore;
        'interaction-handlers': InteractionHandlerStore;
        listeners: ListenerStore;
        preconditions: PreconditionStore;
    }
}

declare const preGenericsInitialization: unique symbol;
declare const preInitialization: unique symbol;
declare const postInitialization: unique symbol;
declare const preLogin: unique symbol;
declare const postLogin: unique symbol;

declare abstract class Plugin {
    static [preGenericsInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [postInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
    static [postLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
}

/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 * Use {@link Argument} instead, and abstract the resolving of the argument data to an external resolver.
 * ---
 * The extended argument class. This class is abstract and is to be extended by subclasses which
 * will implement the {@link ExtendedArgument#handle} method.
 * Much like the {@link Argument} class, this class handles parsing user-specified command arguments
 * into typed command parameters. However, this class can be used to expand upon an existing
 * argument in order to process its transformed value rather than just the argument string.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { ApplyOptions } from '@sapphire/decorators';
 * import { ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions } from '@sapphire/framework';
 * import type { Channel, TextChannel } from 'discord.js';
 *
 * // Just like with `Argument`, you can use `export default` or `export =` too.
 * (at)ApplyOptions<ExtendedArgumentOptions>({
 *   name: 'textChannel',
 *   baseArgument: 'channel'
 * })
 * export class TextChannelArgument extends ExtendedArgument<'channel', TextChannel> {
 *   public handle(parsed: Channel, { argument }: ExtendedArgumentContext): Argument.Result<TextChannel> {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed as TextChannel)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel.' });
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { ExtendedArgument } = require('@sapphire/framework');
 *
 * module.exports = class TextChannelArgument extends ExtendedArgument {
 *   constructor(context) {
 *     super(context, { name: 'textChannel', baseArgument: 'channel' });
 *   }
 *
 *   handle(parsed, { argument }) {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel' });
 *   }
 * }
 * ```
 */
declare abstract class ExtendedArgument<K extends keyof ArgType, T> extends Argument<T> {
    baseArgument: K;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    constructor(context: PieceContext, options: ExtendedArgumentOptions<K>);
    /**
     * Represents the underlying argument that transforms the raw argument
     * into the value used to compute the extended argument's value.
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    get base(): IArgument<ArgType[K]>;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    run(parameter: string, context: Argument.Context<T>): Argument.AsyncResult<T>;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    abstract handle(parsed: ArgType[K], context: ExtendedArgumentContext): Argument.Result<T>;
}
/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 */
interface ExtendedArgumentOptions<K extends keyof ArgType> extends Argument.Options {
    /**
     * The name of the underlying argument whose value is used to compute
     * the extended argument value; see {@link ArgType} for valid keys.
     */
    baseArgument: K;
}
/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 */
interface ExtendedArgumentContext extends Argument.Context {
    /**
     * The canonical parameter specified by the user in the command, as
     * a string, equivalent to the first parameter of {@link Argument#run}.
     * This allows {@link ExtendedArgument#handle} to access the original
     * argument, which is useful for returning {@link Argument#error} so
     * that you don't have to convert the parsed argument back into a
     * string.
     */
    parameter: string;
}

declare const Events: {
    ChannelCreate: "channelCreate";
    ChannelDelete: "channelDelete";
    ChannelPinsUpdate: "channelPinsUpdate";
    ChannelUpdate: "channelUpdate";
    ClientReady: "ready";
    Debug: "debug";
    Error: "error";
    GuildBanAdd: "guildBanAdd";
    GuildBanRemove: "guildBanRemove";
    GuildCreate: "guildCreate";
    GuildDelete: "guildDelete";
    GuildEmojiCreate: "emojiCreate";
    GuildEmojiDelete: "emojiDelete";
    GuildEmojiUpdate: "emojiUpdate";
    GuildIntegrationsUpdate: "guildIntegrationsUpdate";
    GuildMemberAdd: "guildMemberAdd";
    GuildMemberAvailable: "guildMemberAvailable";
    GuildMemberRemove: "guildMemberRemove";
    GuildMembersChunk: "guildMembersChunk";
    GuildMemberUpdate: "guildMemberUpdate";
    GuildRoleCreate: "roleCreate";
    GuildRoleDelete: "roleDelete";
    GuildRoleUpdate: "roleUpdate";
    GuildStickerCreate: "stickerCreate";
    GuildStickerDelete: "stickerDelete";
    GuildStickerUpdate: "stickerUpdate";
    GuildUnavailable: "guildUnavailable";
    GuildUpdate: "guildUpdate";
    InteractionCreate: "interactionCreate";
    Invalidated: "invalidated";
    InvalidRequestWarning: "invalidRequestWarning";
    InviteCreate: "inviteCreate";
    InviteDelete: "inviteDelete";
    MessageBulkDelete: "messageDeleteBulk";
    MessageCreate: "messageCreate";
    MessageDelete: "messageDelete";
    MessageReactionAdd: "messageReactionAdd";
    MessageReactionRemove: "messageReactionRemove";
    MessageReactionRemoveAll: "messageReactionRemoveAll";
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji";
    MessageUpdate: "messageUpdate";
    PresenceUpdate: "presenceUpdate";
    RateLimit: "rateLimit";
    Raw: "raw";
    ShardDisconnect: "shardDisconnect";
    ShardError: "shardError";
    ShardReady: "shardReady";
    ShardReconnecting: "shardReconnecting";
    ShardResume: "shardResume";
    StageInstanceCreate: "stageInstanceCreate";
    StageInstanceDelete: "stageInstanceDelete";
    StageInstanceUpdate: "stageInstanceUpdate";
    ThreadCreate: "threadCreate";
    ThreadDelete: "threadDelete";
    ThreadListSync: "threadListSync";
    ThreadMembersUpdate: "threadMembersUpdate";
    ThreadMemberUpdate: "threadMemberUpdate";
    ThreadUpdate: "threadUpdate";
    TypingStart: "typingStart";
    UserUpdate: "userUpdate";
    VoiceServerUpdate: "voiceServerUpdate";
    VoiceStateUpdate: "voiceStateUpdate";
    Warn: "warn";
    WebhooksUpdate: "webhookUpdate";
    /**
     * Emitted when a message is created that was not sent by bots or webhooks.
     * @param {Message} message The created message
     */
    PreMessageParsed: "preMessageParsed";
    /**
     * Emitted when a message is created consisting of only the bot's mention.
     * @param {Message} message The created message
     */
    MentionPrefixOnly: "mentionPrefixOnly";
    /**
     * Emitted when a message is created that does not start with a valid prefix.
     * @param {Message} message The created message
     */
    NonPrefixedMessage: "nonPrefixedMessage";
    /**
     * Emitted when a message is created that does starts with a valid prefix.
     * @param {Message} message The created message
     */
    PrefixedMessage: "prefixedMessage";
    /**
     * Emitted when a message starts with a valid prefix but does not include a command name.
     * @param {UnknownMessageCommandNamePayload} payload
     */
    UnknownMessageCommandName: "unknownMessageCommandName";
    /**
     * Emitted when the name of a sent message command does not match any loaded commands.
     * @param {UnknownMessageCommandPayload} payload The contextual payload
     */
    UnknownMessageCommand: "unknownMessageCommand";
    /**
     * Emitted when a message command is executed but a `messageRun` method is not found.
     * @param {CommandDoesNotHaveMessageCommandHandler} payload The contextual payload
     */
    CommandDoesNotHaveMessageCommandHandler: "commandDoesNotHaveMessageCommandHandler";
    /**
     * Emitted before the `messageRun` method of a command is run.
     * @param {PreMessageCommandRunPayload} payload The contextual payload
     */
    PreMessageCommandRun: "preMessageCommandRun";
    /**
     * Emitted when a precondition denies a message command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {MessageCommandDeniedPayload} payload The contextual payload
     */
    MessageCommandDenied: "messageCommandDenied";
    /**
     * Emitted when a message command passes all precondition checks, if any.
     * @param {MessageCommandAcceptedPayload} payload The contextual payload
     */
    MessageCommandAccepted: "messageCommandAccepted";
    /**
     * Emitted directly before a message command is run.
     * @param {Message} message The message that executed the command
     * @param {Command} command The command that is being run
     * @param {MessageCommandRunPayload} payload The contextual payload
     */
    MessageCommandRun: "messageCommandRun";
    /**
     * Emitted after a message command runs successfully.
     * @param {MessageCommandSuccessPayload} payload The contextual payload
     */
    MessageCommandSuccess: "messageCommandSuccess";
    /**
     * Emitted after a message command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {MessageCommandErrorPayload} payload The contextual payload
     */
    MessageCommandError: "messageCommandError";
    /**
     * Emitted directly after a message command finished running, regardless of the outcome.
     * @param {Message} message The message that executed the command
     * @param {Command} command The command that finished running
     * @param {MessageCommandFinishPayload} payload The contextual payload
     */
    MessageCommandFinish: "messageCommandFinish";
    /**
     * Emitted after the bot unsuccessfully tried to start typing when a command is executed.
     * @param error The error that was thrown
     * @param payload The contextual payload
     */
    MessageCommandTypingError: "messageCommandTypingError";
    /**
     * Emitted when an error is encountered when executing a listener.
     * @param {*} error The error that was thrown
     * @param {ListenerErrorPayload} payload The contextual payload
     */
    ListenerError: "listenerError";
    /**
     * Emitted when an error is encountered when handling the command application command registry.
     * @param {*} error The error that was thrown
     * @param {Command} command The command who's registry caused the error
     */
    CommandApplicationCommandRegistryError: "commandApplicationCommandRegistryError";
    /**
     * Emitted after a piece is loaded.
     * @param {Store<Piece>} store The store in which the piece belongs to
     * @param {Piece} piece The piece that was loaded
     */
    PiecePostLoad: "piecePostLoad";
    /**
     * Emitted when a piece is unloaded.
     * @param {Store<Piece>} store The store in which the piece belongs to
     * @param {Piece} piece The piece that was unloaded
     */
    PieceUnload: "pieceUnload";
    /**
     * Emitted when a plugin is loaded.
     * @param {PluginHook} hook The plugin hook that was loaded
     * @param {string | undefined} name The name of the plugin, if any
     */
    PluginLoaded: "pluginLoaded";
    /**
     * Emitted when the `parse` method of an interaction handler encounters an error.
     * @param {*} error The error that was encountered
     * @param {InteractionHandlerParseError} payload The contextual payload
     */
    InteractionHandlerParseError: "interactionHandlerParseError";
    /**
     * Emitted when an error is encountered when executing an interaction handler.
     * @param {*} error The error that was encountered
     * @param {InteractionHandlerError} payload The contextual payload
     */
    InteractionHandlerError: "interactionHandlerError";
    /**
     * Emitted when an autocomplete interaction is recieved.
     * @param {AutocompleteInteraction} interaction The interaction that was recieved
     */
    PossibleAutocompleteInteraction: "possibleAutocompleteInteraction";
    /**
     * Emitted after an autocomplete interaction handler runs successfully.
     * @param {AutocompleteInteractionPayload} payload The contextual payload
     */
    CommandAutocompleteInteractionSuccess: "commandAutocompleteInteractionSuccess";
    /**
     * Emitted when an error is encountered when executing an autocomplete interaction handler.
     * @param {*} error The error that was encountered
     * @param {AutocompleteInteractionPayload} payload The contextual payload
     */
    CommandAutocompleteInteractionError: "commandAutocompleteInteractionError";
    /**
     * Emitted when a chat input command interaction is recieved.
     * @param {CommandInteraction} interaction The interaction that was recieved.
     */
    PossibleChatInputCommand: "possibleChatInputCommand";
    /**
     * Emitted when the name of a sent chat input command does not match any loaded commands.
     * @param {UnknownChatInputCommandPayload} payload The contextual payload
     */
    UnknownChatInputCommand: "unknownChatInputCommand";
    /**
     * Emitted when a chat input command is executed but a `chatInputRun` method is not found.
     * @param {CommandDoesNotHaveChatInputCommandHandlerPayload} payload The contextual payload
     */
    CommandDoesNotHaveChatInputCommandHandler: "commandDoesNotHaveChatInputCommandHandler";
    /**
     * Emitted before the `chatInputRun` method of a command is run.
     * @param {PreChatInputCommandRunPayload} payload The contextual payload
     */
    PreChatInputCommandRun: "preChatInputCommandRun";
    /**
     * Emitted when a precondition denies a chat input command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {ChatInputCommandDeniedPayload} payload The contextual payload
     */
    ChatInputCommandDenied: "chatInputCommandDenied";
    /**
     * Emitted when a chat input command passes all precondition checks, if any.
     * @param {ChatInputCommandAcceptedPayload} payload The contextual payload
     */
    ChatInputCommandAccepted: "chatInputCommandAccepted";
    /**
     * Emitted directly before a chat input command is run.
     * @param {CommandInteraction} interaction The interaction that executed the command
     * @param {ChatInputCommand} command The command that is being run
     * @param {ChatInputCommandRunPayload} payload The contextual payload
     */
    ChatInputCommandRun: "chatInputCommandRun";
    /**
     * Emitted after a chat input command runs successfully.
     * @param {ChatInputCommandSuccessPayload} payload The contextual payload
     */
    ChatInputCommandSuccess: "chatInputCommandSuccess";
    /**
     * Emitted after a chat input command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {ChatInputCommandErrorPayload} payload The contextual payload
     */
    ChatInputCommandError: "chatInputCommandError";
    /**
     * Emitted directly after a chat input command finished running, regardless of the outcome.
     * @param {Interaction} interaction The interaction that executed the command
     * @param {ChatInputCommand} command The command that finished running
     * @param {ChatInputCommandFinishPayload} payload The contextual payload
     */
    ChatInputCommandFinish: "chatInputCommandFinish";
    /**
     * Emitted when a context menu interaction is recieved.
     * @param {ContextMenuInteraction} interaction The interaction that was recieved.
     */
    PossibleContextMenuCommand: "possibleContextMenuCommand";
    /**
     * Emitted when the name of a sent context menu command does not match any loaded commands.
     * @param {UnknownContextMenuCommandPayload} payload The contextual payload
     */
    UnknownContextMenuCommand: "unknownContextMenuCommand";
    /**
     * Emitted when a chat input command is executed but a `contextMenuRun` method is not found.
     * @param {CommandDoesNotHaveContextMenuCommandHandlerPayload} payload The contextual payload
     */
    CommandDoesNotHaveContextMenuCommandHandler: "commandDoesNotHaveContextMenuCommandHandler";
    /**
     * Emitted before the `contextMenuRun` method of a command is run.
     * @param {PreContextMenuCommandRunPayload} payload The contextual payload
     */
    PreContextMenuCommandRun: "preContextMenuCommandRun";
    /**
     * Emitted when a precondition denies a context menu command from being run.
     * @param {UserError} error The error reported by the precondition
     * @param {ContextMenuCommandDeniedPayload} payload The contextual payload
     */
    ContextMenuCommandDenied: "contextMenuCommandDenied";
    /**
     * Emitted when a context menu command passes all precondition checks, if any.
     * @param {ContextMenuCommandAcceptedPayload} payload The contextual payload
     */
    ContextMenuCommandAccepted: "contextMenuCommandAccepted";
    /**
     * Emitted directly before a context menu command is run.
     * @param {ContextMenuInteraction} interaction The interaction that executed the command
     * @param {ContextMenuCommand} command The command that is being run
     * @param {ContextMenuCommandRunPayload} payload The contextual payload
     */
    ContextMenuCommandRun: "contextMenuCommandRun";
    /**
     * Emitted after a context menu command runs successfully.
     * @param {ContextMenuCommandSuccessPayload} payload The contextual payload
     */
    ContextMenuCommandSuccess: "contextMenuCommandSuccess";
    /**
     * Emitted after a context menu command runs unsuccesfully.
     * @param {*} error The error that was thrown
     * @param {ContextMenuCommandErrorPayload} payload The contextual payload
     */
    ContextMenuCommandError: "contextMenuCommandError";
    /**
     * Emitted directly after a context menu command finished running, regardless of the outcome.
     * @param {Interaction} interaction The interaction that executed the command
     * @param {ContextMenuCommand} command The command that finished running
     * @param {ContextMenuCommandFinishPayload} payload The contextual payload
     */
    ContextMenuCommandFinish: "contextMenuCommandFinish";
};
interface IPieceError {
    piece: Piece;
}
interface ListenerErrorPayload extends IPieceError {
    piece: Listener;
}
interface UnknownMessageCommandNamePayload {
    message: Message;
    prefix: string | RegExp;
    commandPrefix: string;
}
interface CommandDoesNotHaveMessageCommandHandler {
    message: Message;
    prefix: string | RegExp;
    commandPrefix: string;
    command: Command;
}
interface UnknownMessageCommandPayload extends UnknownMessageCommandNamePayload {
    commandName: string;
}
interface IMessageCommandPayload {
    message: Message;
    command: MessageCommand;
}
interface PreMessageCommandRunPayload extends MessageCommandDeniedPayload {
}
interface MessageCommandDeniedPayload extends IMessageCommandPayload {
    parameters: string;
    context: MessageCommand.RunContext;
}
interface MessageCommandAcceptedPayload extends IMessageCommandPayload {
    parameters: string;
    context: MessageCommand.RunContext;
}
interface MessageCommandRunPayload extends MessageCommandAcceptedPayload {
    args: unknown;
}
interface MessageCommandFinishPayload extends MessageCommandRunPayload {
    duration: number;
}
interface MessageCommandErrorPayload extends MessageCommandRunPayload {
    duration: number;
}
interface MessageCommandSuccessPayload extends MessageCommandRunPayload {
    result: unknown;
    duration: number;
}
interface MessageCommandTypingErrorPayload extends MessageCommandRunPayload {
}
interface UnknownChatInputCommandPayload {
    interaction: CommandInteraction;
    context: ChatInputCommandContext;
}
interface CommandDoesNotHaveChatInputCommandHandlerPayload {
    interaction: CommandInteraction;
    command: Command;
    context: ChatInputCommandContext;
}
interface IChatInputCommandPayload {
    interaction: CommandInteraction;
    command: ChatInputCommand;
}
interface PreChatInputCommandRunPayload extends IChatInputCommandPayload {
    context: ChatInputCommandContext;
}
interface ChatInputCommandDeniedPayload extends IChatInputCommandPayload {
    context: ChatInputCommandContext;
}
interface ChatInputCommandAcceptedPayload extends PreChatInputCommandRunPayload {
}
interface ChatInputCommandRunPayload extends ChatInputCommandAcceptedPayload {
}
interface ChatInputCommandFinishPayload extends ChatInputCommandAcceptedPayload {
    duration: number;
}
interface ChatInputCommandSuccessPayload extends ChatInputCommandRunPayload {
    result: unknown;
    duration: number;
}
interface ChatInputCommandErrorPayload extends IChatInputCommandPayload {
    duration: number;
}
interface UnknownContextMenuCommandPayload {
    interaction: ContextMenuInteraction;
    context: ContextMenuCommandContext;
}
interface CommandDoesNotHaveContextMenuCommandHandlerPayload {
    interaction: ContextMenuInteraction;
    context: ContextMenuCommandContext;
    command: Command;
}
interface IContextMenuCommandPayload {
    interaction: ContextMenuInteraction;
    command: ContextMenuCommand;
}
interface PreContextMenuCommandRunPayload extends IContextMenuCommandPayload {
    context: ContextMenuCommandContext;
}
interface ContextMenuCommandDeniedPayload extends IContextMenuCommandPayload {
    context: ContextMenuCommandContext;
}
interface ContextMenuCommandAcceptedPayload extends PreContextMenuCommandRunPayload {
}
interface ContextMenuCommandRunPayload extends ContextMenuCommandAcceptedPayload {
}
interface ContextMenuCommandFinishPayload extends ContextMenuCommandAcceptedPayload {
    duration: number;
}
interface ContextMenuCommandSuccessPayload extends ContextMenuCommandRunPayload {
    result: unknown;
    duration: number;
}
interface ContextMenuCommandErrorPayload extends IContextMenuCommandPayload {
    duration: number;
}
interface IInteractionHandlerPayload {
    interaction: Interaction;
    handler: InteractionHandler;
}
interface InteractionHandlerParseError extends IInteractionHandlerPayload {
}
interface InteractionHandlerError extends IInteractionHandlerPayload {
}
interface AutocompleteInteractionPayload {
    interaction: AutocompleteInteraction;
    command: AutocompleteCommand;
    context: AutocompleteCommandContext;
}
declare module 'discord.js' {
    interface ClientEvents {
        [Events.PieceUnload]: [store: Store<Piece>, piece: Piece];
        [Events.PiecePostLoad]: [store: Store<Piece>, piece: Piece];
        [Events.ListenerError]: [error: unknown, payload: ListenerErrorPayload];
        [Events.CommandApplicationCommandRegistryError]: [error: unknown, command: Command];
        [Events.PreMessageParsed]: [message: Message];
        [Events.MentionPrefixOnly]: [message: Message];
        [Events.NonPrefixedMessage]: [message: Message];
        [Events.PrefixedMessage]: [message: Message, prefix: string | RegExp];
        [Events.UnknownMessageCommandName]: [payload: UnknownMessageCommandNamePayload];
        [Events.UnknownMessageCommand]: [payload: UnknownMessageCommandPayload];
        [Events.CommandDoesNotHaveMessageCommandHandler]: [payload: CommandDoesNotHaveMessageCommandHandler];
        [Events.PreMessageCommandRun]: [payload: PreMessageCommandRunPayload];
        [Events.MessageCommandDenied]: [error: UserError, payload: MessageCommandDeniedPayload];
        [Events.MessageCommandAccepted]: [payload: MessageCommandAcceptedPayload];
        [Events.MessageCommandRun]: [message: Message, command: Command, payload: MessageCommandRunPayload];
        [Events.MessageCommandSuccess]: [payload: MessageCommandSuccessPayload];
        [Events.MessageCommandError]: [error: unknown, payload: MessageCommandErrorPayload];
        [Events.MessageCommandFinish]: [message: Message, command: Command, payload: MessageCommandFinishPayload];
        [Events.MessageCommandTypingError]: [error: Error, payload: MessageCommandTypingErrorPayload];
        [Events.PluginLoaded]: [hook: PluginHook, name: string | undefined];
        [Events.InteractionHandlerParseError]: [error: unknown, payload: InteractionHandlerParseError];
        [Events.InteractionHandlerError]: [error: unknown, payload: InteractionHandlerError];
        [Events.PossibleAutocompleteInteraction]: [interaction: AutocompleteInteraction];
        [Events.CommandAutocompleteInteractionError]: [error: unknown, payload: AutocompleteInteractionPayload];
        [Events.CommandAutocompleteInteractionSuccess]: [payload: AutocompleteInteractionPayload];
        [Events.PossibleChatInputCommand]: [interaction: CommandInteraction];
        [Events.UnknownChatInputCommand]: [payload: UnknownChatInputCommandPayload];
        [Events.CommandDoesNotHaveChatInputCommandHandler]: [payload: CommandDoesNotHaveChatInputCommandHandlerPayload];
        [Events.PreChatInputCommandRun]: [payload: PreChatInputCommandRunPayload];
        [Events.ChatInputCommandDenied]: [error: UserError, payload: ChatInputCommandDeniedPayload];
        [Events.ChatInputCommandAccepted]: [payload: ChatInputCommandAcceptedPayload];
        [Events.ChatInputCommandRun]: [interaction: CommandInteraction, command: ChatInputCommand, payload: ChatInputCommandRunPayload];
        [Events.ChatInputCommandSuccess]: [payload: ChatInputCommandSuccessPayload];
        [Events.ChatInputCommandError]: [error: unknown, payload: ChatInputCommandErrorPayload];
        [Events.ChatInputCommandFinish]: [interaction: CommandInteraction, command: ChatInputCommand, payload: ChatInputCommandFinishPayload];
        [Events.PossibleContextMenuCommand]: [interaction: ContextMenuInteraction];
        [Events.UnknownContextMenuCommand]: [payload: UnknownContextMenuCommandPayload];
        [Events.CommandDoesNotHaveContextMenuCommandHandler]: [payload: CommandDoesNotHaveContextMenuCommandHandlerPayload];
        [Events.PreContextMenuCommandRun]: [payload: PreContextMenuCommandRunPayload];
        [Events.ContextMenuCommandDenied]: [error: UserError, payload: ContextMenuCommandDeniedPayload];
        [Events.ContextMenuCommandAccepted]: [payload: ContextMenuCommandAcceptedPayload];
        [Events.ContextMenuCommandRun]: [interaction: ContextMenuInteraction, command: ContextMenuCommand, payload: ContextMenuCommandRunPayload];
        [Events.ContextMenuCommandSuccess]: [payload: ContextMenuCommandSuccessPayload];
        [Events.ContextMenuCommandError]: [error: unknown, payload: ContextMenuCommandErrorPayload];
        [Events.ContextMenuCommandFinish]: [
            interaction: ContextMenuInteraction,
            command: ContextMenuCommand,
            payload: ContextMenuCommandFinishPayload
        ];
        [K: string]: unknown[];
    }
}

declare class Logger implements ILogger {
    level: LogLevel;
    constructor(level: LogLevel);
    has(level: LogLevel): boolean;
    trace(...values: readonly unknown[]): void;
    debug(...values: readonly unknown[]): void;
    info(...values: readonly unknown[]): void;
    warn(...values: readonly unknown[]): void;
    error(...values: readonly unknown[]): void;
    fatal(...values: readonly unknown[]): void;
    write(level: LogLevel, ...values: readonly unknown[]): void;
    protected static readonly levels: Map<LogLevel, LogMethods>;
}
declare type LogMethods = 'trace' | 'debug' | 'info' | 'warn' | 'error';

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionAnd: IPreconditionCondition;

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 || V1 [|| V2 [|| V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionOr: IPreconditionCondition;

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: PieceContext) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new ClientPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class ClientPermissionsPrecondition implements PreconditionSingleResolvableDetails<'ClientPermissions'> {
    name: 'ClientPermissions';
    context: {
        permissions: Permissions;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: PieceContext) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new UserPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class UserPermissionsPrecondition implements PreconditionSingleResolvableDetails<'UserPermissions'> {
    name: 'UserPermissions';
    context: {
        permissions: Permissions;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

declare const ApplicationCommandRegistries: {
    acquire: typeof acquire;
    setDefaultBehaviorWhenNotIdentical: typeof setDefaultBehaviorWhenNotIdentical;
    getDefaultBehaviorWhenNotIdentical: typeof getDefaultBehaviorWhenNotIdentical;
    readonly registries: ReadonlyMap<string, ApplicationCommandRegistry>;
};

declare const CorePreconditions: {
    ClientPermissions: typeof CorePrecondition$b;
    Cooldown: typeof CorePrecondition$c;
    DMOnly: typeof CorePrecondition$a;
    Enabled: typeof CorePrecondition$9;
    GuildNewsOnly: typeof CorePrecondition$8;
    GuildNewsThreadOnly: typeof CorePrecondition$7;
    GuildOnly: typeof CorePrecondition$6;
    GuildPrivateThreadOnly: typeof CorePrecondition$5;
    GuildPublicThreadOnly: typeof CorePrecondition$4;
    GuildTextOnly: typeof CorePrecondition$3;
    GuildThreadOnly: typeof CorePrecondition$2;
    NSFW: typeof CorePrecondition$1;
    UserPermissions: typeof CorePrecondition;
};
declare namespace CorePreconditions {
    type UserPermissionsPreconditionContext = PermissionPreconditionContext;
    type CooldownContext = CooldownPreconditionContext;
}
/**
 * The [@sapphire/framework](https://github.com/sapphiredev/framework) version that you are currently using.
 * An example use of this is showing it of in a bot information command.
 *
 * Note to Sapphire developers: This needs to explicitly be `string` so it is not typed as the string that gets replaced by Rollup
 */
declare const version: string;

export { AllFlowsPrecondition, ApplicationCommandRegistries, ApplicationCommandRegistry, ApplicationCommandRegistryRegisterOptions, ArgOptions, ArgType, Args, ArgsNextCallback, Argument, ArgumentContext, ArgumentError, ArgumentOptions, ArgumentResult, ArgumentStore, AsyncArgumentResult, AsyncPluginHooks, AsyncPreconditionContainerReturn, AsyncPreconditionResult, AutocompleteCommand, AutocompleteCommandContext, AutocompleteInteractionPayload, BucketScope, ChatInputCommand, ChatInputCommandAcceptedPayload, ChatInputCommandContext, ChatInputCommandDeniedPayload, ChatInputCommandErrorPayload, ChatInputCommandFinishPayload, ChatInputCommandRunPayload, ChatInputCommandSuccessPayload, ClientLoggerOptions, ClientPermissionsPrecondition, Command, CommandChatInputRegisterShortcut, CommandDoesNotHaveChatInputCommandHandlerPayload, CommandDoesNotHaveContextMenuCommandHandlerPayload, CommandDoesNotHaveMessageCommandHandler, CommandJSON, CommandOptions, CommandOptionsRunType, CommandOptionsRunTypeEnum, CommandPreConditions, CommandStore, ContextMenuCommand, ContextMenuCommandAcceptedPayload, ContextMenuCommandContext, ContextMenuCommandDeniedPayload, ContextMenuCommandErrorPayload, ContextMenuCommandFinishPayload, ContextMenuCommandRunPayload, ContextMenuCommandSuccessPayload, CooldownLevel, CooldownOptions, CorePreconditions, DetailedDescriptionCommand, DetailedDescriptionCommandObject, Events, ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions, IArgument, IChatInputCommandPayload, IContextMenuCommandPayload, IInteractionHandlerPayload, ILogger, IMessageCommandPayload, IPieceError, IPreconditionCondition, IPreconditionContainer, Identifiers, InteractionHandler, InteractionHandlerError, InteractionHandlerFilters, InteractionHandlerJSON, InteractionHandlerOptions, InteractionHandlerParseError, InteractionHandlerParseResult, InteractionHandlerStore, InteractionHandlerTypes, InternalRegistryAPIType, Listener, ListenerErrorPayload, ListenerJSON, ListenerOptions, ListenerStore, LogLevel, LogMethods, Logger, MessageCommand, MessageCommandAcceptedPayload, MessageCommandContext, MessageCommandDeniedPayload, MessageCommandErrorPayload, MessageCommandFinishPayload, MessageCommandRunPayload, MessageCommandSuccessPayload, MessageCommandTypingErrorPayload, Plugin, PluginHook, PluginManager, PreChatInputCommandRunPayload, PreContextMenuCommandRunPayload, PreMessageCommandRunPayload, Precondition, PreconditionArrayResolvable, PreconditionArrayResolvableDetails, PreconditionConditionAnd, PreconditionConditionOr, PreconditionContainerArray, PreconditionContainerResult, PreconditionContainerReturn, PreconditionContainerSingle, PreconditionContext, PreconditionEntryResolvable, PreconditionError, PreconditionKeys, PreconditionOptions, PreconditionResult, PreconditionRunCondition, PreconditionRunMode, PreconditionSingleResolvable, PreconditionSingleResolvableDetails, PreconditionStore, Preconditions, RegisterBehavior, RepeatArgOptions, index_d as Resolvers, SapphireClient, SapphireClientOptions, SapphirePluginAsyncHook, SapphirePluginHook, SapphirePluginHookEntry, SapphirePrefix, SapphirePrefixHook, SimplePreconditionKeys, SimplePreconditionSingleResolvableDetails, SyncPluginHooks, UnknownChatInputCommandPayload, UnknownContextMenuCommandPayload, UnknownMessageCommandNamePayload, UnknownMessageCommandPayload, UserError, UserPermissionsPrecondition, postInitialization, postLogin, preGenericsInitialization, preInitialization, preLogin, version };
