/// <reference types="node" />
import { Piece, AliasPiece, AliasPieceJSON, PieceContext, AliasStore, Store, StoreRegistry } from '@sapphire/pieces';
export { AliasPiece, AliasPieceOptions, AliasStore, LoaderError, MissingExportsError, Piece, PieceContext, PieceOptions, Store, StoreOptions, StoreRegistry, StoreRegistryEntries, container } from '@sapphire/pieces';
import { Awaitable, NonNullObject } from '@sapphire/utilities';
export { Awaitable } from '@sapphire/utilities';
import { Snowflake, Message, Permissions, Collection, PermissionResolvable, DMChannel, CategoryChannel, NewsChannel, ThreadChannel, TextChannel, StageChannel, VoiceChannel, GuildMember, Role, User, ClientOptions, Client, ClientEvents, Guild, PartialDMChannel, PermissionString } from 'discord.js';
import * as Lexure from 'lexure';
import { option } from 'lexure';
import { EventEmitter } from 'events';
import { RateLimitManager } from '@sapphire/ratelimits';
import { ChannelTypes, GuildBasedChannelTypes, TextBasedChannelTypes } from '@sapphire/discord.js-utilities';
import { URL } from 'url';

/**
 * The UserError class to be emitted in the pieces.
 * @property name This will be `'UserError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class UserError extends Error {
    /**
     * An identifier, useful to localize emitted errors.
     */
    readonly identifier: string;
    /**
     * User-provided context.
     */
    readonly context: unknown;
    /**
     * Constructs an UserError.
     * @param type The identifier, useful to localize emitted errors.
     * @param message The error message.
     */
    constructor(options: UserError.Options);
    get name(): string;
}
declare namespace UserError {
    /**
     * The options for {@link UserError}.
     * @since 1.0.0
     */
    interface Options {
        /**
         * The identifier for this error.
         * @since 1.0.0
         */
        identifier: string;
        /**
         * The message to be passed to the Error constructor.
         * @since 1.0.0
         */
        message?: string;
        /**
         * The extra context to provide more information about this error.
         * @since 1.0.0
         * @default null
         */
        context?: unknown;
    }
}

declare const enum CooldownLevel {
    Author = "author",
    Channel = "channel",
    Guild = "guild"
}
declare const enum PluginHook {
    PreGenericsInitialization = "preGenericsInitialization",
    PreInitialization = "preInitialization",
    PostInitialization = "postInitialization",
    PreLogin = "preLogin",
    PostLogin = "postLogin"
}
/**
 * The scope the cooldown applies to.
 */
declare const enum BucketScope {
    /**
     * Per channel cooldowns.
     */
    Channel = 0,
    /**
     * Global cooldowns.
     */
    Global = 1,
    /**
     * Per guild cooldowns.
     */
    Guild = 2,
    /**
     * Per user cooldowns.
     */
    User = 3
}

interface CooldownContext extends PreconditionContext {
    scope?: BucketScope;
    delay: number;
    limit?: number;
    filteredUsers?: Snowflake[];
}
declare class CorePrecondition$c extends Precondition {
    buckets: WeakMap<Command<Args, CommandOptions>, RateLimitManager<string>>;
    run(message: Message, command: Command, context: CooldownContext): PreconditionResult;
    private getId;
    private getManager;
}

/**
 * Errors thrown by preconditions
 * @property name This will be `'PreconditionError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class PreconditionError extends UserError {
    readonly precondition: Precondition;
    constructor(options: PreconditionError.Options);
    get name(): string;
}
declare namespace PreconditionError {
    /**
     * The options for {@link PreconditionError}.
     * @since 1.0.0
     */
    interface Options extends Omit<UserError.Options, 'identifier'> {
        /**
         * The precondition that caused the error.
         * @since 1.0.0
         */
        precondition: Precondition;
        /**
         * The identifier.
         * @since 1.0.0
         * @default precondition.name
         */
        identifier?: string;
    }
}

/**
 * A type used to express computations that can fail.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
declare type Result<T, E> = Ok<T> | Err<E>;
/**
 * The computation is successful.
 * @typeparam T Type of results.
 */
declare type Ok<T> = Lexure.Ok<T>;
/**
 * The computation failed.
 * @typeparam E Type of errors.
 */
declare type Err<E> = Lexure.Err<E>;
/**
 * Creates an Ok with no value.
 * @return A successful Result.
 */
declare function ok(): Ok<unknown>;
/**
 * Creates an Ok.
 * @typeparam T The result's type.
 * @param x Value to use.
 * @return A successful Result.
 */
declare function ok<T>(x: T): Ok<T>;
/**
 * Creates an Err with no error.
 * @return An erroneous Result.
 */
declare function err(): Err<unknown>;
/**
 * Creates an Err.
 * @typeparam E The error's type.
 * @param x Value to use.
 * @return An erroneous Result.
 */
declare function err<E>(x: E): Err<E>;
/**
 * Determines whether or not a result is an Ok.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
declare function isOk<T, E>(x: Result<T, E>): x is Ok<T>;
/**
 * Determines whether or not a result is an Err.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
declare function isErr<T, E>(x: Result<T, E>): x is Err<E>;
/**
 * Creates a {@link Result} out of a callback.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
declare function from<T, E = unknown>(cb: (...args: unknown[]) => T): Result<T, E>;
/**
 * Creates a {@link Result} out of a promise or async callback.
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 */
declare function fromAsync<T, E = unknown>(promiseOrCb: Awaitable<T> | ((...args: unknown[]) => Awaitable<T>)): Promise<Result<T, E>>;

declare type PreconditionResult = Awaitable<Result<unknown, UserError>>;
declare type AsyncPreconditionResult = Promise<Result<unknown, UserError>>;
/**
 * The registered preconditions and their contexts, if any. When registering new ones, it is recommended to use
 * [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation) so
 * custom ones are registered.
 *
 * When a key's value is `never`, it means that it does not take any context, which allows you to pass its identifier as
 * a bare string (e.g. `preconditions: ['NSFW']`), however, if context is required, a non-`never` type should be passed,
 * which will type {@link PreconditionContainerArray#append} and require an object with the name and a `context` with
 * the defined type.
 *
 * @example
 * ```typescript
 * declare module '@sapphire/framework' {
 *   interface Preconditions {
 *     // A precondition named `Moderator` which does not read `context`:
 *     Moderator: never;
 *
 *     // A precondition named `ChannelPermissions` which does read `context`:
 *     ChannelPermissions: {
 *       permissions: Permissions;
 *     };
 *   }
 * }
 *
 * // [✔] These are valid:
 * preconditions.append('Moderator');
 * preconditions.append({ name: 'Moderator' });
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { permissions: new Permissions(8) }
 * });
 *
 * // [X] These are invalid:
 * preconditions.append({ name: 'Moderator', context: {} });
 * // ➡ `never` keys do not accept `context`.
 *
 * preconditions.append('ChannelPermissions');
 * // ➡ non-`never` keys always require `context`, a string cannot be used.
 *
 * preconditions.append({
 *   name: 'ChannelPermissions',
 *   context: { unknownProperty: 1 }
 * });
 * // ➡ mismatching `context` properties, `{ unknownProperty: number }` is not
 * // assignable to `{ permissions: Permissions }`.
 * ```
 */
interface Preconditions {
    Cooldown: CooldownContext;
    DMOnly: never;
    Enabled: never;
    GuildNewsOnly: never;
    GuildNewsThreadOnly: never;
    GuildOnly: never;
    GuildPrivateThreadOnly: never;
    GuildPublicThreadOnly: never;
    GuildTextOnly: never;
    GuildThreadOnly: never;
    NSFW: never;
    ClientPermissions: {
        permissions: Permissions;
    };
    UserPermissions: {
        permissions: Permissions;
    };
}
declare type PreconditionKeys = keyof Preconditions;
declare type SimplePreconditionKeys = {
    [K in PreconditionKeys]: Preconditions[K] extends never ? K : never;
}[PreconditionKeys];
interface PreconditionOptions extends Piece.Options {
    /**
     * The position for the precondition to be set at in the global precondition list. If set to `null`, this
     * precondition will not be set as a global one.
     * @default null
     */
    position?: number | null;
}
interface PreconditionContext extends Record<PropertyKey, unknown> {
    external?: boolean;
}
declare abstract class Precondition<O extends PreconditionOptions = PreconditionOptions> extends Piece<O> {
    readonly position: number | null;
    constructor(context: Piece.Context, options?: Precondition.Options);
    abstract run(message: Message, command: Command, context: Precondition.Context): Precondition.Result;
    ok(): Precondition.Result;
    /**
     * Constructs a {@link PreconditionError} with the precondition parameter set to `this`.
     * @param options The information.
     */
    error(options?: Omit<PreconditionError.Options, 'precondition'>): Precondition.Result;
}
declare namespace Precondition {
    type Options = PreconditionOptions;
    type Context = PreconditionContext;
    type Result = PreconditionResult;
    type AsyncResult = AsyncPreconditionResult;
}

/**
 * Defines the result's value for a PreconditionContainer.
 * @since 1.0.0
 */
declare type PreconditionContainerResult = Result<unknown, UserError>;
/**
 * Defines the return type of the generic {@link IPreconditionContainer.run}.
 * @since 1.0.0
 */
declare type PreconditionContainerReturn = Awaitable<PreconditionContainerResult>;
/**
 * Async-only version of {@link PreconditionContainerReturn}, to be used when the run method is async.
 * @since 1.0.0
 */
declare type AsyncPreconditionContainerReturn = Promise<PreconditionContainerResult>;
/**
 * An abstracted precondition container to be implemented by classes.
 * @since 1.0.0
 */
interface IPreconditionContainer {
    /**
     * Runs a precondition container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    run(message: Message, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
}

/**
 * Defines the condition for {@link PreconditionContainerArray}s to run.
 * @since 1.0.0
 */
interface IPreconditionCondition {
    /**
     * Runs the containers one by one.
     * @seealso {@link PreconditionRunMode.sequential}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     */
    sequential(message: Message, command: Command, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
    /**
     * Runs all the containers using `Promise.all`, then checks the results once all tasks finished running.
     * @seealso {@link PreconditionRunMode.parallel}
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     * @param entries The containers to run.
     */
    parallel(message: Message, command: Command, entries: readonly IPreconditionContainer[], context: PreconditionContext): PreconditionContainerReturn;
}

/**
 * Defines the simple options for the {@link PreconditionContainerSingle}, where only the name of the precondition can
 * be defined.
 * @since 2.0.0
 */
interface SimplePreconditionSingleResolvableDetails {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 2.0.0
     */
    name: SimplePreconditionKeys;
}
/**
 * Defines the detailed options for the {@link PreconditionContainerSingle}, where both the {@link PreconditionContext} and the
 * name of the precondition can be defined.
 * @since 1.0.0
 */
interface PreconditionSingleResolvableDetails<K extends PreconditionKeys = PreconditionKeys> {
    /**
     * The name of the precondition to retrieve from {@link SapphireClient.preconditions}.
     * @since 1.0.0
     */
    name: K;
    /**
     * The context to be set at {@link PreconditionContainerSingle.context}.
     * @since 1.0.0
     */
    context: Preconditions[K];
}
/**
 * Defines the data accepted by {@link PreconditionContainerSingle}'s constructor.
 * @since 1.0.0
 */
declare type PreconditionSingleResolvable = SimplePreconditionKeys | SimplePreconditionSingleResolvableDetails | PreconditionSingleResolvableDetails;
/**
 * An {@link IPreconditionContainer} which runs a single precondition from {@link SapphireClient.preconditions}.
 * @since 1.0.0
 */
declare class PreconditionContainerSingle implements IPreconditionContainer {
    /**
     * The context to be used when calling {@link Precondition.run}. This will always be an empty object (`{}`) when the
     * container was constructed with a string, otherwise it is a direct reference to the value from
     * {@link PreconditionSingleResolvableDetails.context}.
     * @since 1.0.0
     */
    readonly context: Record<PropertyKey, unknown>;
    /**
     * The name of the precondition to run.
     * @since 1.0.0
     */
    readonly name: string;
    constructor(data: PreconditionSingleResolvable);
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    run(message: Message, command: Command, context?: PreconditionContext): PreconditionResult;
}

/**
 * The run mode for a {@link PreconditionContainerArray}.
 * @since 1.0.0
 */
declare const enum PreconditionRunMode {
    /**
     * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous
     * tasks, but is performance savvy.
     * @since 1.0.0
     */
    Sequential = 0,
    /**
     * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have
     * completed.
     * @since 1.0.0
     */
    Parallel = 1
}
/**
 * The condition for a {@link PreconditionContainerArray}.
 */
declare enum PreconditionRunCondition {
    /**
     * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.
     * @since 1.0.0
     */
    And = 0,
    /**
     * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.
     * @since 1.0.0
     */
    Or = 1
}
/**
 * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the
 * entries can be defined.
 * @since 1.0.0
 */
interface PreconditionArrayResolvableDetails {
    /**
     * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.
     * @since 1.0.0
     */
    entries: readonly PreconditionEntryResolvable[];
    /**
     * The mode the {@link PreconditionContainerArray} will run.
     * @since 1.0.0
     */
    mode: PreconditionRunMode;
}
/**
 * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.
 * @since 1.0.0
 */
declare type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;
/**
 * Defines the data accepted for each entry of the array.
 * @since 1.0.0
 * @seealso {@link PreconditionArrayResolvable}
 * @seealso {@link PreconditionArrayResolvableDetails.entries}
 */
declare type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;
/**
 * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.
 *
 * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level
 * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).
 *
 * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:
 * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.
 * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.
 * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.
 *
 * In other words, it is identical to doing:
 * ```typescript
 * Connect && (Moderator || (DJ && SongAuthor));
 * ```
 * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),
 * see {@link PreconditionContainerArray.conditions} for more information.
 * @since 1.0.0
 */
declare class PreconditionContainerArray implements IPreconditionContainer {
    /**
     * The mode at which this precondition will run.
     * @since 1.0.0
     */
    readonly mode: PreconditionRunMode;
    /**
     * The {@link IPreconditionContainer}s the array holds.
     * @since 1.0.0
     */
    readonly entries: IPreconditionContainer[];
    /**
     * The {@link PreconditionRunCondition} that defines how entries must be handled.
     * @since 1.0.0
     */
    readonly runCondition: PreconditionRunCondition;
    constructor(data?: PreconditionArrayResolvable, parent?: PreconditionContainerArray | null);
    /**
     * Adds a new entry to the array.
     * @since 1.0.0
     * @param entry The value to add to the entries.
     */
    add(entry: IPreconditionContainer): this;
    append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;
    append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;
    /**
     * Runs the container.
     * @since 1.0.0
     * @param message The message that ran this precondition.
     * @param command The command the message invoked.
     */
    run(message: Message, command: Command, context?: PreconditionContext): PreconditionContainerReturn;
    /**
     * Parses the precondition entry resolvables, and adds them to the entries.
     * @since 1.0.0
     * @param entries The entries to parse.
     */
    protected parse(entries: Iterable<PreconditionEntryResolvable>): this;
    /**
     * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.
     * @since 1.0.0
     */
    protected get condition(): IPreconditionCondition;
    /**
     * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then
     * inserting {@link IPreconditionCondition}s.
     * @since 1.0.0
     * @example
     * ```typescript
     * // Adding more kinds of conditions
     *
     * // Set the new condition:
     * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);
     *
     * // Augment Sapphire to add the new condition, in case of a JavaScript
     * // project, this can be moved to an `Augments.d.ts` (or any other name)
     * // file somewhere:
     * declare module '@sapphire/framework' {
     *   export enum PreconditionRunCondition {
     *     Random = 2
     *   }
     * }
     * ```
     */
    static readonly conditions: Collection<PreconditionRunCondition, IPreconditionCondition>;
}

/**
 * The strategy options used in Sapphire.
 */
interface FlagStrategyOptions {
    /**
     * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    flags?: readonly string[] | boolean;
    /**
     * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:
     * * An array of strings, e.g. [`silent`].
     * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).
     * @default []
     */
    options?: readonly string[] | boolean;
    /**
     * The prefixes for both flags and options.
     * @default ['--', '-', '—']
     */
    prefixes?: string[];
    /**
     * The flag separators.
     * @default ['=', ':']
     */
    separators?: string[];
}

/**
 * The allowed values for {@link Command.Options.runIn}.
 * @remark It is discouraged to use this type, we recommend using {@link Command.OptionsRunTypeEnum} instead.
 * @since 2.0.0
 */
declare type CommandOptionsRunType = 'DM' | 'GUILD_TEXT' | 'GUILD_NEWS' | 'GUILD_NEWS_THREAD' | 'GUILD_PUBLIC_THREAD' | 'GUILD_PRIVATE_THREAD' | 'GUILD_ANY';
/**
 * The allowed values for {@link Command.Options.runIn} as an enum.
 * @since 2.0.0
 */
declare const enum CommandOptionsRunTypeEnum {
    Dm = "DM",
    GuildText = "GUILD_TEXT",
    GuildNews = "GUILD_NEWS",
    GuildNewsThread = "GUILD_NEWS_THREAD",
    GuildPublicThread = "GUILD_PUBLIC_THREAD",
    GuildPrivateThread = "GUILD_PRIVATE_THREAD",
    GuildAny = "GUILD_ANY"
}
/**
 * The available command pre-conditions.
 * @since 2.0.0
 */
declare const enum CommandPreConditions {
    Cooldown = "Cooldown",
    DirectMessageOnly = "DMOnly",
    GuildNewsOnly = "GuildNewsOnly",
    GuildNewsThreadOnly = "GuildNewsThreadOnly",
    GuildOnly = "GuildOnly",
    GuildPrivateThreadOnly = "GuildPrivateThreadOnly",
    GuildPublicThreadOnly = "GuildPublicThreadOnly",
    GuildTextOnly = "GuildTextOnly",
    GuildThreadOnly = "GuildThreadOnly",
    NotSafeForWork = "NSFW",
    ClientPermissions = "ClientPermissions",
    UserPermissions = "UserPermissions"
}
/**
 * The {@link Command} options.
 * @since 1.0.0
 */
interface CommandOptions extends AliasPiece.Options, FlagStrategyOptions {
    /**
     * Whether to add aliases for commands with dashes in them
     * @since 1.0.0
     * @default false
     */
    generateDashLessAliases?: boolean;
    /**
     * The description for the command.
     * @since 1.0.0
     * @default ''
     */
    description?: string;
    /**
     * The detailed description for the command.
     * @since 1.0.0
     * @default ''
     */
    detailedDescription?: DetailedDescriptionCommand;
    /**
     * The full category path for the command
     * @since 2.0.0
     * @default 'An array of folder names that lead back to the folder that is registered for in the commands store'
     * @example
     * ```typescript
     * // Given a file named `ping.js` at the path of `commands/General/ping.js`
     * ['General']
     *
     * // Given a file named `info.js` at the path of `commands/General/About/ping.js`
     * ['General', 'About']
     * ```
     */
    fullCategory?: string[];
    /**
     * The {@link Precondition}s to be run, accepts an array of their names.
     * @seealso {@link PreconditionContainerArray}
     * @since 1.0.0
     * @default []
     */
    preconditions?: readonly PreconditionEntryResolvable[];
    /**
     * The quotes accepted by this command, pass `[]` to disable them.
     * @since 1.0.0
     * @default
     * [
     *   ['"', '"'], // Double quotes
     *   ['“', '”'], // Fancy quotes (on iOS)
     *   ['「', '」'] // Corner brackets (CJK)
     * ]
     */
    quotes?: [string, string][];
    /**
     * Sets whether or not the command should be treated as NSFW. If set to true, the `NSFW` precondition will be added to the list.
     * @since 2.0.0
     * @default false
     */
    nsfw?: boolean;
    /**
     * The amount of entries the cooldown can have before filling up, if set to a non-zero value alongside {@link Command.Options.cooldownDelay}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 1
     */
    cooldownLimit?: number;
    /**
     * The time in milliseconds for the cooldown entries to reset, if set to a non-zero value alongside {@link Command.Options.cooldownLimit}, the `Cooldown` precondition will be added to the list.
     * @since 2.0.0
     * @default 0
     */
    cooldownDelay?: number;
    /**
     * The scope of the cooldown entries.
     * @since 2.0.0
     * @default BucketScope.User
     */
    cooldownScope?: BucketScope;
    /**
     * The users that are exempt from the Cooldown precondition.
     * Use this to filter out someone like a bot owner
     * @since 2.0.0
     * @default undefined
     */
    cooldownFilteredUsers?: Snowflake[];
    /**
     * The required permissions for the client.
     * @since 2.0.0
     * @default 0
     */
    requiredClientPermissions?: PermissionResolvable;
    /**
     * The required permissions for the user.
     * @since 2.0.0
     * @default 0
     */
    requiredUserPermissions?: PermissionResolvable;
    /**
     * The channels the command should run in. If set to `null`, no precondition entry will be added. Some optimizations are applied when given an array to reduce the amount of preconditions run (e.g. `'GUILD_TEXT'` and `'GUILD_NEWS'` becomes `'GUILD_ANY'`, and if both `'DM'` and `'GUILD_ANY'` are defined, then no precondition entry is added as it runs in all channels).
     * @since 2.0.0
     * @default null
     */
    runIn?: Command.RunInTypes | CommandOptionsRunTypeEnum | readonly (Command.RunInTypes | CommandOptionsRunTypeEnum)[] | null;
    /**
     * If {@link SapphireClient.typing} is true, this option will override it.
     * Otherwise, this option has no effect - you may call {@link Channel#sendTyping}` in the run method if you want specific commands to display the typing status.
     * @default true
     */
    typing?: boolean;
}
interface CommandContext extends Record<PropertyKey, unknown> {
    /**
     * The prefix used to run this command.
     *
     * This is a string for the mention and default prefix, and a RegExp for the `regexPrefix`.
     */
    prefix: string | RegExp;
    /**
     * The alias used to run this command.
     */
    commandName: string;
    /**
     * The matched prefix, this will always be the same as {@link Command.RunContext.prefix} if it was a string, otherwise it is
     * the result of doing `prefix.exec(content)[0]`.
     */
    commandPrefix: string;
}
interface CommandJSON extends AliasPieceJSON {
    description: string;
    detailedDescription: DetailedDescriptionCommand;
    category: string | null;
}
declare abstract class Command<T = Args, O extends Command.Options = Command.Options> extends AliasPiece<O> {
    /**
     * A basic summary about the command
     * @since 1.0.0
     */
    description: string;
    /**
     * The preconditions to be run.
     * @since 1.0.0
     */
    preconditions: PreconditionContainerArray;
    /**
     * Longer version of command's summary and how to use it
     * @since 1.0.0
     */
    detailedDescription: DetailedDescriptionCommand;
    /**
     * The full category for the command. Either an array of strings that denote every (sub)folder the command is in,
     * or `null` if it could not be resolved automatically.
     *
     * If this is `null` for how you setup your code then you can overwrite how the `fullCategory` is resolved by
     * extending this class and overwriting the assignment in the constructor.
     * @since 2.0.0
     */
    readonly fullCategory: readonly string[];
    /**
     * The strategy to use for the lexer.
     * @since 1.0.0
     */
    strategy: Lexure.UnorderedStrategy;
    /**
     * If {@link SapphireClient.typing} is true, it can be overridden for a specific command using this property, set via its options.
     * Otherwise, this property will be ignored.
     * @default true
     */
    typing: boolean;
    /**
     * The lexer to be used for command parsing
     * @since 1.0.0
     * @private
     */
    protected lexer: Lexure.Lexer;
    /**
     * @since 1.0.0
     * @param context The context.
     * @param options Optional Command settings.
     */
    protected constructor(context: PieceContext, options?: Command.Options);
    /**
     * The pre-parse method. This method can be overridden by plugins to define their own argument parser.
     * @param message The message that triggered the command.
     * @param parameters The raw parameters as a single string.
     * @param context The command-context used in this execution.
     */
    preParse(message: Message, parameters: string, context: Command.RunContext): Awaitable<T>;
    /**
     * The main category for the command, if any.
     *
     * This getter retrieves the first value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get category(): string | null;
    /**
     * The sub-category for the command, if any.
     *
     * This getter retrieves the second value of {@link Command.fullCategory}, if it has at least two items, otherwise
     * it returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get subCategory(): string | null;
    /**
     * The parent category for the command.
     *
     * This getter retrieves the last value of {@link Command.fullCategory}, if it has at least one item, otherwise it
     * returns `null`.
     *
     * @note You can set {@link Command.Options.fullCategory} to override the built-in category resolution.
     */
    get parentCategory(): string | null;
    /**
     * Executes the command's logic for a message.
     * @param message The message that triggered the command.
     * @param args The value returned by {@link Command.preParse}, by default an instance of {@link Args}.
     */
    abstract messageRun(message: Message, args: T, context: Command.RunContext): Awaitable<unknown>;
    /**
     * Defines the JSON.stringify behavior of the command.
     */
    toJSON(): CommandJSON;
    /**
     * Parses the command's options and processes them, calling {@link Command#parseConstructorPreConditionsRunIn},
     * {@link Command#parseConstructorPreConditionsNsfw},
     * {@link Command#parseConstructorPreConditionsRequiredClientPermissions}, and
     * {@link Command#parseConstructorPreConditionsCooldown}.
     * @since 2.0.0
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditions(options: Command.Options): void;
    /**
     * Appends the `NSFW` precondition if {@link Command.Options.nsfw} is set to true.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsNsfw(options: Command.Options): void;
    /**
     * Appends the `DMOnly`, `GuildOnly`, `NewsOnly`, and `TextOnly` preconditions based on the values passed in
     * {@link Command.Options.runIn}, optimizing in specific cases (`NewsOnly` + `TextOnly` = `GuildOnly`; `DMOnly` +
     * `GuildOnly` = `null`), defaulting to `null`, which doesn't add a precondition.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRunIn(options: Command.Options): void;
    /**
     * Appends the `ClientPermissions` precondition when {@link Command.Options.requiredClientPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredClientPermissions(options: Command.Options): void;
    /**
     * Appends the `UserPermissions` precondition when {@link Command.Options.requiredUserPermissions} resolves to a
     * non-zero bitfield.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsRequiredUserPermissions(options: Command.Options): void;
    /**
     * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and
     * {@link Command.Options.cooldownDelay} are both non-zero.
     * @param options The command options given from the constructor.
     */
    protected parseConstructorPreConditionsCooldown(options: Command.Options): void;
    private resolveConstructorPreConditionsRunType;
}
interface Command<T = Args> {
    /**
     * Executes the command's logic.
     * @param message The message that triggered the command.
     * @param args The value returned by {@link Command.preParse}, by default an instance of {@link Args}.
     * @deprecated Use `messageRun` instead.
     */
    run?(message: Message, args: T, context: Command.RunContext): Awaitable<unknown>;
}
declare namespace Command {
    type Options = CommandOptions;
    type JSON = CommandJSON;
    type Context = AliasPiece.Context;
    type RunContext = CommandContext;
    type RunInTypes = CommandOptionsRunType;
}
declare type DetailedDescriptionCommand = string | DetailedDescriptionCommandObject;
interface DetailedDescriptionCommandObject extends NonNullObject {
}

/**
 * A type used to express a value that may or may not exist.
 * @typeparam T The value's type.
 */
declare type Maybe<T> = Some<T> | None;
/**
 * A value that exists.
 * @typeparam T The value's type.
 */
declare type Some<T> = option.Some<T>;
/**
 * An empty value.
 */
declare type None = option.None;
/**
 * Returns the maybe itself.
 * @param value The value to convert.
 */
declare function maybe<T, V extends Maybe<T>>(value: V): V;
/**
 * Creates a {@link None} from an existing {@link None} or a `null`.
 * @param value The value to convert.
 */
declare function maybe(value: null | None): None;
/**
 * Creates a {@link Some} from a non-null value or an existing {@link Some}, or a {@link None} otherwise.
 * @param value The value to convert.
 */
declare function maybe<T>(value: T | Maybe<T> | null): Maybe<T>;
/**
 * Creates a {@link Some} from a non-null value or an existing {@link Some}.
 * @param value The value to convert.
 */
declare function maybe<T>(value: T | Some<T>): Some<T>;
/**
 * Creates a None with no value.
 * @return An existing Maybe.
 */
declare function some(): Some<unknown>;
/**
 * Creates a None with a value.
 * @typeparam T The value's type.
 * @param x Value to use.
 * @return An existing Maybe.
 */
declare function some<T>(x: T): Some<T>;
/**
 * Creates a None value.
 * @return A non-existing Maybe.
 */
declare function none(): None;
/**
 * Determines whether or not a Maybe is a Some.
 * @typeparam T The value's type.
 */
declare function isSome<T>(x: Maybe<T>): x is Some<T>;
/**
 * Determines whether or not a Maybe is a None.
 * @typeparam T The value's type.
 */
declare function isNone<T>(x: Maybe<T>): x is None;
/**
 * Type-safe helper to preserve the type parameter's type.
 * @param x The value to check.
 */
declare function isMaybe<T>(x: Maybe<T>): true;
/**
 * Determines whether or not an arbitrary value is a Maybe.
 * @param x The value to check.
 */
declare function isMaybe<T>(x: unknown): x is Maybe<T>;

/**
 * The argument parser to be used in {@link Command}.
 */
declare class Args {
    /**
     * The original message that triggered the command.
     */
    readonly message: Message;
    /**
     * The command that is being run.
     */
    readonly command: Command;
    /**
     * The context of the command being run.
     */
    readonly commandContext: Command.RunContext;
    /**
     * The internal Lexure parser.
     */
    protected readonly parser: Lexure.Args;
    /**
     * The states stored in the args.
     * @see Args#save
     * @see Args#restore
     */
    private readonly states;
    constructor(message: Message, command: Command, parser: Lexure.Args, context: Command.RunContext);
    /**
     * Sets the parser to the first token.
     */
    start(): Args;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((arg) => {
     *   const parsed = Number(argument);
     *   if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));
     *   return ok(parsed);
     * });
     * const a = await args.pickResult(resolver);
     * if (!a.success) throw new UserError('ArgumentNumberNaN', 'You must write a valid number.');
     *
     * await message.channel.send(`The result is: ${a.value ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pickResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Retrieves the next parameter and parses it. Advances index on success.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the first one did not match.');
     *
     * const b = await args.pickResult('integer');
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write two numbers, but the second one did not match.');
     *
     * await message.channel.send(`The result is: ${a.value + b.value}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pickResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !square 5
     * const resolver = Args.make((arg) => {
     *   const parsed = Number(argument);
     *   if (Number.isNaN(parsed)) return err(new UserError('ArgumentNumberNaN', 'You must write a valid number.'));
     *   return ok(parsed);
     * });
     * const a = await args.pick(resolver);
     *
     * await message.channel.send(`The result is: ${a ** 2}!`);
     * // Sends "The result is: 25"
     * ```
     */
    pick<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.pickResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 1 2
     * const a = await args.pick('integer');
     * const b = await args.pick('integer');
     * await message.channel.send(`The result is: ${a + b}!`);
     * // Sends "The result is: 3"
     * ```
     */
    pick<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const a = await args.restResult(resolver);
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write some text.');
     *
     * await message.channel.send(`The reversed value is... ${a.value}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    restResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pickResult('integer');
     * if (!a.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the former did not match.');
     *
     * const b = await args.restResult('string', { minimum: 1 });
     * if (!b.success) throw new UserError('AddArgumentError', 'You must write a number and a text, but the latter did not match.');
     *
     * await message.channel.send(`The repeated value is... ${b.value.repeat(a.value)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    restResult<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse Hello world!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const a = await args.rest(resolver);
     * await message.channel.send(`The reversed value is... ${a}`);
     * // Sends "The reversed value is... !dlrow olleH"
     * ```
     */
    rest<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.restResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const a = await args.pick('integer');
     * const b = await args.rest('string', { minimum: 1 });
     * await message.channel.send(`The repeated value is... ${b.repeat(a)}!`);
     * // Sends "The repeated value is... Hello World!Hello World!"
     * ```
     */
    rest<K extends keyof ArgType>(type: K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const result = await args.repeatResult(resolver, { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): olleH !dlroW"
     * ```
     */
    repeatResult<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<Result<T[], UserError>>;
    /**
     * Retrieves all the following arguments.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const result = await args.repeatResult('string', { times: 5 });
     * if (!result.success) throw new UserError('CountArgumentError', 'You must write up to 5 words.');
     *
     * await message.channel.send(`You have written ${result.value.length} word(s): ${result.value.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeatResult<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<Result<ArgType[K][], UserError>>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !reverse-each 2 Hello World!
     * const resolver = Args.make((arg) => ok(arg.split('').reverse()));
     * const result = await args.repeat(resolver, { times: 5 });
     * await message.channel.send(`You have written ${result.length} word(s): ${result.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<T>(type: IArgument<T>, options?: RepeatArgOptions): Promise<T[]>;
    /**
     * Similar to {@link Args.repeatResult} but returns the value on success, throwing otherwise.
     * @param type The type of the argument.
     * @example
     * ```typescript
     * // !add 2 Hello World!
     * const words = await args.repeat('string', { times: 5 });
     * await message.channel.send(`You have written ${words.length} word(s): ${words.join(' ')}`);
     * // Sends "You have written 2 word(s): Hello World!"
     * ```
     */
    repeat<K extends keyof ArgType>(type: K, options?: RepeatArgOptions): Promise<ArgType[K][]>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !reversedandscreamfirst hello world
     * const resolver = Args.make((arg) => ok(arg.split('').reverse().join('')));
     *
     * const result = await args.peekResult(() => args.repeatResult(resolver));
     * if (isOk(result)) await message.channel.send(
     *   `Reversed ${result.value.length} word(s): ${result.value.join(' ')}`
     * ); // Reversed 2 word(s): olleh dlrow
     *
     * const firstWord = await args.pickResult('string');
     * if (isOk(firstWord)) await message.channel.send(firstWord.value.toUpperCase()); // HELLO
     * ```
     */
    peekResult<T>(type: () => Argument.Result<T>): Promise<Result<T, UserError>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !reverseandscreamfirst sapphire community
     * const resolver = Args.make((arg) => ok(arg.split('').reverse().join('')));
     *
     * const peekedWord = await args.peekResult(resolver);
     * if (isOk(peekedWord)) await message.channel.send(peekedWord.value); // erihppas
     *
     * const firstWord = await args.pickResult('string');
     * if (isOk(firstWord)) await message.channel.send(firstWord.value.toUpperCase()); // SAPPHIRE
     * ```
     */
    peekResult<T>(type: IArgument<T>, options?: ArgOptions): Promise<Result<T, UserError>>;
    /**
     * Peeks the following parameter(s) without advancing the parser's state.
     * Passing a function as a parameter allows for returning {@link Args.pickResult}, {@link Args.repeatResult},
     * or {@link Args.restResult}; otherwise, passing the custom argument or the argument type with options
     * will use {@link Args.pickResult} and only peek a single argument.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !datethenaddtwo 1608867472611
     * const date = await args.peekResult('date');
     * if (isOk(date)) await message.channel.send(
     *   `Your date (in UTC): ${date.value.toUTCString()}`
     * ); // Your date (in UTC): Fri, 25 Dec 2020 03:37:52 GMT
     *
     * const result = await args.pickResult('number', { maximum: Number.MAX_SAFE_INTEGER - 2 });
     * if (isOk(result)) await message.channel.send(`Your number plus two: ${result.value + 2}`); // Your number plus two: 1608867472613
     * ```
     */
    peekResult<K extends keyof ArgType>(type: (() => Argument.Result<ArgType[K]>) | K, options?: ArgOptions): Promise<Result<ArgType[K], UserError>>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !bigintsumthensquarefirst 25 50 75
     * const resolver = Args.make((arg) => {
     *   try {
     *     return ok(BigInt(arg));
     *   } catch {
     *     return err(new UserError('InvalidBigInt', 'You must specify a valid number for a bigint.'));
     *   }
     * });
     *
     * const peeked = await args.peek(() => args.repeatResult(resolver));
     * await message.channel.send(`Sum: **${peeked.reduce((x, y) => x + y, 0)}**`); // Sum: 150
     *
     * const first = await args.pick(resolver);
     * await message.channel.send(`First bigint squared: ${first**2n}`); // First bigint squared: 625
     * ```
     */
    peek<T>(type: () => Argument.Result<T>): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !createdat 730159185517477900
     * const snowflakeResolver = Args.make((arg) =>
     * 	 SnowflakeRegex.test(arg) ? ok(BigInt(arg)) : err(new UserError('InvalidSnowflake', 'You must specify a valid snowflake.'));
     * );
     *
     * const snowflake = await args.peek(snowflakeResolver);
     * const timestamp = Number((snowflake >> 22n) + DiscordSnowflake.Epoch);
     * const createdAt = new Date(timestamp);
     *
     * await message.channel.send(
     *   `The snowflake ${snowflake} was registered on ${createdAt.toUTCString()}.`
     * ); // The snowflake 730159185517477900 was registered on Tue, 07 Jul 2020 20:31:55 GMT.
     *
     * const id = await args.pick('string');
     * await message.channel.send(`Your ID, reversed: ${id.split('').reverse().join('')}`); // Your ID, reversed: 009774715581951037
     * ```
     */
    peek<T>(type: IArgument<T>, options?: ArgOptions): Promise<T>;
    /**
     * Similar to {@link Args.peekResult} but returns the value on success, throwing otherwise.
     * @param type The function, custom argument, or argument name.
     * @example
     * ```typescript
     * // !messagelink https://discord.com/channels/737141877803057244/737142209639350343/791843123898089483
     * const remoteMessage = await args.peek('message');
     * await message.channel.send(
     *   `${remoteMessage.author.tag}: ${remoteMessage.content}`
     * ); // RealShadowNova#7462: Yeah, Sapphire has been a great experience so far, especially being able to help and contribute.
     *
     * const url = await args.pick('hyperlink');
     * await message.channel.send(`Hostname: ${url.hostname}`); // Hostname: discord.com
     * ```
     */
    peek<K extends keyof ArgType>(type: (() => Argument.Result<ArgType[K]>) | K, options?: ArgOptions): Promise<ArgType[K]>;
    /**
     * Retrieves the next raw argument from the parser.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.nextMaybe());
     * // -> { exists: true, value: '1' }
     * ```
     */
    nextMaybe(): Maybe<string>;
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     * That token will now be consider used if the transformation succeeds.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> { exists: true, value: 1 }
     * ```
     */
    nextMaybe<T>(cb: ArgsNextCallback<T>): Maybe<T>;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     *
     * console.log(args.next());
     * // -> '1'
     * ```
     */
    next(): string;
    /**
     * Similar to {@link Args.nextMaybe} but returns the value on success, null otherwise.
     * @typeparam T Output type of the {@link ArgsNextCallback callback}.
     * @param cb Gives an option of either the resulting value, or nothing if failed.
     * @example
     * ```typescript
     * // !numbers 1 2 3
     * const parse = (x: string) => {
     *   const n = Number(x);
     *   return Number.isNaN(n) ? none() : some(n);
     * };
     *
     * console.log(args.nextMaybe(parse));
     * // -> 1
     * ```
     */
    next<T>(cb: ArgsNextCallback<T>): T;
    /**
     * Checks if one or more flag were given.
     * @param keys The name(s) of the flag.
     * @example
     * ```typescript
     * // Suppose args are from '--f --g'.
     * console.log(args.getFlags('f'));
     * // >>> true
     *
     * console.log(args.getFlags('g', 'h'));
     * // >>> true
     *
     * console.log(args.getFlags('h'));
     * // >>> false
     * ```
     */
    getFlags(...keys: readonly string[]): boolean;
    /**
     * Gets the last value of one or more options.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --b=2 --c=3'.
     * console.log(args.getOption('a'));
     * // >>> '1'
     *
     * console.log(args.getOption('b', 'c'));
     * // >>> '2'
     *
     * console.log(args.getOption('d'));
     * // >>> null
     * ```
     */
    getOption(...keys: readonly string[]): string | null;
    /**
     * Gets all the values of one or more option.
     * @param keys The name(s) of the option.
     * @example
     * ```typescript
     * // Suppose args are from '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.getOptions('a'));
     * // >>> ['1', '1']
     *
     * console.log(args.getOptions('b', 'c'));
     * // >>> ['2', '3']
     *
     * console.log(args.getOptions('d'));
     * // >>> null
     * ```
     */
    getOptions(...keys: readonly string[]): string[] | null;
    /**
     * Saves the current state into the stack following a FILO strategy (first-in, last-out).
     * @see Args#restore
     */
    save(): void;
    /**
     * Restores the previously saved state from the stack.
     * @see Args#save
     */
    restore(): void;
    /**
     * Whether all arguments have been consumed.
     */
    get finished(): boolean;
    /**
     * Defines the `JSON.stringify` override.
     */
    toJSON(): {
        message: Message<boolean>;
        command: Command<Args, CommandOptions>;
        commandContext: CommandContext;
    };
    protected unavailableArgument<T>(type: string | IArgument<T>): Err<UserError>;
    protected missingArguments(): Err<UserError>;
    /**
     * Resolves an argument.
     * @param arg The argument name or {@link IArgument} instance.
     */
    private resolveArgument;
    /**
     * Converts a callback into an usable argument.
     * @param cb The callback to convert into an {@link IArgument}.
     */
    static make<T>(cb: IArgument<T>['run'], name?: string): IArgument<T>;
    /**
     * Constructs an {@link Ok} result.
     * @param value The value to pass.
     */
    static ok<T>(value: T): Ok<T>;
    /**
     * Constructs an {@link Err} result containing an {@link ArgumentError}.
     * @param options The options for the argument error.
     */
    static error<T>(options: ArgumentError.Options<T>): Err<ArgumentError<T>>;
}
interface ArgType {
    boolean: boolean;
    channel: ChannelTypes;
    date: Date;
    dmChannel: DMChannel;
    float: number;
    guildCategoryChannel: CategoryChannel;
    guildChannel: GuildBasedChannelTypes;
    guildNewsChannel: NewsChannel;
    guildNewsThreadChannel: ThreadChannel & {
        type: 'GUILD_NEWS_THREAD';
        parent: NewsChannel | null;
    };
    guildPrivateThreadChannel: ThreadChannel & {
        type: 'GUILD_PRIVATE_THREAD';
        parent: TextChannel | null;
    };
    guildPublicThreadChannel: ThreadChannel & {
        type: 'GUILD_PUBLIC_THREAD';
        parent: TextChannel | null;
    };
    guildStageVoiceChannel: StageChannel;
    guildTextChannel: TextChannel;
    guildThreadChannel: ThreadChannel;
    guildVoiceChannel: VoiceChannel;
    hyperlink: URL;
    integer: number;
    member: GuildMember;
    message: Message;
    number: number;
    role: Role;
    string: string;
    url: URL;
    user: User;
    enum: string;
}
interface ArgOptions extends Omit<Argument.Context, 'message' | 'command'> {
}
interface RepeatArgOptions extends ArgOptions {
    /**
     * The maximum amount of times the argument can be repeated.
     * @default Infinity
     */
    times?: number;
}
/**
 * The callback used for {@link Args.nextMaybe} and {@link Args.next}.
 */
interface ArgsNextCallback<T> {
    /**
     * The value to be mapped.
     */
    (value: string): Maybe<T>;
}

/**
 * Defines a synchronous result of an {@link Argument}, check {@link Argument.AsyncResult} for the asynchronous version.
 */
declare type ArgumentResult<T> = Awaitable<Result<T, UserError>>;
/**
 * Defines an asynchronous result of an {@link Argument}, check {@link Argument.Result} for the synchronous version.
 */
declare type AsyncArgumentResult<T> = Promise<Result<T, UserError>>;
interface IArgument<T> {
    /**
     * The name of the argument, this is used to make the identification of an argument easier.
     */
    readonly name: string;
    /**
     * The method which is called when invoking the argument.
     * @param parameter The string parameter to parse.
     * @param context The context for the method call, contains the message, command, and other options.
     */
    run(parameter: string, context: Argument.Context<T>): Argument.Result<T>;
}
interface ArgumentOptions extends AliasPiece.Options {
}
interface ArgumentContext<T = unknown> extends Record<PropertyKey, unknown> {
    argument: IArgument<T>;
    args: Args;
    message: Message;
    command: Command;
    commandContext: Command.RunContext;
    minimum?: number;
    maximum?: number;
    inclusive?: boolean;
}
/**
 * The base argument class. This class is abstract and is to be extended by subclasses implementing the methods. In
 * Sapphire's workflow, arguments are called when using {@link Args}'s methods (usually used inside {@link Command}s by default).
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Argument, PieceContext } from '@sapphire/framework';
 * import { URL } from 'url';
 *
 * // Define a class extending `Argument`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreArgument extends Argument<URL> {
 *   public constructor(context: PieceContext) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   public run(argument: string): Argument.Result<URL> {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error(argument, 'ArgumentHyperlinkInvalidURL', 'The argument did not resolve to a valid URL.');
 *     }
 *   }
 * }
 *
 * // Augment the ArgType structure so `args.pick('url')`, `args.repeat('url')`
 * // and others have a return type of `URL`.
 * declare module '@sapphire/framework' {
 *   export interface ArgType {
 *     url: URL;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Argument } = require('@sapphire/framework');
 *
 * // Define a class extending `Argument`, then export it.
 * module.exports = class CoreArgument extends Argument {
 *   constructor(context) {
 *     super(context, { name: 'hyperlink', aliases: ['url'] });
 *   }
 *
 *   run(argument) {
 *     try {
 *       return this.ok(new URL(argument));
 *     } catch {
 *       return this.error(argument, 'ArgumentHyperlinkInvalidURL', 'The argument did not resolve to a valid URL.');
 *     }
 *   }
 * }
 * ```
 */
declare abstract class Argument<T = unknown, O extends Argument.Options = Argument.Options> extends AliasPiece<O> implements IArgument<T> {
    abstract run(parameter: string, context: Argument.Context<T>): Argument.Result<T>;
    /**
     * Wraps a value into a successful value.
     * @param value The value to wrap.
     */
    ok(value: T): Argument.Result<T>;
    /**
     * Constructs an {@link ArgumentError} with a custom type.
     * @param parameter The parameter that triggered the argument.
     * @param type The identifier for the error.
     * @param message The description message for the rejection.
     */
    error(options: Omit<ArgumentError.Options<T>, 'argument'>): Argument.Result<T>;
}
declare namespace Argument {
    type Options = ArgumentOptions;
    type Context<T = unknown> = ArgumentContext<T>;
    type Result<T> = ArgumentResult<T>;
    type AsyncResult<T> = AsyncArgumentResult<T>;
}

/**
 * Errors thrown by the argument parser
 * @since 1.0.0
 * @property name This will be `'ArgumentError'` and can be used to distinguish the type of error when any error gets thrown
 */
declare class ArgumentError<T = unknown> extends UserError {
    readonly argument: IArgument<T>;
    readonly parameter: string;
    constructor(options: ArgumentError.Options<T>);
    get name(): string;
}
declare namespace ArgumentError {
    /**
     * The options for {@link ArgumentError}.
     * @since 1.0.0
     */
    interface Options<T> extends Omit<UserError.Options, 'identifier'> {
        /**
         * The argument that caused the error.
         * @since 1.0.0
         */
        argument: IArgument<T>;
        /**
         * The parameter that failed to be parsed.
         * @since 1.0.0
         */
        parameter: string;
        /**
         * The identifier.
         * @since 1.0.0
         * @default argument.name
         */
        identifier?: string;
    }
}

declare const enum Identifiers {
    ArgsMissing = "argsMissing",
    ArgsUnavailable = "argsUnavailable",
    ArgumentBooleanError = "booleanError",
    ArgumentChannelError = "channelError",
    ArgumentDateError = "dateError",
    ArgumentDateTooEarly = "dateTooEarly",
    ArgumentDateTooFar = "dateTooFar",
    ArgumentDMChannelError = "dmChannelError",
    ArgumentFloatError = "floatError",
    ArgumentFloatTooLarge = "floatTooLarge",
    ArgumentFloatTooSmall = "floatTooSmall",
    ArgumentGuildCategoryChannelError = "categoryChannelError",
    ArgumentGuildChannelError = "guildChannelError",
    ArgumentGuildChannelMissingGuildError = "guildChannelMissingGuildError",
    ArgumentGuildNewsChannelError = "guildNewsChannelError",
    ArgumentGuildNewsThreadChannelError = "guildNewsChannelError",
    ArgumentGuildPrivateThreadChannelError = "guildPrivateThreadChannelError",
    ArgumentGuildPublicThreadChannelError = "guildPublicThreadChannelError",
    ArgumentGuildStageVoiceChannelError = "guildStageVoiceChannelError",
    ArgumentGuildTextChannelError = "guildTextChannelError",
    ArgumentGuildThreadChannelError = "guildThreadChannelError",
    ArgumentGuildVoiceChannelError = "guildVoiceChannelError",
    ArgumentHyperlinkError = "hyperlinkError",
    ArgumentIntegerError = "integerError",
    ArgumentIntegerTooLarge = "integerTooLarge",
    ArgumentIntegerTooSmall = "integerTooSmall",
    ArgumentMemberError = "memberError",
    ArgumentMemberMissingGuild = "memberMissingGuild",
    ArgumentMessageError = "messageError",
    ArgumentNumberError = "numberError",
    ArgumentNumberTooLarge = "numberTooLarge",
    ArgumentNumberTooSmall = "numberTooSmall",
    ArgumentRoleError = "roleError",
    ArgumentRoleMissingGuild = "roleMissingGuild",
    ArgumentStringTooLong = "stringTooLong",
    ArgumentStringTooShort = "stringTooShort",
    ArgumentUserError = "userError",
    ArgumentEnumEmptyError = "enumEmptyError",
    ArgumentEnumError = "enumError",
    CommandDisabled = "commandDisabled",
    PreconditionCooldown = "preconditionCooldown",
    PreconditionDMOnly = "preconditionDmOnly",
    PreconditionGuildNewsOnly = "preconditionGuildNewsOnly",
    PreconditionGuildNewsThreadOnly = "preconditionGuildNewsThreadOnly",
    PreconditionGuildOnly = "preconditionGuildOnly",
    PreconditionGuildPrivateThreadOnly = "preconditionGuildPrivateThreadOnly",
    PreconditionGuildPublicThreadOnly = "preconditionGuildPublicThreadOnly",
    PreconditionGuildTextOnly = "preconditionGuildTextOnly",
    PreconditionNSFW = "preconditionNsfw",
    PreconditionClientPermissions = "preconditionClientPermissions",
    PreconditionClientPermissionsNoClient = "preconditionClientPermissionsNoClient",
    PreconditionClientPermissionsNoPermissions = "preconditionClientPermissionsNoPermissions",
    PreconditionUserPermissions = "preconditionUserPermissions",
    PreconditionUserPermissionsNoPermissions = "preconditionUserPermissionsNoPermissions",
    PreconditionThreadOnly = "preconditionThreadOnly"
}

declare type AsyncPluginHooks = PluginHook.PreLogin | PluginHook.PostLogin;
interface SapphirePluginAsyncHook {
    (this: SapphireClient, options: ClientOptions): Awaitable<unknown>;
}
declare type SyncPluginHooks = Exclude<PluginHook, AsyncPluginHooks>;
interface SapphirePluginHook {
    (this: SapphireClient, options: ClientOptions): unknown;
}
interface SapphirePluginHookEntry<T = SapphirePluginHook | SapphirePluginAsyncHook> {
    hook: T;
    type: PluginHook;
    name?: string;
}
declare class PluginManager {
    readonly registry: Set<SapphirePluginHookEntry<SapphirePluginAsyncHook | SapphirePluginHook>>;
    registerHook(hook: SapphirePluginHook, type: SyncPluginHooks, name?: string): this;
    registerHook(hook: SapphirePluginAsyncHook, type: AsyncPluginHooks, name?: string): this;
    registerPreGenericsInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPostInitializationHook(hook: SapphirePluginHook, name?: string): this;
    registerPreLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    registerPostLoginHook(hook: SapphirePluginAsyncHook, name?: string): this;
    use(plugin: typeof Plugin): this;
    values(): Generator<SapphirePluginHookEntry, void, unknown>;
    values(hook: SyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginHook>, void, unknown>;
    values(hook: AsyncPluginHooks): Generator<SapphirePluginHookEntry<SapphirePluginAsyncHook>, void, unknown>;
}

declare class ArgumentStore extends AliasStore<Argument> {
    constructor();
}

/**
 * Stores all Command pieces
 * @since 1.0.0
 */
declare class CommandStore extends AliasStore<Command> {
    constructor();
    /**
     * Get all the command categories.
     */
    get categories(): string[];
}

interface ListenerOptions extends Piece.Options {
    readonly emitter?: keyof Client | EventEmitter;
    readonly event?: string;
    readonly once?: boolean;
}
interface ListenerJSON extends Piece.JSON {
    event: string;
    once: boolean;
}
/**
 * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In
 * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { Events, Listener } from '@sapphire/framework';
 *
 * // Define a class extending `Listener`, then export it.
 * // NOTE: You can use `export default` or `export =` too.
 * export class CoreListener extends Listener<typeof Events.Ready> {
 *   public constructor(context: Listener.Context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   public run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { Events, Listener } = require('@sapphire/framework');
 *
 * // Define a class extending `Listener`, then export it.
 * module.exports = class CoreListener extends Listener {
 *   constructor(context) {
 *     super(context, { event: Events.Ready, once: true });
 *   }
 *
 *   run() {
 *     this.container.client.id ??= this.container.client.user?.id ?? null;
 *   }
 * }
 * ```
 */
declare abstract class Listener<E extends keyof ClientEvents | symbol = '', O extends Listener.Options = Listener.Options> extends Piece<O> {
    /**
     * The emitter, if any.
     * @since 2.0.0
     */
    readonly emitter: EventEmitter | null;
    /**
     * The name of the event the listener listens to.
     * @since 2.0.0
     */
    readonly event: string;
    /**
     * Whether or not the listener will be unloaded after the first run.
     * @since 2.0.0
     */
    readonly once: boolean;
    private _listener;
    constructor(context: Listener.Context, options?: Listener.Options);
    abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;
    onLoad(): unknown;
    onUnload(): unknown;
    toJSON(): ListenerJSON;
    private _run;
    private _runOnce;
}
declare namespace Listener {
    type Options = ListenerOptions;
    type JSON = ListenerJSON;
    type Context = Piece.Context;
}

declare class ListenerStore extends Store<Listener> {
    constructor();
}

declare class PreconditionStore extends Store<Precondition> {
    private readonly globalPreconditions;
    constructor();
    run(message: Message, command: Command, context?: PreconditionContext): AsyncPreconditionResult;
    set(key: string, value: Precondition): this;
    delete(key: string): boolean;
    clear(): void;
}

/**
 * The logger levels for the {@link ILogger}.
 */
declare const enum LogLevel {
    /**
     * The lowest log level, used when calling {@link ILogger.trace}.
     */
    Trace = 10,
    /**
     * The debug level, used when calling {@link ILogger.debug}.
     */
    Debug = 20,
    /**
     * The info level, used when calling {@link ILogger.info}.
     */
    Info = 30,
    /**
     * The warning level, used when calling {@link ILogger.warn}.
     */
    Warn = 40,
    /**
     * The error level, used when calling {@link ILogger.error}.
     */
    Error = 50,
    /**
     * The critical level, used when calling {@link ILogger.fatal}.
     */
    Fatal = 60,
    /**
     * An unknown or uncategorized level.
     */
    None = 100
}
interface ILogger {
    /**
     * Checks whether a level is supported.
     * @param level The level to check.
     */
    has(level: LogLevel): boolean;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Trace} as level.
     * @param values The values to log.
     */
    trace(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Debug} as level.
     * @param values The values to log.
     */
    debug(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Info} as level.
     * @param values The values to log.
     */
    info(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Warn} as level.
     * @param values The values to log.
     */
    warn(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Error} as level.
     * @param values The values to log.
     */
    error(...values: readonly unknown[]): void;
    /**
     * Alias of {@link ILogger.write} with {@link LogLevel.Fatal} as level.
     * @param values The values to log.
     */
    fatal(...values: readonly unknown[]): void;
    /**
     * Writes the log message given a level and the value(s).
     * @param level The log level.
     * @param values The values to log.
     */
    write(level: LogLevel, ...values: readonly unknown[]): void;
}

/**
 * A valid prefix in Sapphire.
 * * `string`: a single prefix, e.g. `'!'`.
 * * `string[]`: an array of prefixes, e.g. `['!', '.']`.
 * * `null`: disabled prefix, locks the bot's command usage to mentions only.
 */
declare type SapphirePrefix = string | readonly string[] | null;
interface SapphirePrefixHook {
    (message: Message): Awaitable<SapphirePrefix>;
}
interface SapphireClientOptions {
    /**
     * The base user directory, if set to `null`, Sapphire will not call {@link StoreRegistry.registerPath},
     * meaning that you will need to manually set each folder for each store. Please read the aforementioned method's
     * documentation for more information.
     * @since 1.0.0
     * @default undefined
     */
    baseUserDirectory?: string | null;
    /**
     * Whether commands can be case insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitiveCommands?: boolean | null;
    /**
     * Whether prefixes can be case insensitive
     * @since 1.0.0
     * @default false
     */
    caseInsensitivePrefixes?: boolean | null;
    /**
     * The default prefix, in case of `null`, only mention prefix will trigger the bot's commands.
     * @since 1.0.0
     * @default null
     */
    defaultPrefix?: SapphirePrefix;
    /**
     * The regex prefix, an alternative to a mention or regular prefix to allow creating natural language command messages
     * @since 1.0.0
     * @example
     * ```typescript
     * /^(hey +)?bot[,! ]/i
     *
     * // Matches:
     * // - hey bot,
     * // - hey bot!
     * // - hey bot
     * // - bot,
     * // - bot!
     * // - bot
     * ```
     */
    regexPrefix?: RegExp;
    /**
     * The prefix hook, by default it is a callback function that returns {@link SapphireClientOptions.defaultPrefix}.
     * @since 1.0.0
     * @default () => client.options.defaultPrefix
     */
    fetchPrefix?: SapphirePrefixHook;
    /**
     * The client's ID, this is automatically set by the CoreReady event.
     * @since 1.0.0
     * @default this.client.user?.id ?? null
     */
    id?: Snowflake;
    /**
     * The logger options, defaults to an instance of {@link Logger} when {@link ClientLoggerOptions.instance} is not specified.
     * @since 1.0.0
     * @default { instance: new Logger(LogLevel.Info) }
     */
    logger?: ClientLoggerOptions;
    /**
     * Whether or not trace logging should be enabled.
     * @since 2.0.0
     * @default container.logger.has(LogLevel.Trace)
     */
    enableLoaderTraceLoggings?: boolean;
    /**
     * If Sapphire should load our pre-included error event listeners that log any encountered errors to the {@link SapphireClient.logger} instance
     * @since 1.0.0
     * @default true
     */
    loadDefaultErrorListeners?: boolean;
    /**
     * Controls whether the bot will automatically appear to be typing when a command is accepted.
     * @default false
     */
    typing?: boolean;
    /**
     * Sets the default cooldown time for all commands.
     * @default "No cooldown options"
     */
    defaultCooldown?: CooldownOptions;
    /**
     * Controls whether the bot has mention as a prefix disabled
     * @default false
     */
    disableMentionPrefix?: boolean;
}
/**
 * The base {@link Client} extension that makes Sapphire work. When building a Discord bot with the framework, the developer
 * must either use this class, or extend it.
 *
 * Sapphire also automatically detects the folders to scan for pieces, please read {@link StoreRegistry.registerPath}
 * for reference. This method is called at the start of the {@link SapphireClient.login} method.
 *
 * @see {@link SapphireClientOptions} for all options available to the Sapphire Client. You can also provide all of discord.js' [ClientOptions](https://discord.js.org/#/docs/main/stable/typedef/ClientOptions)
 *
 * @since 1.0.0
 * @example
 * ```typescript
 * const client = new SapphireClient({
 *   presence: {
 *     activity: {
 *       name: 'for commands!',
 *       type: 'LISTENING'
 *     }
 *   }
 * });
 *
 * client.login(process.env.DISCORD_TOKEN)
 *   .catch(console.error);
 * ```
 *
 * @example
 * ```typescript
 * // Automatically scan from a specific directory, e.g. the main
 * // file is at `/home/me/bot/index.js` and all your pieces are at
 * // `/home/me/bot/pieces` (e.g. `/home/me/bot/pieces/commands/MyCommand.js`):
 * const client = new SapphireClient({
 *   baseUserDirectory: join(__dirname, 'pieces'),
 *   // More options...
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Opt-out automatic scanning:
 * const client = new SapphireClient({
 *   baseUserDirectory: null,
 *   // More options...
 * });
 * ```
 */
declare class SapphireClient<Ready extends boolean = boolean> extends Client<Ready> {
    /**
     * The client's ID, used for the user prefix.
     * @since 1.0.0
     */
    id: Snowflake | null;
    /**
     * The method to be overriden by the developer.
     * @since 1.0.0
     * @return A string for a single prefix, an array of strings for matching multiple, or null for no match (mention prefix only).
     * @example
     * ```typescript
     * // Return always the same prefix (unconfigurable):
     * client.fetchPrefix = () => '!';
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from a SQL database:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getOne('SELECT prefix FROM public.guild WHERE id = $1', [message.guild.id]);
     *   return guild?.prefix ?? '!';
     * };
     * ```
     * @example
     * ```typescript
     * // Retrieving the prefix from an ORM:
     * client.fetchPrefix = async (message) => {
     *   // note: driver is something generic and depends on how you connect to your database
     *   const guild = await driver.getRepository(GuildEntity).findOne({ id: message.guild.id });
     *   return guild?.prefix ?? '!';
     * };
     * ```
     */
    fetchPrefix: SapphirePrefixHook;
    /**
     * The logger to be used by the framework and plugins. By default, a {@link Logger} instance is used, which emits the
     * messages to the console.
     * @since 1.0.0
     */
    logger: ILogger;
    /**
     * Whether the bot has mention as a prefix disabled
     * @default false
     * @example
     * ```typescript
     * client.disableMentionPrefix = false;
     * ```
     */
    disableMentionPrefix?: boolean;
    /**
     * The registered stores.
     * @since 1.0.0
     */
    stores: StoreRegistry;
    constructor(options: ClientOptions);
    /**
     * Loads all pieces, then logs the client in, establishing a websocket connection to Discord.
     * @since 1.0.0
     * @param token Token of the account to log in with.
     * @return Token of the account used.
     */
    login(token?: string): Promise<string>;
    static plugins: PluginManager;
    static use(plugin: typeof Plugin): typeof SapphireClient;
}
interface ClientLoggerOptions {
    level?: LogLevel;
    instance?: ILogger;
}
interface CooldownOptions {
    scope?: BucketScope;
    delay?: number;
    limit?: number;
    filteredUsers?: Snowflake[];
    filteredCommands?: string[];
}
declare module 'discord.js' {
    interface Client {
        id: Snowflake | null;
        logger: ILogger;
        stores: StoreRegistry;
        fetchPrefix: SapphirePrefixHook;
    }
    interface ClientOptions extends SapphireClientOptions {
    }
}
declare module '@sapphire/pieces' {
    interface Container {
        client: SapphireClient;
        logger: ILogger;
        stores: StoreRegistry;
    }
    interface StoreRegistryEntries {
        arguments: ArgumentStore;
        commands: CommandStore;
        listeners: ListenerStore;
        preconditions: PreconditionStore;
    }
}

declare const preGenericsInitialization: unique symbol;
declare const preInitialization: unique symbol;
declare const postInitialization: unique symbol;
declare const preLogin: unique symbol;
declare const postLogin: unique symbol;

declare abstract class Plugin {
    static [preGenericsInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [postInitialization]?: (this: SapphireClient, options: ClientOptions) => void;
    static [preLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
    static [postLogin]?: (this: SapphireClient, options: ClientOptions) => Awaitable<void>;
}

declare function resolveBoolean(parameter: string, customs?: {
    truths?: readonly string[];
    falses?: readonly string[];
}): Result<boolean, Identifiers.ArgumentBooleanError>;

declare function resolveChannel(parameter: string, message: Message): Result<ChannelTypes, Identifiers.ArgumentChannelError>;

declare function resolveDate(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<Date, Identifiers.ArgumentDateError | Identifiers.ArgumentDateTooEarly | Identifiers.ArgumentDateTooFar>;

declare function resolveDMChannel(parameter: string, message: Message): Result<DMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveFloat(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentFloatError | Identifiers.ArgumentFloatTooSmall | Identifiers.ArgumentFloatTooLarge>;

declare function resolveGuildCategoryChannel(parameter: string, guild: Guild): Result<CategoryChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildCategoryChannelError>;

declare function resolveGuildChannel(parameter: string, guild: Guild): Result<GuildBasedChannelTypes, Identifiers.ArgumentGuildChannelError>;

declare function resolveGuildNewsChannel(parameter: string, guild: Guild): Result<NewsChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildNewsChannelError>;

declare function resolveGuildNewsThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildNewsThreadChannelError>;

declare function resolveGuildPrivateThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPrivateThreadChannelError>;

declare function resolveGuildPublicThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError | Identifiers.ArgumentGuildPublicThreadChannelError>;

declare function resolveGuildStageVoiceChannel(parameter: string, guild: Guild): Result<StageChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildStageVoiceChannelError>;

declare function resolveGuildTextChannel(parameter: string, guild: Guild): Result<TextChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildTextChannelError>;

declare function resolveGuildThreadChannel(parameter: string, guild: Guild): Result<ThreadChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildThreadChannelError>;

declare function resolveGuildVoiceChannel(parameter: string, guild: Guild): Result<VoiceChannel, Identifiers.ArgumentGuildChannelError | Identifiers.ArgumentGuildVoiceChannelError>;

declare function resolveHyperlink(parameter: string): Result<URL, Identifiers.ArgumentHyperlinkError>;

declare function resolveInteger(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentIntegerError | Identifiers.ArgumentIntegerTooSmall | Identifiers.ArgumentIntegerTooLarge>;

declare function resolveMember(parameter: string, guild: Guild): Promise<Result<GuildMember, Identifiers.ArgumentMemberError>>;

interface MessageResolverOptions {
    channel?: TextBasedChannelTypes;
    message: Message;
}
declare function resolveMessage(parameter: string, options: MessageResolverOptions): Promise<Result<Message, Identifiers.ArgumentMessageError>>;

declare function resolveNumber(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<number, Identifiers.ArgumentNumberError | Identifiers.ArgumentNumberTooSmall | Identifiers.ArgumentNumberTooLarge>;

declare function resolvePartialDMChannel(parameter: string, message: Message): Result<DMChannel | PartialDMChannel, Identifiers.ArgumentChannelError | Identifiers.ArgumentDMChannelError>;

declare function resolveRole(parameter: string, guild: Guild): Promise<Result<Role, Identifiers.ArgumentRoleError>>;

declare function resolveString(parameter: string, options?: {
    minimum?: number;
    maximum?: number;
}): Result<string, Identifiers.ArgumentStringTooShort | Identifiers.ArgumentStringTooLong>;

declare function resolveUser(parameter: string): Promise<Result<User, Identifiers.ArgumentUserError>>;

declare function resolveEnum(parameter: string, options?: {
    enum?: string[];
    caseInsensitive?: boolean;
}): Result<string, Identifiers.ArgumentEnumEmptyError | Identifiers.ArgumentEnumError>;

//# sourceMappingURL=index.d.ts.map

declare const index_d$1_resolveBoolean: typeof resolveBoolean;
declare const index_d$1_resolveChannel: typeof resolveChannel;
declare const index_d$1_resolveDate: typeof resolveDate;
declare const index_d$1_resolveDMChannel: typeof resolveDMChannel;
declare const index_d$1_resolveFloat: typeof resolveFloat;
declare const index_d$1_resolveGuildCategoryChannel: typeof resolveGuildCategoryChannel;
declare const index_d$1_resolveGuildChannel: typeof resolveGuildChannel;
declare const index_d$1_resolveGuildNewsChannel: typeof resolveGuildNewsChannel;
declare const index_d$1_resolveGuildNewsThreadChannel: typeof resolveGuildNewsThreadChannel;
declare const index_d$1_resolveGuildPrivateThreadChannel: typeof resolveGuildPrivateThreadChannel;
declare const index_d$1_resolveGuildPublicThreadChannel: typeof resolveGuildPublicThreadChannel;
declare const index_d$1_resolveGuildStageVoiceChannel: typeof resolveGuildStageVoiceChannel;
declare const index_d$1_resolveGuildTextChannel: typeof resolveGuildTextChannel;
declare const index_d$1_resolveGuildThreadChannel: typeof resolveGuildThreadChannel;
declare const index_d$1_resolveGuildVoiceChannel: typeof resolveGuildVoiceChannel;
declare const index_d$1_resolveHyperlink: typeof resolveHyperlink;
declare const index_d$1_resolveInteger: typeof resolveInteger;
declare const index_d$1_resolveMember: typeof resolveMember;
declare const index_d$1_resolveMessage: typeof resolveMessage;
declare const index_d$1_resolveNumber: typeof resolveNumber;
declare const index_d$1_resolvePartialDMChannel: typeof resolvePartialDMChannel;
declare const index_d$1_resolveRole: typeof resolveRole;
declare const index_d$1_resolveString: typeof resolveString;
declare const index_d$1_resolveUser: typeof resolveUser;
declare const index_d$1_resolveEnum: typeof resolveEnum;
declare namespace index_d$1 {
  export {
    index_d$1_resolveBoolean as resolveBoolean,
    index_d$1_resolveChannel as resolveChannel,
    index_d$1_resolveDate as resolveDate,
    index_d$1_resolveDMChannel as resolveDMChannel,
    index_d$1_resolveFloat as resolveFloat,
    index_d$1_resolveGuildCategoryChannel as resolveGuildCategoryChannel,
    index_d$1_resolveGuildChannel as resolveGuildChannel,
    index_d$1_resolveGuildNewsChannel as resolveGuildNewsChannel,
    index_d$1_resolveGuildNewsThreadChannel as resolveGuildNewsThreadChannel,
    index_d$1_resolveGuildPrivateThreadChannel as resolveGuildPrivateThreadChannel,
    index_d$1_resolveGuildPublicThreadChannel as resolveGuildPublicThreadChannel,
    index_d$1_resolveGuildStageVoiceChannel as resolveGuildStageVoiceChannel,
    index_d$1_resolveGuildTextChannel as resolveGuildTextChannel,
    index_d$1_resolveGuildThreadChannel as resolveGuildThreadChannel,
    index_d$1_resolveGuildVoiceChannel as resolveGuildVoiceChannel,
    index_d$1_resolveHyperlink as resolveHyperlink,
    index_d$1_resolveInteger as resolveInteger,
    index_d$1_resolveMember as resolveMember,
    index_d$1_resolveMessage as resolveMessage,
    index_d$1_resolveNumber as resolveNumber,
    index_d$1_resolvePartialDMChannel as resolvePartialDMChannel,
    index_d$1_resolveRole as resolveRole,
    index_d$1_resolveString as resolveString,
    index_d$1_resolveUser as resolveUser,
    index_d$1_resolveEnum as resolveEnum,
  };
}

/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 * Use {@link Argument} instead, and abstract the resolving of the argument data to an external resolver.
 * ---
 * The extended argument class. This class is abstract and is to be extended by subclasses which
 * will implement the {@link ExtendedArgument#handle} method.
 * Much like the {@link Argument} class, this class handles parsing user-specified command arguments
 * into typed command parameters. However, this class can be used to expand upon an existing
 * argument in order to process its transformed value rather than just the argument string.
 *
 * @example
 * ```typescript
 * // TypeScript:
 * import { ApplyOptions } from '@sapphire/decorators';
 * import { ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions } from '@sapphire/framework';
 * import type { Channel, TextChannel } from 'discord.js';
 *
 * // Just like with `Argument`, you can use `export default` or `export =` too.
 * (at)ApplyOptions<ExtendedArgumentOptions>({
 *   name: 'textChannel',
 *   baseArgument: 'channel'
 * })
 * export class TextChannelArgument extends ExtendedArgument<'channel', TextChannel> {
 *   public handle(parsed: Channel, { argument }: ExtendedArgumentContext): Argument.Result<TextChannel> {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed as TextChannel)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel.' });
 *   }
 * }
 * ```
 *
 * @example
 * ```javascript
 * // JavaScript:
 * const { ExtendedArgument } = require('@sapphire/framework');
 *
 * module.exports = class TextChannelArgument extends ExtendedArgument {
 *   constructor(context) {
 *     super(context, { name: 'textChannel', baseArgument: 'channel' });
 *   }
 *
 *   handle(parsed, { argument }) {
 *     return parsed.type === 'text'
 *       ? this.ok(parsed)
 *       : this.error({ identifier: 'ArgumentTextChannelInvalidTextChannel', message: 'The argument did not resolve to a text channel' });
 *   }
 * }
 * ```
 */
declare abstract class ExtendedArgument<K extends keyof ArgType, T> extends Argument<T> {
    baseArgument: K;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    constructor(context: PieceContext, options: ExtendedArgumentOptions<K>);
    /**
     * Represents the underlying argument that transforms the raw argument
     * into the value used to compute the extended argument's value.
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    get base(): IArgument<ArgType[K]>;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    run(parameter: string, context: Argument.Context<T>): Argument.AsyncResult<T>;
    /**
     * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
     */
    abstract handle(parsed: ArgType[K], context: ExtendedArgumentContext): Argument.Result<T>;
}
/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 */
interface ExtendedArgumentOptions<K extends keyof ArgType> extends Argument.Options {
    /**
     * The name of the underlying argument whose value is used to compute
     * the extended argument value; see {@link ArgType} for valid keys.
     */
    baseArgument: K;
}
/**
 * @deprecated {@link ExtendedArgument} is deprecated and will be removed in v3.0.0.
 */
interface ExtendedArgumentContext extends Argument.Context {
    /**
     * The canonical parameter specified by the user in the command, as
     * a string, equivalent to the first parameter of {@link Argument#run}.
     * This allows {@link ExtendedArgument#handle} to access the original
     * argument, which is useful for returning {@link Argument#error} so
     * that you don't have to convert the parsed argument back into a
     * string.
     */
    parameter: string;
}

declare const Events: {
    ChannelCreate: "channelCreate";
    ChannelDelete: "channelDelete";
    ChannelPinsUpdate: "channelPinsUpdate";
    ChannelUpdate: "channelUpdate";
    ClientReady: "ready";
    Debug: "debug";
    Error: "error";
    GuildBanAdd: "guildBanAdd";
    GuildBanRemove: "guildBanRemove";
    GuildCreate: "guildCreate";
    GuildDelete: "guildDelete";
    GuildEmojiCreate: "emojiCreate";
    GuildEmojiDelete: "emojiDelete";
    GuildEmojiUpdate: "emojiUpdate";
    GuildIntegrationsUpdate: "guildIntegrationsUpdate";
    GuildMemberAdd: "guildMemberAdd";
    GuildMemberAvailable: "guildMemberAvailable";
    GuildMemberRemove: "guildMemberRemove";
    GuildMemberUpdate: "guildMemberUpdate";
    GuildMembersChunk: "guildMembersChunk";
    GuildRoleCreate: "roleCreate";
    GuildRoleDelete: "roleDelete";
    GuildRoleUpdate: "roleUpdate";
    GuildUnavailable: "guildUnavailable";
    GuildUpdate: "guildUpdate";
    Invalidated: "invalidated";
    InviteCreate: "inviteCreate";
    InviteDelete: "inviteDelete";
    MessageBulkDelete: "messageDeleteBulk";
    MessageCreate: "messageCreate";
    MessageDelete: "messageDelete";
    MessageReactionAdd: "messageReactionAdd";
    MessageReactionRemoveAll: "messageReactionRemoveAll";
    MessageReactionRemove: "messageReactionRemove";
    MessageUpdate: "messageUpdate";
    PresenceUpdate: "presenceUpdate";
    RateLimit: "rateLimit";
    Raw: "raw";
    ShardDisconnect: "shardDisconnect";
    ShardError: "shardError";
    ShardReady: "shardReady";
    ShardReconnecting: "shardReconnecting";
    ShardResume: "shardResume";
    TypingStart: "typingStart";
    UserUpdate: "userUpdate";
    VoiceStateUpdate: "voiceStateUpdate";
    Warn: "warn";
    WebhooksUpdate: "webhookUpdate";
    CommandAccepted: "commandAccepted";
    CommandDenied: "commandDenied";
    CommandError: "commandError";
    CommandFinish: "commandFinish";
    CommandRun: "commandRun";
    CommandSuccess: "commandSuccess";
    CommandTypingError: "commandTypingError";
    ListenerError: "listenerError";
    MentionPrefixOnly: "mentionPrefixOnly";
    NonPrefixedMessage: "nonPrefixedMessage";
    PiecePostLoad: "piecePostLoad";
    PieceUnload: "pieceUnload";
    PluginLoaded: "pluginLoaded";
    PreCommandRun: "preCommandRun";
    PrefixedMessage: "prefixedMessage";
    PreMessageParsed: "preMessageParsed";
    UnknownCommand: "unknownCommand";
    UnknownCommandName: "unknownCommandName";
};
interface IPieceError {
    piece: Piece;
}
interface ListenerErrorPayload extends IPieceError {
    piece: Listener;
}
interface UnknownCommandNamePayload {
    message: Message;
    prefix: string | RegExp;
    commandPrefix: string;
}
interface UnknownCommandPayload extends UnknownCommandNamePayload {
    commandName: string;
}
interface ICommandPayload {
    message: Message;
    command: Command;
}
interface PreCommandRunPayload extends CommandDeniedPayload {
}
interface CommandDeniedPayload extends ICommandPayload {
    parameters: string;
    context: Command.RunContext;
}
interface CommandAcceptedPayload extends ICommandPayload {
    parameters: string;
    context: Command.RunContext;
}
interface CommandRunPayload<T extends Args = Args> extends CommandAcceptedPayload {
    args: T;
}
interface CommandFinishPayload<T extends Args = Args> extends CommandRunPayload<T> {
}
interface CommandErrorPayload<T extends Args = Args> extends CommandRunPayload<T> {
    piece: Command;
}
interface CommandSuccessPayload<T extends Args = Args> extends CommandRunPayload<T> {
    result: unknown;
}
interface CommandTypingErrorPayload<T extends Args = Args> extends CommandRunPayload<T> {
}
declare module 'discord.js' {
    interface ClientEvents {
        [Events.PieceUnload]: [store: Store<Piece>, piece: Piece];
        [Events.PiecePostLoad]: [store: Store<Piece>, piece: Piece];
        [Events.MentionPrefixOnly]: [message: Message];
        [Events.ListenerError]: [error: unknown, payload: ListenerErrorPayload];
        [Events.PreMessageParsed]: [message: Message];
        [Events.PrefixedMessage]: [message: Message, prefix: string | RegExp];
        [Events.UnknownCommandName]: [payload: UnknownCommandNamePayload];
        [Events.UnknownCommand]: [payload: UnknownCommandPayload];
        [Events.PreCommandRun]: [payload: PreCommandRunPayload];
        [Events.CommandDenied]: [error: UserError, payload: CommandDeniedPayload];
        [Events.CommandAccepted]: [payload: CommandAcceptedPayload];
        [Events.CommandRun]: [message: Message, command: Command, payload: CommandRunPayload];
        [Events.CommandSuccess]: [payload: CommandSuccessPayload];
        [Events.CommandError]: [error: unknown, payload: CommandErrorPayload];
        [Events.CommandFinish]: [message: Message, command: Command, payload: CommandFinishPayload];
        [Events.CommandTypingError]: [error: unknown, payload: CommandTypingErrorPayload];
        [Events.PluginLoaded]: [hook: PluginHook, name: string | undefined];
        [Events.NonPrefixedMessage]: [message: Message];
        [K: string]: unknown[];
    }
}

declare class Logger implements ILogger {
    level: LogLevel;
    constructor(level: LogLevel);
    has(level: LogLevel): boolean;
    trace(...values: readonly unknown[]): void;
    debug(...values: readonly unknown[]): void;
    info(...values: readonly unknown[]): void;
    warn(...values: readonly unknown[]): void;
    error(...values: readonly unknown[]): void;
    fatal(...values: readonly unknown[]): void;
    write(level: LogLevel, ...values: readonly unknown[]): void;
    protected static readonly levels: Map<LogLevel, LogMethods>;
}
declare type LogMethods = 'trace' | 'debug' | 'info' | 'warn' | 'error';

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionAnd: IPreconditionCondition;

/**
 * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 || V1 [|| V2 [|| V3 ...]]).
 * @since 1.0.0
 */
declare const PreconditionConditionOr: IPreconditionCondition;

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: PieceContext) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new ClientPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class ClientPermissionsPrecondition implements PreconditionSingleResolvableDetails<'ClientPermissions'> {
    name: 'ClientPermissions';
    context: {
        permissions: Permissions;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

/**
 * Constructs a contextful permissions precondition requirement.
 * @since 1.0.0
 * @example
 * ```typescript
 * export class CoreCommand extends Command {
 *   public constructor(context: PieceContext) {
 *     super(context, {
 *       preconditions: [
 *         'GuildOnly',
 *         new UserPermissionsPrecondition('ADD_REACTIONS')
 *       ]
 *     });
 *   }
 *
 *   public messageRun(message: Message, args: Args) {
 *     // ...
 *   }
 * }
 * ```
 */
declare class UserPermissionsPrecondition implements PreconditionSingleResolvableDetails<'UserPermissions'> {
    name: 'UserPermissions';
    context: {
        permissions: Permissions;
    };
    /**
     * Constructs a precondition container entry.
     * @param permissions The permissions that will be required by this command.
     */
    constructor(permissions: PermissionResolvable);
}

declare class CorePrecondition$b extends Precondition {
    private readonly dmChannelPermissions;
    run(message: Message, _command: Command, context: PreconditionContext): PreconditionResult;
    static readonly readablePermissions: Record<PermissionString, string>;
}

declare class CorePrecondition$a extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$9 extends Precondition {
    constructor(context: PieceContext);
    run(_: Message, command: Command, context: Precondition.Context): Precondition.Result;
}

declare class CorePrecondition$8 extends Precondition {
    private readonly allowedTypes;
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$7 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$6 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$5 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$4 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$3 extends Precondition {
    private readonly allowedTypes;
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$2 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition$1 extends Precondition {
    run(message: Message): PreconditionResult;
}

declare class CorePrecondition extends Precondition {
    private readonly dmChannelPermissions;
    run(message: Message, _command: Command, context: PreconditionContext): PreconditionResult;
}

//# sourceMappingURL=index.d.ts.map

declare namespace index_d {
  export {
    CorePrecondition$b as ClientPermissions,
    CorePrecondition$c as Cooldown,
    CorePrecondition$a as DMOnly,
    CorePrecondition$9 as Enabled,
    CorePrecondition$8 as GuildNewsOnly,
    CorePrecondition$7 as GuildNewsThreadOnly,
    CorePrecondition$6 as GuildOnly,
    CorePrecondition$5 as GuildPrivateThreadOnly,
    CorePrecondition$4 as GuildPublicThreadOnly,
    CorePrecondition$3 as GuildTextOnly,
    CorePrecondition$2 as GuildThreadOnly,
    CorePrecondition$1 as NSFW,
    CorePrecondition as UserPermissions,
  };
}

/**
 * The [@sapphire/framework](https://github.com/sapphiredev/framework) version that you are currently using.
 * An example use of this is showing it of in a bot information command.
 *
 * Note to Sapphire developers: This needs to explicitly be `string` so it is not typed as the string that gets replaced by Rollup
 */
declare const version: string;

export { ArgOptions, ArgType, Args, ArgsNextCallback, Argument, ArgumentContext, ArgumentError, ArgumentOptions, ArgumentResult, ArgumentStore, AsyncArgumentResult, AsyncPluginHooks, AsyncPreconditionContainerReturn, AsyncPreconditionResult, BucketScope, ClientLoggerOptions, CorePrecondition$b as ClientPermissionsCorePrecondition, ClientPermissionsPrecondition, Command, CommandAcceptedPayload, CommandContext, CommandDeniedPayload, CommandErrorPayload, CommandFinishPayload, CommandJSON, CommandOptions, CommandOptionsRunType, CommandOptionsRunTypeEnum, CommandPreConditions, CommandRunPayload, CommandStore, CommandSuccessPayload, CommandTypingErrorPayload, CooldownContext, CooldownLevel, CooldownOptions, index_d as CorePreconditions, DetailedDescriptionCommand, DetailedDescriptionCommandObject, Err, Events, ExtendedArgument, ExtendedArgumentContext, ExtendedArgumentOptions, IArgument, ICommandPayload, ILogger, IPieceError, IPreconditionCondition, IPreconditionContainer, Identifiers, Listener, ListenerErrorPayload, ListenerJSON, ListenerOptions, ListenerStore, LogLevel, LogMethods, Logger, Maybe, None, Ok, Plugin, PluginHook, PluginManager, PreCommandRunPayload, Precondition, PreconditionArrayResolvable, PreconditionArrayResolvableDetails, PreconditionConditionAnd, PreconditionConditionOr, PreconditionContainerArray, PreconditionContainerResult, PreconditionContainerReturn, PreconditionContainerSingle, PreconditionContext, PreconditionEntryResolvable, PreconditionError, PreconditionKeys, PreconditionOptions, PreconditionResult, PreconditionRunCondition, PreconditionRunMode, PreconditionSingleResolvable, PreconditionSingleResolvableDetails, PreconditionStore, Preconditions, RepeatArgOptions, index_d$1 as Resolvers, Result, SapphireClient, SapphireClientOptions, SapphirePluginAsyncHook, SapphirePluginHook, SapphirePluginHookEntry, SapphirePrefix, SapphirePrefixHook, SimplePreconditionKeys, SimplePreconditionSingleResolvableDetails, Some, SyncPluginHooks, UnknownCommandNamePayload, UnknownCommandPayload, UserError, UserPermissionsPrecondition, err, from, fromAsync, isErr, isMaybe, isNone, isOk, isSome, maybe, none, ok, postInitialization, postLogin, preGenericsInitialization, preInitialization, preLogin, some, version };
