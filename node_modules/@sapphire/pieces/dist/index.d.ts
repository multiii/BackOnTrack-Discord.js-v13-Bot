import Collection from '@discordjs/collection';
import { Awaitable, Constructor, Ctor } from '@sapphire/utilities';

declare const enum LoaderErrorType {
    EmptyModule = "EMPTY_MODULE",
    UnloadedPiece = "UNLOADED_PIECE",
    IncorrectType = "INCORRECT_TYPE"
}
/**
 * Describes a loader error with a type for easy indentification.
 */
declare class LoaderError extends Error {
    /**
     * The type of the error that was thrown.
     */
    readonly type: LoaderErrorType;
    constructor(type: LoaderErrorType, message: string);
    get name(): string;
}

/**
 * Describes a {@link LoaderErrorType.EmptyModule} loader error and adds a path for easy identification.
 */
declare class MissingExportsError extends LoaderError {
    /**
     * The path of the module that did not have exports.
     */
    readonly path: string;
    constructor(path: string);
}

declare function getRootData(): RootData;
interface RootData {
    root: string;
    type: 'ESM' | 'CommonJS';
}

/**
 * The metadata class used for {@link Piece}s.
 */
declare class PieceLocation {
    /**
     * The full path to the file.
     */
    readonly full: string;
    /**
     * The root directory the file was found from.
     */
    readonly root: string;
    /**
     * @param full The full path to the file.
     * @param root The root directory the file was found from.
     */
    constructor(full: string, root: string);
    /**
     * The relative path between {@link PieceLocation.root} and {@link PieceLocation.full}.
     * @example
     * ```typescript
     * const location = new PieceLocation(
     * 	'/usr/src/app/commands',
     * 	'/usr/src/app/commands/general/ping.js'
     * );
     *
     * console.log(location.relative);
     * // → 'general/ping.js'
     * ```
     */
    get relative(): string;
    /**
     * The names of the directories that separate {@link PieceLocation.root} and {@link PieceLocation.full}.
     * @example
     * ```typescript
     * const location = new PieceLocation(
     * 	'/usr/src/app/commands',
     * 	'/usr/src/app/commands/games/multiplayer/connect-four.js'
     * );
     *
     * console.log(location.directories);
     * // → ['games', 'multiplayer']
     * ```
     */
    get directories(): string[];
    /**
     * The name and extension of the file that was loaded, extracted from {@link PieceLocation.full}.
     * @example
     * ```typescript
     * const location = new PieceLocation(
     * 	'/usr/src/app/commands',
     * 	'/usr/src/app/commands/games/multiplayer/connect-four.js'
     * );
     *
     * console.log(location.name);
     * // → 'connect-four.js'
     * ```
     */
    get name(): string;
    /**
     * Defines the `JSON.stringify` behavior of this structure.
     */
    toJSON(): PieceLocationJSON;
}
/**
 * The return type of {@link PieceLocation.toJSON}.
 */
interface PieceLocationJSON {
    directories: string[];
    full: string;
    name: string;
    relative: string;
    root: string;
}

/**
 * The module data information.
 */
interface ModuleData {
    /**
     * The name of the module.
     */
    name: string;
    /**
     * The absolute path to the module.
     */
    path: string;
    /**
     * The extension of the module.
     */
    extension: string;
}
/**
 * The hydrated module data.
 */
interface HydratedModuleData extends ModuleData {
    /**
     * The directory the module was loaded from.
     */
    root: string;
}
/**
 * The result from the filter.
 */
declare type FilterResult = ModuleData | null;
/**
 * Represents the return data from {@link ILoaderStrategy.preload}
 */
declare type PreloadResult<T extends Piece> = Awaitable<Constructor<T> & Record<PropertyKey, unknown>>;
/**
 * Represents the return data from {@link ILoaderStrategy.preload}
 */
declare type AsyncPreloadResult<T extends Piece> = Promise<Constructor<T> & Record<PropertyKey, unknown>>;
/**
 * Represents an entry from {@link ILoaderResult}.
 */
declare type ILoaderResultEntry<T extends Piece> = Ctor<ConstructorParameters<typeof Piece>, T>;
/**
 * Represents the return data from {@link ILoaderStrategy.load}.
 */
declare type ILoaderResult<T extends Piece> = AsyncIterableIterator<ILoaderResultEntry<T>>;
/**
 * An abstracted loader strategy interface.
 */
interface ILoaderStrategy<T extends Piece> {
    /**
     * Retrieves the name and the extension of the specified file path.
     * @param path The path of the file to be processed.
     * @return A {@link ModuleData} on success, otherwise `null` to stop the store from processing the path.
     * @example
     * ```typescript
     * // ts-node support
     * class MyStrategy extends LoaderStrategy {
     *   filter(path) {
     *     const extension = extname(path);
     *     if (!['.js', '.ts'].includes(extension)) return null;
     *     const name = basename(path, extension);
     *     return { extension, name };
     *   }
     * }
     * ```
     */
    filter(path: string): FilterResult;
    /**
     * The pre-load hook, use this to override the loader.
     * @example
     * ```typescript
     * // CommonJS support:
     * class MyStrategy extends LoaderStrategy {
     *   preload(path) {
     *     return require(path);
     *   }
     * }
     * ```
     * @example
     * ```typescript
     * // ESM support:
     * class MyStrategy extends LoaderStrategy {
     *   preload(file) {
     *     return import(file.path);
     *   }
     * }
     * ```
     */
    preload(file: ModuleData): PreloadResult<T>;
    /**
     * The load hook, use this to override the loader.
     * @example
     * ```typescript
     * class MyStrategy extends LoaderStrategy {
     *   load(store, file) {
     *     // ...
     *   }
     * }
     * ```
     */
    load(store: Store<T>, file: HydratedModuleData): ILoaderResult<T>;
    /**
     * Called after a piece has been loaded, but before {@link Piece.onLoad} and {@link Store.set}.
     * @param store The store that holds the piece.
     * @param piece The piece that was loaded.
     */
    onLoad(store: Store<T>, piece: T): Awaitable<unknown>;
    /**
     * Called after all pieces have been loaded.
     * @param store The store that loaded all pieces.
     */
    onLoadAll(store: Store<T>): Awaitable<unknown>;
    /**
     * Called after a piece has been unloaded or overwritten by a newly loaded piece.
     * @param store The store that held the piece.
     * @param piece The piece that was unloaded.
     */
    onUnload(store: Store<T>, piece: T): Awaitable<unknown>;
    /**
     * Called after all pieces have been unloaded.
     * @param store The store that unloaded all pieces.
     */
    onUnloadAll(store: Store<T>): Awaitable<unknown>;
    /**
     * @param error The error that was thrown.
     * @param path The path of the file that caused the error to be thrown.
     */
    onError(error: Error, path: string): void;
}

/**
 * The options for the store, this features both hooks (changes the behaviour) and handlers (similar to event listeners).
 */
interface StoreOptions<T extends Piece> {
    /**
     * The name for this store.
     */
    readonly name: string;
    /**
     * The paths to load pieces from, should be absolute.
     * @default []
     */
    readonly paths?: readonly string[];
    /**
     * The strategy to be used for the loader.
     * @default Store.defaultStrategy
     */
    readonly strategy?: ILoaderStrategy<T>;
}
/**
 * An interface representing a logger function.
 */
interface StoreLogger {
    /**
     * @param value The string to print. All strings will be formatted with the format `[STORE => ${name}] [${type}] ${content}`,
     * where the content may have identifiers (values or names of methods) surrounded by `'`. For example:
     *
     * - `[STORE => commands] [LOAD] Skipped piece '/home/user/bot/src/commands/foo.js' as 'LoaderStrategy#filter' returned 'null'.`
     * - `[STORE => commands] [INSERT] Unloaded new piece 'foo' due to 'enabled' being 'false'.`
     * - `[STORE => commands] [UNLOAD] Unloaded piece 'foo'.`
     */
    (value: string): void;
}
/**
 * The store class which contains {@link Piece}s.
 */
declare class Store<T extends Piece> extends Collection<string, T> {
    readonly Constructor: Constructor<T>;
    readonly name: string;
    readonly paths: Set<string>;
    readonly strategy: ILoaderStrategy<T>;
    /**
     * @param constructor The piece constructor this store loads.
     * @param options The options for the store.
     */
    constructor(constructor: Constructor<T>, options: StoreOptions<T>);
    /**
     * A reference to the {@link Container} object for ease of use.
     * @see container
     */
    get container(): Container;
    /**
     * Registers a directory into the store.
     * @param path The path to be added.
     * @example
     * ```typescript
     * store
     *   .registerPath(resolve('commands'))
     *   .registerPath(resolve('third-party', 'commands'));
     * ```
     */
    registerPath(path: string): this;
    /**
     * Loads one or more pieces from a path.
     * @param root The root directory the file is from.
     * @param path The path of the file to load, relative to the `root`.
     * @return All the loaded pieces.
     */
    load(root: string, path: string): Promise<T[]>;
    /**
     * Unloads a piece given its instance or its name.
     * @param name The name of the file to load.
     * @return Returns the piece that was unloaded.
     */
    unload(name: string | T): Promise<T>;
    /**
     * Unloads all pieces from the store.
     */
    unloadAll(): Promise<T[]>;
    /**
     * Loads all pieces from all directories specified by {@link paths}.
     */
    loadAll(): Promise<void>;
    /**
     * Resolves a piece by its name or its instance.
     * @param name The name of the piece or the instance itself.
     * @return The resolved piece.
     */
    resolve(name: string | T): T;
    /**
     * Inserts a piece into the store.
     * @param piece The piece to be inserted into the store.
     * @return The inserted piece.
     */
    insert(piece: T): Promise<T>;
    /**
     * Constructs a {@link Piece} instance.
     * @param Ctor The {@link Piece}'s constructor used to build the instance.
     * @param data The module's information
     * @return An instance of the constructed piece.
     */
    construct(Ctor: ILoaderResultEntry<T>, data: HydratedModuleData): T;
    /**
     * Adds the final module data properties.
     * @param root The root directory to add.
     * @param data The module data returned from {@link ILoaderStrategy.filter}.
     * @returns The finished module data.
     */
    private hydrateModuleData;
    /**
     * Loads a directory into the store.
     * @param root The directory to load the pieces from.
     * @return An async iterator that yields the pieces to be loaded into the store.
     */
    private loadPath;
    /**
     * Retrieves all possible pieces.
     * @param path The directory to load the pieces from.
     * @return An async iterator that yields the modules to be processed and loaded into the store.
     */
    private walk;
    /**
     * The default strategy, defaults to {@link LoaderStrategy}, which is constructed on demand when a store is constructed,
     * when none was set beforehand.
     */
    static defaultStrategy: ILoaderStrategy<any>;
    /**
     * The default logger, defaults to `null`.
     */
    static logger: StoreLogger | null;
}
declare namespace Store {
    const Registry: typeof StoreRegistry;
    type Options<T extends Piece> = StoreOptions<T>;
    type Logger = StoreLogger;
    type RegistryEntries = StoreRegistryEntries;
}

/**
 * The context for the piece, contains extra information from the store,
 * the piece's path, and the store that loaded it.
 */
interface PieceContext {
    /**
     * The root directory the piece was loaded from.
     */
    readonly root: string;
    /**
     * The path the module was loaded from, relative to {@link PieceContext.root}.
     */
    readonly path: string;
    /**
     * The module's name extracted from the path.
     */
    readonly name: string;
    /**
     * The store that loaded the piece.
     */
    readonly store: Store<Piece>;
}
/**
 * The options for the {@link Piece}.
 */
interface PieceOptions {
    /**
     * The name for the piece.
     * @default ''
     */
    readonly name?: string;
    /**
     * Whether or not the piece should be enabled. If set to false, the piece will be unloaded.
     * @default true
     */
    readonly enabled?: boolean;
}
/**
 * The return type of {@link Piece.toJSON}.
 */
interface PieceJSON {
    location: PieceLocationJSON;
    name: string;
    enabled: boolean;
    options: PieceOptions;
}
/**
 * The piece to be stored in {@link Store} instances.
 */
declare class Piece<O extends PieceOptions = PieceOptions> {
    /**
     * The store that contains the piece.
     */
    readonly store: Store<Piece>;
    /**
     * The location metadata for the piece's file.
     */
    readonly location: PieceLocation;
    /**
     * The name of the piece.
     */
    readonly name: string;
    /**
     * Whether or not the piece is enabled.
     */
    enabled: boolean;
    /**
     * The raw options passed to this {@link Piece}
     */
    readonly options: O;
    constructor(context: PieceContext, options?: PieceOptions);
    /**
     * A reference to the {@link Container} object for ease of use.
     * @see container
     */
    get container(): Container;
    /**
     * Per-piece listener that is called when the piece is loaded into the store.
     * Useful to set-up asynchronous initialization tasks.
     */
    onLoad(): Awaitable<unknown>;
    /**
     * Per-piece listener that is called when the piece is unloaded from the store.
     * Useful to set-up clean-up tasks.
     */
    onUnload(): Awaitable<unknown>;
    /**
     * Unloads and disables the piece.
     */
    unload(): Promise<void>;
    /**
     * Reloads the piece by loading the same path in the store.
     */
    reload(): Promise<void>;
    /**
     * Defines the `JSON.stringify` behavior of this piece.
     */
    toJSON(): PieceJSON;
}
declare namespace Piece {
    const Location: typeof PieceLocation;
    type Options = PieceOptions;
    type Context = PieceContext;
    type JSON = PieceJSON;
    type LocationJSON = PieceLocationJSON;
}

declare type Key = keyof StoreRegistryEntries;
declare type Value = StoreRegistryEntries[Key];
/**
 * A strict-typed store registry. This is available in {@link container}.
 * @since 2.1.0
 * @example
 * ```typescript
 * // Adding new stores
 *
 * // Register the store:
 * container.stores.register(new RouteStore());
 *
 * // Augment Sapphire to add the new store, in case of a JavaScript
 * // project, this can be moved to an `Augments.d.ts` (or any other name)
 * // file somewhere:
 * declare module '@sapphire/pieces' {
 *   export interface StoreRegistryEntries {
 *     routes: RouteStore;
 *   }
 * }
 * ```
 */
declare class StoreRegistry extends Collection<Key, Value> {
    /**
     * Loads all the registered stores.
     * @since 2.1.0
     */
    load(): Promise<void>;
    /**
     * Registers all user directories from the process working directory, the default value is obtained by assuming
     * CommonJS (high accuracy) but with fallback for ECMAScript Modules (reads package.json's `main` entry, fallbacks
     * to `process.cwd()`).
     *
     * By default, if you have this folder structure:
     * ```
     * /home/me/my-bot
     * ├─ src
     * │  ├─ commands
     * │  ├─ events
     * │  └─ main.js
     * └─ package.json
     * ```
     *
     * And you run `node src/main.js`, the directories `/home/me/my-bot/src/commands` and `/home/me/my-bot/src/events` will
     * be registered for the commands and events stores respectively, since both directories are located in the same
     * directory as your main file.
     *
     * **Note**: this also registers directories for all other stores, even if they don't have a folder, this allows you
     * to create new pieces and hot-load them later anytime.
     * @since 2.1.0
     * @param rootDirectory The root directory to register pieces at.
     */
    registerPath(rootDirectory?: string): void;
    /**
     * Registers a store.
     * @since 2.1.0
     * @param store The store to register.
     */
    register<T extends Piece>(store: Store<T>): this;
    /**
     * Deregisters a store.
     * @since 2.1.0
     * @param store The store to deregister.
     */
    deregister<T extends Piece>(store: Store<T>): this;
}
interface StoreRegistry {
    get<K extends Key>(key: K): StoreRegistryEntries[K];
    get(key: string): undefined;
    has(key: Key): true;
    has(key: string): false;
}
/**
 * The {@link StoreRegistry}'s registry, use module augmentation against this interface when adding new stores.
 * @since 2.1.0
 */
interface StoreRegistryEntries {
}

/**
 * Represents the type of the properties injected into the container, which is available at {@link container}.
 *
 * Because Sapphire works as a standalone framework (independent of external libraries), there is a need to pass data
 * from one place to another, which would vary depending on the user and their use-cases.
 *
 * Furthermore, plugins may use this structure to add properties referencing to the plugin's objects so they can be
 * accessed by both the user and the plugin at any moment and at any place.
 *
 * Finally, both library developers and bot developers should augment the Container interface from this module using
 * [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).
 */
interface Container {
    stores: StoreRegistry;
}
/**
 * The injected variables that will be accessible to any place. To add an extra property, simply add a property with a
 * regular assignment, and it will be available in all places simultaneously.
 *
 * @example
 * ```typescript
 * // Add a reference for the version:
 * import { container } from '@sapphire/pieces';
 *
 * container.version = '1.0.0';
 *
 * // Can be placed anywhere in a TypeScript file, for JavaScript projects,
 * // you can create an `augments.d.ts` and place the code there.
 * declare module '@sapphire/pieces' {
 *   interface Container {
 *     version: string;
 *   }
 * }
 *
 * // In any piece, core, plugin, or custom:
 * export class UserCommand extends Command {
 *   public run(message, args) {
 *     // The injected version is available here:
 *     const { version } = this.container;
 *
 *     // ...
 *   }
 * }
 * ```
 *
 * @example
 * ```typescript
 * // In a plugin's context, e.g. API:
 * class Api extends Plugin {
 *   static [postInitialization]() {
 *     const server = new Server(this);
 *     container.server = server;
 *
 *     // ...
 *   }
 * }
 *
 * declare module '@sapphire/pieces' {
 *   interface Container {
 *     server: Server;
 *   }
 * }
 *
 * // In any piece, even those that aren't routes nor middlewares:
 * export class UserRoute extends Route {
 *   public [methods.POST](message, args) {
 *     // The injected server is available here:
 *     const { server } = this.container;
 *
 *     // ...
 *   }
 * }
 * ```
 */
declare const container: Container;

/**
 * A multi-purpose feature-complete loader strategy supporting multi-piece modules as well as supporting both ECMAScript
 * Modules and CommonJS with reloading support.
 */
declare class LoaderStrategy<T extends Piece> implements ILoaderStrategy<T> {
    clientUsesESModules: boolean;
    supportedExtensions: string[];
    private readonly filterDtsFiles;
    constructor();
    filter(path: string): FilterResult;
    preload(file: ModuleData): AsyncPreloadResult<T>;
    load(store: Store<T>, file: ModuleData): ILoaderResult<T>;
    onLoad(): unknown;
    onLoadAll(): unknown;
    onUnload(): unknown;
    onUnloadAll(): unknown;
    onError(error: Error, path: string): void;
}

interface AliasPieceOptions extends Piece.Options {
    /**
     * The aliases for the piece.
     * @default []
     */
    readonly aliases?: readonly string[];
}
/**
 * The return type of {@link AliasPiece.toJSON}.
 */
interface AliasPieceJSON extends Piece.JSON {
    aliases: string[];
    options: AliasPieceOptions;
}
/**
 * The piece to be stored in {@link AliasStore} instances.
 */
declare class AliasPiece<O extends AliasPieceOptions = AliasPieceOptions> extends Piece<O> {
    /**
     * The aliases for the piece.
     */
    aliases: readonly string[];
    constructor(context: Piece.Context, options?: AliasPieceOptions);
    /**
     * Defines the `JSON.stringify` behavior of this alias piece.
     */
    toJSON(): AliasPieceJSON;
}
declare namespace AliasPiece {
    const Location: typeof PieceLocation;
    type Options = AliasPieceOptions;
    type Context = Piece.Context;
    type JSON = AliasPieceJSON;
    type LocationJSON = Piece.LocationJSON;
}

/**
 * The store class which contains {@link AliasPiece}s.
 */
declare class AliasStore<T extends AliasPiece> extends Store<T> {
    /**
     * The aliases referencing to pieces.
     */
    readonly aliases: Collection<string, T>;
    /**
     * Looks up the name by the store, falling back to an alias lookup.
     * @param key The key to look for.
     */
    get(key: string): T | undefined;
    /**
     * Checks whether a key is in the store, or is an alias
     * @param key The key to check
     */
    has(key: string): boolean;
    /**
     * Unloads a piece given its instance or its name, and removes all the aliases.
     * @param name The name of the file to load.
     * @return Returns the piece that was unloaded.
     */
    unload(name: string | T): Promise<T>;
    /**
     * Inserts a piece into the store, and adds all the aliases.
     * @param piece The piece to be inserted into the store.
     * @return The inserted piece.
     */
    insert(piece: T): Promise<T>;
}

export { AliasPiece, AliasPieceJSON, AliasPieceOptions, AliasStore, AsyncPreloadResult, Container, FilterResult, HydratedModuleData, ILoaderResult, ILoaderResultEntry, ILoaderStrategy, LoaderError, LoaderErrorType, LoaderStrategy, MissingExportsError, ModuleData, Piece, PieceContext, PieceJSON, PieceLocation, PieceLocationJSON, PieceOptions, PreloadResult, RootData, Store, StoreLogger, StoreOptions, StoreRegistry, StoreRegistryEntries, container, getRootData };
