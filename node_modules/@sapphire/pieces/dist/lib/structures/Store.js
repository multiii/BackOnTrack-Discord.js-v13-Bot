"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Store = void 0;
const tslib_1 = require("tslib");
const collection_1 = tslib_1.__importDefault(require("@discordjs/collection"));
const fs_1 = require("fs");
const path_1 = require("path");
const LoaderError_1 = require("../errors/LoaderError");
const Container_1 = require("../shared/Container");
const LoaderStrategy_1 = require("../strategies/LoaderStrategy");
const StoreRegistry_1 = require("./StoreRegistry");
/**
 * The store class which contains {@link Piece}s.
 */
class Store extends collection_1.default {
    /**
     * @param constructor The piece constructor this store loads.
     * @param options The options for the store.
     */
    constructor(constructor, options) {
        super();
        Object.defineProperty(this, "Constructor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "paths", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "strategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.Constructor = constructor;
        this.name = options.name;
        this.paths = new Set(options.paths ?? []);
        this.strategy = options.strategy ?? Store.defaultStrategy;
    }
    /**
     * A reference to the {@link Container} object for ease of use.
     * @see container
     */
    get container() {
        return Container_1.container;
    }
    /**
     * Registers a directory into the store.
     * @param path The path to be added.
     * @example
     * ```typescript
     * store
     *   .registerPath(resolve('commands'))
     *   .registerPath(resolve('third-party', 'commands'));
     * ```
     */
    registerPath(path) {
        this.paths.add(path);
        Store.logger?.(`[STORE => ${this.name}] [REGISTER] Registered path '${path}'.`);
        return this;
    }
    /**
     * Loads one or more pieces from a path.
     * @param root The root directory the file is from.
     * @param path The path of the file to load, relative to the `root`.
     * @return All the loaded pieces.
     */
    async load(root, path) {
        const full = (0, path_1.join)(root, path);
        const data = this.strategy.filter(full);
        if (data === null) {
            Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${full}' as 'LoaderStrategy#filter' returned 'null'.`);
            return [];
        }
        const promises = [];
        const finishedData = this.hydrateModuleData(root, data);
        for await (const Ctor of this.strategy.load(this, finishedData)) {
            promises.push(this.insert(this.construct(Ctor, finishedData)));
        }
        return Promise.all(promises);
    }
    /**
     * Unloads a piece given its instance or its name.
     * @param name The name of the file to load.
     * @return Returns the piece that was unloaded.
     */
    async unload(name) {
        const piece = this.resolve(name);
        // Unload piece:
        this.strategy.onUnload(this, piece);
        await piece.onUnload();
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Unloaded piece '${piece.name}'.`);
        // Remove from cache and return it:
        this.delete(piece.name);
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD] Removed piece '${piece.name}'.`);
        return piece;
    }
    /**
     * Unloads all pieces from the store.
     */
    async unloadAll() {
        const promises = [];
        for (const piece of this.values()) {
            promises.push(this.unload(piece));
        }
        const results = await Promise.all(promises);
        this.strategy.onUnloadAll(this);
        Store.logger?.(`[STORE => ${this.name}] [UNLOAD-ALL] Removed all pieces.`);
        return results;
    }
    /**
     * Loads all pieces from all directories specified by {@link paths}.
     */
    async loadAll() {
        const pieces = [];
        for (const path of this.paths) {
            for await (const piece of this.loadPath(path)) {
                pieces.push(piece);
            }
        }
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Found '${pieces.length}' pieces.`);
        // Clear the store before inserting the new pieces:
        await this.unloadAll();
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Cleared all pieces.`);
        // Load each piece:
        for (const piece of pieces) {
            await this.insert(piece);
        }
        // Call onLoadAll:
        this.strategy.onLoadAll(this);
        Store.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Successfully loaded '${this.size}' pieces.`);
    }
    /**
     * Resolves a piece by its name or its instance.
     * @param name The name of the piece or the instance itself.
     * @return The resolved piece.
     */
    resolve(name) {
        if (typeof name === 'string') {
            const result = this.get(name);
            if (typeof result === 'undefined')
                throw new LoaderError_1.LoaderError("UNLOADED_PIECE" /* UnloadedPiece */, `The piece '${name}' does not exist.`);
            return result;
        }
        if (name instanceof this.Constructor)
            return name;
        throw new LoaderError_1.LoaderError("INCORRECT_TYPE" /* IncorrectType */, `The piece '${name.name}' is not an instance of '${this.Constructor.name}'.`);
    }
    /**
     * Inserts a piece into the store.
     * @param piece The piece to be inserted into the store.
     * @return The inserted piece.
     */
    async insert(piece) {
        if (!piece.enabled)
            return piece;
        // Load piece:
        this.strategy.onLoad(this, piece);
        await piece.onLoad();
        Store.logger?.(`[STORE => ${this.name}] [INSERT] Loaded new piece '${piece.name}'.`);
        // If the onLoad disabled the piece, call unload and return it:
        if (!piece.enabled) {
            // Unload piece:
            this.strategy.onUnload(this, piece);
            await piece.onUnload();
            Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded new piece '${piece.name}' due to 'enabled' being 'false'.`);
            return piece;
        }
        // Unload existing piece, if any:
        const previous = super.get(piece.name);
        if (previous) {
            await this.unload(previous);
            Store.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded existing piece '${piece.name}' due to conflicting 'name'.`);
        }
        // Set the new piece and return it:
        this.set(piece.name, piece);
        Store.logger?.(`[STORE => ${this.name}] [INSERT] Inserted new piece '${piece.name}'.`);
        return piece;
    }
    /**
     * Constructs a {@link Piece} instance.
     * @param Ctor The {@link Piece}'s constructor used to build the instance.
     * @param data The module's information
     * @return An instance of the constructed piece.
     */
    construct(Ctor, data) {
        return new Ctor({ store: this, root: data.root, path: data.path, name: data.name }, { name: data.name, enabled: true });
    }
    /**
     * Adds the final module data properties.
     * @param root The root directory to add.
     * @param data The module data returned from {@link ILoaderStrategy.filter}.
     * @returns The finished module data.
     */
    hydrateModuleData(root, data) {
        return { root, ...data };
    }
    /**
     * Loads a directory into the store.
     * @param root The directory to load the pieces from.
     * @return An async iterator that yields the pieces to be loaded into the store.
     */
    async *loadPath(root) {
        Store.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${root}'.`);
        for await (const child of this.walk(root)) {
            const data = this.strategy.filter(child);
            if (data === null) {
                Store.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${child}' as 'LoaderStrategy#filter' returned 'null'.`);
                continue;
            }
            try {
                const finishedData = this.hydrateModuleData(root, data);
                for await (const Ctor of this.strategy.load(this, finishedData)) {
                    yield this.construct(Ctor, finishedData);
                }
            }
            catch (error) {
                this.strategy.onError(error, data.path);
            }
        }
    }
    /**
     * Retrieves all possible pieces.
     * @param path The directory to load the pieces from.
     * @return An async iterator that yields the modules to be processed and loaded into the store.
     */
    async *walk(path) {
        Store.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${path}'.`);
        try {
            const dir = await fs_1.promises.opendir(path);
            for await (const item of dir) {
                if (item.isFile())
                    yield (0, path_1.join)(dir.path, item.name);
                else if (item.isDirectory())
                    yield* this.walk((0, path_1.join)(dir.path, item.name));
            }
        }
        catch (error) {
            // Specifically ignore ENOENT, which is commonly raised by fs operations
            // to indicate that a component of the specified pathname does not exist.
            // No entity (file or directory) could be found by the given path.
            if (error.code !== 'ENOENT')
                this.strategy.onError(error, path);
        }
    }
}
exports.Store = Store;
/**
 * The default strategy, defaults to {@link LoaderStrategy}, which is constructed on demand when a store is constructed,
 * when none was set beforehand.
 */
Object.defineProperty(Store, "defaultStrategy", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new LoaderStrategy_1.LoaderStrategy()
});
/**
 * The default logger, defaults to `null`.
 */
Object.defineProperty(Store, "logger", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: null
});
(function (Store) {
    Store.Registry = StoreRegistry_1.StoreRegistry;
})(Store = exports.Store || (exports.Store = {}));
//# sourceMappingURL=Store.js.map