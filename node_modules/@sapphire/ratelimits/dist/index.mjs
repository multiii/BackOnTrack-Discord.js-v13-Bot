var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/lib/RateLimit.ts
var RateLimit = class {
  constructor(manager) {
    __publicField(this, "remaining");
    __publicField(this, "expires");
    __publicField(this, "manager");
    this.manager = manager;
    this.reset();
  }
  get expired() {
    return this.remainingTime === 0;
  }
  get limited() {
    return this.remaining === 0 && !this.expired;
  }
  get remainingTime() {
    return Math.max(this.expires - Date.now(), 0);
  }
  consume() {
    if (this.limited)
      throw new Error("Cannot consume a limited bucket");
    if (this.expired)
      this.reset();
    this.remaining--;
    return this;
  }
  reset() {
    return this.resetRemaining().resetTime();
  }
  resetRemaining() {
    this.remaining = this.manager.limit;
    return this;
  }
  resetTime() {
    this.expires = Date.now() + this.manager.time;
    return this;
  }
};

// src/lib/RateLimitManager.ts
import { TimerManager } from "@sapphire/time-utilities";
var _RateLimitManager = class extends Map {
  constructor(time, limit = 1) {
    super();
    __publicField(this, "time");
    __publicField(this, "limit");
    __publicField(this, "sweepInterval");
    this.time = time;
    this.limit = limit;
  }
  acquire(id) {
    return this.get(id) ?? this.create(id);
  }
  create(id) {
    const value = new RateLimit(this);
    this.set(id, value);
    return value;
  }
  set(id, value) {
    this.sweepInterval ?? (this.sweepInterval = TimerManager.setInterval(this.sweep.bind(this), _RateLimitManager.sweepIntervalDuration));
    return super.set(id, value);
  }
  sweep() {
    for (const [id, value] of this.entries()) {
      if (value.expired)
        this.delete(id);
    }
    if (this.size === 0) {
      TimerManager.clearInterval(this.sweepInterval);
      this.sweepInterval = null;
    }
  }
};
var RateLimitManager = _RateLimitManager;
__publicField(RateLimitManager, "sweepIntervalDuration", 3e4);
export {
  RateLimit,
  RateLimitManager
};
//# sourceMappingURL=index.mjs.map