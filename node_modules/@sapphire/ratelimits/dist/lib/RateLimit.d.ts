import type { RateLimitManager } from './RateLimitManager';
export declare class RateLimit<K = string> {
    /**
     * The remaining amount of times this entry can be dripped before the bucket is empty.
     */
    remaining: number;
    /**
     * The timestamp that represents when this entry will reset back to a available state.
     */
    expires: number;
    /**
     * The {@link RateLimitManager} this entry is for.
     */
    private manager;
    /**
     * @param manager The manager for this entry.
     */
    constructor(manager: RateLimitManager<K>);
    /**
     * Whether this entry is expired or not, allowing the bucket to be reset.
     */
    get expired(): boolean;
    /**
     * Whether this entry is limited or not.
     */
    get limited(): boolean;
    /**
     * The remaining time in milliseconds before resetting.
     */
    get remainingTime(): number;
    /**
     * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.
     */
    consume(): this;
    /**
     * Resets the entry back to it's full state.
     */
    reset(): this;
    /**
     * Resets the entry's {@link RateLimit.remaining} uses back to full state.
     */
    resetRemaining(): this;
    /**
     * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.
     */
    resetTime(): this;
}
//# sourceMappingURL=RateLimit.d.ts.map