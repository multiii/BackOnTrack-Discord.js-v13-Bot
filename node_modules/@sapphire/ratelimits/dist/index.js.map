{"version":3,"sources":["../src/index.ts","../src/lib/RateLimit.ts","../src/lib/RateLimitManager.ts"],"sourcesContent":["export * from './lib/RateLimit';\nexport * from './lib/RateLimitManager';\n","import type { RateLimitManager } from './RateLimitManager';\n\nexport class RateLimit<K = string> {\n\t/**\n\t * The remaining amount of times this entry can be dripped before the bucket is empty.\n\t */\n\tpublic remaining!: number;\n\n\t/**\n\t * The timestamp that represents when this entry will reset back to a available state.\n\t */\n\tpublic expires!: number;\n\n\t/**\n\t * The {@link RateLimitManager} this entry is for.\n\t */\n\tprivate manager: RateLimitManager<K>;\n\n\t/**\n\t * @param manager The manager for this entry.\n\t */\n\tpublic constructor(manager: RateLimitManager<K>) {\n\t\tthis.manager = manager;\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Whether this entry is expired or not, allowing the bucket to be reset.\n\t */\n\tpublic get expired(): boolean {\n\t\treturn this.remainingTime === 0;\n\t}\n\n\t/**\n\t * Whether this entry is limited or not.\n\t */\n\tpublic get limited(): boolean {\n\t\treturn this.remaining === 0 && !this.expired;\n\t}\n\n\t/**\n\t * The remaining time in milliseconds before resetting.\n\t */\n\tpublic get remainingTime(): number {\n\t\treturn Math.max(this.expires - Date.now(), 0);\n\t}\n\n\t/**\n\t * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.\n\t */\n\tpublic consume(): this {\n\t\tif (this.limited) throw new Error('Cannot consume a limited bucket');\n\t\tif (this.expired) this.reset();\n\n\t\tthis.remaining--;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry back to it's full state.\n\t */\n\tpublic reset(): this {\n\t\treturn this.resetRemaining().resetTime();\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.remaining} uses back to full state.\n\t */\n\tpublic resetRemaining(): this {\n\t\tthis.remaining = this.manager.limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.\n\t */\n\tpublic resetTime(): this {\n\t\tthis.expires = Date.now() + this.manager.time;\n\t\treturn this;\n\t}\n}\n","import { TimerManager } from '@sapphire/time-utilities';\nimport { RateLimit } from './RateLimit';\n\nexport class RateLimitManager<K = string> extends Map<K, RateLimit<K>> {\n\t/**\n\t * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.\n\t */\n\tpublic readonly time: number;\n\n\t/**\n\t * The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic readonly limit: number;\n\n\t/**\n\t * The interval to sweep expired {@link RateLimit ratelimits}.\n\t */\n\tprivate sweepInterval!: NodeJS.Timer | null;\n\n\t/**\n\t * @param time The amount of milliseconds for the ratelimits from this manager to expire.\n\t * @param limit The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic constructor(time: number, limit = 1) {\n\t\tsuper();\n\n\t\tthis.time = time;\n\t\tthis.limit = limit;\n\t}\n\n\t/**\n\t * Gets a {@link RateLimit} from this manager or creates it if it does not exist.\n\t * @param id The id for the {@link RateLimit}\n\t */\n\tpublic acquire(id: K): RateLimit<K> {\n\t\treturn this.get(id) ?? this.create(id);\n\t}\n\n\t/**\n\t * Creates a {@link RateLimit} for this manager.\n\t * @param id The id the {@link RateLimit} belongs to\n\t */\n\tpublic create(id: K): RateLimit<K> {\n\t\tconst value = new RateLimit(this);\n\t\tthis.set(id, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.\n\t * @param id The id the {@link RateLimit} belongs to\n\t * @param value The {@link RateLimit} to set\n\t */\n\tpublic override set(id: K, value: RateLimit<K>): this {\n\t\tthis.sweepInterval ??= TimerManager.setInterval(this.sweep.bind(this), RateLimitManager.sweepIntervalDuration);\n\t\treturn super.set(id, value);\n\t}\n\n\t/**\n\t * Wraps Collection's sweep method to clear the interval when this manager is empty.\n\t */\n\tpublic sweep(): void {\n\t\tfor (const [id, value] of this.entries()) {\n\t\t\tif (value.expired) this.delete(id);\n\t\t}\n\n\t\tif (this.size === 0) {\n\t\t\tTimerManager.clearInterval(this.sweepInterval!);\n\t\t\tthis.sweepInterval = null;\n\t\t}\n\t}\n\n\t/**\n\t * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.\n\t */\n\tpublic static sweepIntervalDuration = 30_000;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,sBAA4B;AAAA,EAmB3B,YAAY,SAA8B;AAf1C;AAKA;AAKC;AAMP,SAAK,UAAU;AACf,SAAK,MAAM;AAAA,EACZ;AAAA,MAKW,UAAmB;AAC7B,WAAO,KAAK,kBAAkB;AAAA,EAC/B;AAAA,MAKW,UAAmB;AAC7B,WAAO,KAAK,cAAc,KAAK,CAAC,KAAK;AAAA,EACtC;AAAA,MAKW,gBAAwB;AAClC,WAAO,KAAK,IAAI,KAAK,UAAU,KAAK,IAAI,GAAG,CAAC;AAAA,EAC7C;AAAA,EAKO,UAAgB;AACtB,QAAI,KAAK;AAAS,YAAM,IAAI,MAAM,iCAAiC;AACnE,QAAI,KAAK;AAAS,WAAK,MAAM;AAE7B,SAAK;AACL,WAAO;AAAA,EACR;AAAA,EAKO,QAAc;AACpB,WAAO,KAAK,eAAe,EAAE,UAAU;AAAA,EACxC;AAAA,EAKO,iBAAuB;AAC7B,SAAK,YAAY,KAAK,QAAQ;AAC9B,WAAO;AAAA,EACR;AAAA,EAKO,YAAkB;AACxB,SAAK,UAAU,KAAK,IAAI,IAAI,KAAK,QAAQ;AACzC,WAAO;AAAA,EACR;AACD;AA9EO;;ACFP,4BAA6B;AAGtB,sCAA2C,IAAqB;AAAA,EAoB/D,YAAY,MAAc,QAAQ,GAAG;AAC3C,UAAM;AAjBS;AAKA;AAKR;AASP,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACd;AAAA,EAMO,QAAQ,IAAqB;AACnC,WAAO,KAAK,IAAI,EAAE,KAAK,KAAK,OAAO,EAAE;AAAA,EACtC;AAAA,EAMO,OAAO,IAAqB;AAClC,UAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,SAAK,IAAI,IAAI,KAAK;AAClB,WAAO;AAAA,EACR;AAAA,EAOgB,IAAI,IAAO,OAA2B;AACrD,SAAK,iBAAL,MAAK,gBAAkB,mCAAa,YAAY,KAAK,MAAM,KAAK,IAAI,GAAG,kBAAiB,qBAAqB;AAC7G,WAAO,MAAM,IAAI,IAAI,KAAK;AAAA,EAC3B;AAAA,EAKO,QAAc;AACpB,eAAW,CAAC,IAAI,UAAU,KAAK,QAAQ,GAAG;AACzC,UAAI,MAAM;AAAS,aAAK,OAAO,EAAE;AAAA,IAClC;AAEA,QAAI,KAAK,SAAS,GAAG;AACpB,yCAAa,cAAc,KAAK,aAAc;AAC9C,WAAK,gBAAgB;AAAA,IACtB;AAAA,EACD;AAMD;AAzEO;AAwEQ,cAxER,kBAwEQ,yBAAwB;","names":[]}